trees_all <- trees_all[!trees_all$sp == "pist", ]
lmm.nullsp <- lmer(resist.value ~ 1 + (1 | sp / tree), data=trees_all, REML=FALSE)
lmm.nullyear <- lmer(resist.value ~ 1 + (1 | year), data=trees_all, REML=FALSE)
lmm.random <- lmer(resist.value ~ 1 + (1 | sp / tree) + (1 | year), data=trees_all, REML=FALSE)
lmm.positionsp <- lmer(resist.value ~ position + (1 | sp / tree), data=trees_all, REML=FALSE)
lmm.positionyear <- lmer(resist.value ~ position + (1 | year), data=trees_all, REML=FALSE)
lmm.full <- lmer(resist.value ~ position + (1 | sp / tree) + (1 | year), data=trees_all, REML=FALSE)
#add tlp
lmm.tlpsp <- lmer(resist.value ~ tlp + (1 | sp), data=trees_all, REML=FALSE)
lmm.tlpyear <- lmer(resist.value ~ tlp + (1 | year), data=trees_all, REML=FALSE)
#lmm.fixed <- lmer(resist.value ~ position + tlp, data=trees_all, REML=FALSE)
#not technically a mixed effects model because no random effects
lmm.fixedsp <- lmer(resist.value ~ position + tlp + (1 | sp), data=trees_all, REML=FALSE)
lmm.fixedyear <- lmer(resist.value ~ position + tlp + (1 | year), data=trees_all, REML=FALSE)
lmm.combined <- lmer(resist.value ~ position + tlp + (1 | sp) + (1 | year), data=trees_all, REML=FALSE)
cand.models <- list(lmm.nullsp, lmm.nullyear, lmm.random, lmm.positionsp, lmm.positionyear, lmm.full, lmm.tlpsp, lmm.tlpyear, lmm.fixedsp, lmm.fixedyear, lmm.combined)
names(cand.models) <- c("lmm.nullsp", "lmm.nullyear", "lmm.random", "lmm.positionsp", "lmm.positionyear", "lmm.full", "lmm.tlpsp", "lmm.tlpyear", "lmm.fixedsp", "lmm.fixedyear", "lmm.combined")
#this function looks through all the models above to say what is the best one (what fits the best)
var_aic <- aictab(cand.models, second.ord=TRUE, sort=TRUE)
View(var_aic)
#What this plot does is create a dashed horizontal line representing zero: an average of zero deviation from the best-fit line. It also creates a solid line that represents the residual deviation from the best-fit line.
# If the solid line doesn't cover the dashed line, that would mean the best-fit line does not fit particularly well.
plot(fitted(lmm.combined), residuals(lmm.combined), xlab = "Fitted Values", ylab = "Residuals")
abline(h=0, lty=2)
lines(smooth.spline(fitted(lmm.combined), residuals(lmm.combined)))
trees_all$resist.value.t <- trees_all$resist.value + 1
qqp(trees_all$resist.value.t, "norm")
qqp(trees_all$resist.value, "norm")
#1 convert intraannual growth to dbh####
setwd("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/Dendrobands/data")
dirs <- dir("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/Dendrobands/data", pattern="_201[0-8]*.csv")
years <- c(2010:2018)
#1a. this loop breaks up each year's dendroband trees into separate dataframes by stemID ####
all_years <- list()
for (k in seq(along=dirs)){
file <- dirs[[k]]
yr <- read.csv(file, stringsAsFactors = FALSE)
yr_intra <- yr[yr$intraannual==1, ]
yr_intra$dbh <- as.numeric(yr_intra$dbh)
all_years[[k]] <- split(yr_intra, yr_intra$stemID)
#  if (file == dirs[[1]]){
#   all_years[[k]] <- split(yr, yr$stemID)
#  }
#  else{
#    all_years[[k]] <- split(yr_intra, yr_intra$stemID)
#  }
}
tent_name <- paste0("trees", sep="_", years)
names(all_years) <- tent_name
#the below loop takes all the unique stemIDs from each year and rbinds them.
all_stems <- list()
for(stemID in sort(unique(unlist(sapply(all_years, names))))) {
all_stems[[paste0("stemID_", stemID)]] <-  do.call(rbind, lapply(years, function(year) all_years[[paste0("trees", sep="_", year)]][[stemID]]))
}
#sort(unique(unlist(sapply(all_years, names)))) -> an explainer:
#sapply says find all the names within all_years
#unlist says take all those names (all those stemIDS) and dump them all together
#unique gets rid of the duplicates, and sort sorts them
#need to call in Condit's functions (also saved in separate R code) for the next bit
objectiveFuncDendro= function(diameter2,diameter1,gap1,gap2){
if(gap1>diameter1) return(20)
if(gap2>diameter2) return(20)
delta=abs(diameter1 - diameter2 + (1/pi) * diameter2 * asin(gap2/diameter2) - (1/pi) * diameter1 * asin(gap1/diameter1))
return(return(delta))
}
findOneDendroDBH= function(dbh1,m1,m2,func=objectiveFuncDendro){
if(is.na(dbh1)|is.na(m1)|is.na(m2)|dbh1<=0) return(NA)
if(m2>0) upper=dbh1+m2
else upper=dbh1+1
if(m2<m1) lower=0
else lower=dbh1
result=optimize(f=func,interval=c(lower,upper),diameter1=dbh1,gap1=m1,gap2=m2)
return(result$minimum)
}
findDendroDBH= function(dbh1,m1,m2,func=objectiveFuncDendro){
records=max(length(dbh1),length(m1),length(m2))
if(length(dbh1)==1) dbh1=rep(dbh1,records)
if(length(m1)==1) m1=rep(m1,records)
if(length(m2)==1) m2=rep(m2,records)
dbh2=numeric()
for(i in 1:records) dbh2[i]=findOneDendroDBH(dbh1[i],m1[i],m2[i],func)
return(dbh2)
}
devtools::install_github("seanmcm/RDendrom")
library(RDendrom)
test_intra <- all_stems$stemID_7444
library(data.table)
test_intra <- setnames(test_intra,
old=c("treeID", "dendroID", "stemID", "sp", "dbh", "measure", "year", "new.band"),
new=c("TREE_ID", "BAND_NUM", "UNIQUE_ID", "SP", "ORG_DBH", "GAP_WIDTH", "YEAR", "NEW_BAND"))
newcols <- c("SKIP", "ADJUST", "REMOVE")
test_intra[,newcols] <- 0
test_intra$SITE <- "SCBI"
test_intra$ORG_DBH <- test_intra$ORG_DBH/10
library(lubridate)
test_intra$DOY <- as.Date(with(test_intra, paste(YEAR, month, day, sep="-")), "%Y-%m-%d")
test_intra$DOY <- yday(test_intra$DOY)
test_intra$SITE <- "SCBI"
get.optimized.dendro(test_intra, units="cm", OUTPUT.folder = "C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/Dendrobands/results/McMahon_code_output")
test_intra <- all_stems$stemID_10045
library(data.table)
test_intra <- setnames(test_intra,
old=c("treeID", "dendroID", "stemID", "sp", "dbh", "measure", "year", "new.band"),
new=c("TREE_ID", "BAND_NUM", "UNIQUE_ID", "SP", "ORG_DBH", "GAP_WIDTH", "YEAR", "NEW_BAND"))
newcols <- c("SKIP", "ADJUST", "REMOVE")
test_intra[,newcols] <- 0
test_intra$SITE <- "SCBI"
test_intra$ORG_DBH <- test_intra$ORG_DBH/10
library(lubridate)
test_intra$DOY <- as.Date(with(test_intra, paste(YEAR, month, day, sep="-")), "%Y-%m-%d")
test_intra$DOY <- yday(test_intra$DOY)
test_intra$SITE <- "SCBI"
get.optimized.dendro(test_intra, units="cm", OUTPUT.folder = "C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/Dendrobands/results/McMahon_code_output")
band.index <- as.numeric(table(test_intra$BAND_NUM))
test_intra$BAND_NUM <- unlist(mapply(rep, seq(length(band.index)), length.out = band.index))
test_intra$BAND_NUM
View(test_intra)
get.optimized.dendro(test_intra, OUTPUT.folder = "C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/Dendrobands/results/McMahon_code_output")
test_intra <- all_stems$stemID_7444
library(data.table)
test_intra <- setnames(test_intra,
old=c("treeID", "stemID", "sp", "dbh", "measure", "year", "new.band"),
new=c("TREE_ID", "UNIQUE_ID", "SP", "ORG_DBH", "GAP_WIDTH", "YEAR", "NEW_BAND"))
newcols <- c("SKIP", "ADJUST", "REMOVE")
test_intra[,newcols] <- 0
test_intra$SITE <- "SCBI"
test_intra$ORG_DBH <- test_intra$ORG_DBH/10
library(lubridate)
test_intra$DOY <- as.Date(with(test_intra, paste(YEAR, month, day, sep="-")), "%Y-%m-%d")
test_intra$DOY <- yday(test_intra$DOY)
test_intra$SITE <- "SCBI"
band.index <- as.numeric(table(test_intra$dendroID))
test_intra$BAND_NUM <- unlist(mapply(rep, seq(length(band.index)), length.out = band.index))
test_intra <- subset(test_intra, complete.cases(test_intra$GAP_WIDTH))
#1 convert intraannual growth to dbh####
setwd("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/Dendrobands/data")
dirs <- dir("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/Dendrobands/data", pattern="_201[0-8]*.csv")
years <- c(2010:2018)
#1a. this loop breaks up each year's dendroband trees into separate dataframes by stemID ####
all_years <- list()
for (k in seq(along=dirs)){
file <- dirs[[k]]
yr <- read.csv(file, stringsAsFactors = FALSE)
yr_intra <- yr[yr$intraannual==1, ]
yr_intra$dbh <- as.numeric(yr_intra$dbh)
all_years[[k]] <- split(yr_intra, yr_intra$stemID)
#  if (file == dirs[[1]]){
#   all_years[[k]] <- split(yr, yr$stemID)
#  }
#  else{
#    all_years[[k]] <- split(yr_intra, yr_intra$stemID)
#  }
}
tent_name <- paste0("trees", sep="_", years)
names(all_years) <- tent_name
#the below loop takes all the unique stemIDs from each year and rbinds them.
all_stems <- list()
for(stemID in sort(unique(unlist(sapply(all_years, names))))) {
all_stems[[paste0("stemID_", stemID)]] <-  do.call(rbind, lapply(years, function(year) all_years[[paste0("trees", sep="_", year)]][[stemID]]))
}
#sort(unique(unlist(sapply(all_years, names)))) -> an explainer:
#sapply says find all the names within all_years
#unlist says take all those names (all those stemIDS) and dump them all together
#unique gets rid of the duplicates, and sort sorts them
#need to call in Condit's functions (also saved in separate R code) for the next bit
objectiveFuncDendro= function(diameter2,diameter1,gap1,gap2){
if(gap1>diameter1) return(20)
if(gap2>diameter2) return(20)
delta=abs(diameter1 - diameter2 + (1/pi) * diameter2 * asin(gap2/diameter2) - (1/pi) * diameter1 * asin(gap1/diameter1))
return(return(delta))
}
findOneDendroDBH= function(dbh1,m1,m2,func=objectiveFuncDendro){
if(is.na(dbh1)|is.na(m1)|is.na(m2)|dbh1<=0) return(NA)
if(m2>0) upper=dbh1+m2
else upper=dbh1+1
if(m2<m1) lower=0
else lower=dbh1
result=optimize(f=func,interval=c(lower,upper),diameter1=dbh1,gap1=m1,gap2=m2)
return(result$minimum)
}
findDendroDBH= function(dbh1,m1,m2,func=objectiveFuncDendro){
records=max(length(dbh1),length(m1),length(m2))
if(length(dbh1)==1) dbh1=rep(dbh1,records)
if(length(m1)==1) m1=rep(m1,records)
if(length(m2)==1) m2=rep(m2,records)
dbh2=numeric()
for(i in 1:records) dbh2[i]=findOneDendroDBH(dbh1[i],m1[i],m2[i],func)
return(dbh2)
}
library(RDendrom)
test_intra <- all_stems$stemID_7444
library(data.table)
test_intra <- setnames(test_intra,
old=c("treeID", "stemID", "sp", "dbh", "measure", "year", "new.band"),
new=c("TREE_ID", "UNIQUE_ID", "SP", "ORG_DBH", "GAP_WIDTH", "YEAR", "NEW_BAND"))
newcols <- c("SKIP", "ADJUST", "REMOVE")
test_intra[,newcols] <- 0
test_intra$SITE <- "SCBI"
test_intra$ORG_DBH <- test_intra$ORG_DBH/10
library(lubridate)
test_intra$DOY <- as.Date(with(test_intra, paste(YEAR, month, day, sep="-")), "%Y-%m-%d")
test_intra$DOY <- yday(test_intra$DOY)
test_intra$SITE <- "SCBI"
band.index <- as.numeric(table(test_intra$dendroID))
test_intra$BAND_NUM <- unlist(mapply(rep, seq(length(band.index)), length.out = band.index))
test_intra <- subset(test_intra, complete.cases(test_intra$GAP_WIDTH))
View(test_intra)
get.optimized.dendro(test_intra, OUTPUT.folder = "C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/Dendrobands/results/McMahon_code_output")
param.table.name = "Param_table.csv"
Dendro.data.name = "Dendro_data.Rdata"
Dendro.split.name = "Dendro_data_split.Rdata"
OUTPUT.folder <- "C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/Dendrobands/results/McMahon_code_output"
param.table <- read.csv(file = paste(OUTPUT.folder, param.table.name, sep = "/"))
load(file = paste(OUTPUT.folder, Dendro.data.name, sep = "/")) # loads Dendro.complete
load(file = paste(OUTPUT.folder, Dendro.split.name, sep = "/")) #loads Dendro.split
load(file = paste(OUTPUT.folder, "Dendro_Tree.Rdata", sep = "/")) #loads Dendro.tree
get.extra.metrics(param.table, Dendro.split, OUTPUT.folder = OUTPUT.folder)
param.table.extended <- read.csv(file = paste(OUTPUT.folder, param.table.name, sep = "/"))
View(param.table.extended)
View(param.table)
View(Dendro.tree)
View(Dendro.split)
##6b. graphs
make.dendro.plot.ts(ts.data = Dendro.split[[3]], params = param.table[3, ], day = seq(365))
View(Dendro.split)
make.dendro.plot.tree(Dendro.ind = Dendro.tree[[1]], param.tab = subset(param.table, TREE_ID == Dendro.tree[[1]]$TREE_ID[1]))
View(test_intra)
test_intra <- all_stems$stemID_10045
library(data.table)
test_intra <- setnames(test_intra,
old=c("treeID", "stemID", "sp", "dbh", "measure", "year", "new.band"),
new=c("TREE_ID", "UNIQUE_ID", "SP", "ORG_DBH", "GAP_WIDTH", "YEAR", "NEW_BAND"))
newcols <- c("SKIP", "ADJUST", "REMOVE")
test_intra[,newcols] <- 0
test_intra$SITE <- "SCBI"
test_intra$ORG_DBH <- test_intra$ORG_DBH/10
library(lubridate)
test_intra$DOY <- as.Date(with(test_intra, paste(YEAR, month, day, sep="-")), "%Y-%m-%d")
test_intra$DOY <- yday(test_intra$DOY)
test_intra$SITE <- "SCBI"
#creates separate column creating band numbers starting at 1, then increasing by 1 for each NEW_BAND=1 change
band.index <- as.numeric(table(test_intra$dendroID))
test_intra$BAND_NUM <- unlist(mapply(rep, seq(length(band.index)), length.out = band.index))
#remove NAs in caliper measurements
test_intra <- subset(test_intra, complete.cases(test_intra$GAP_WIDTH))
get.optimized.dendro(test_intra, OUTPUT.folder = "C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/Dendrobands/results/McMahon_code_output")
param.table.name = "Param_table.csv"
Dendro.data.name = "Dendro_data.Rdata"
Dendro.split.name = "Dendro_data_split.Rdata"
OUTPUT.folder <- "C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/Dendrobands/results/McMahon_code_output"
param.table <- read.csv(file = paste(OUTPUT.folder, param.table.name, sep = "/"))
load(file = paste(OUTPUT.folder, Dendro.data.name, sep = "/")) # loads Dendro.complete
load(file = paste(OUTPUT.folder, Dendro.split.name, sep = "/")) #loads Dendro.split
load(file = paste(OUTPUT.folder, "Dendro_Tree.Rdata", sep = "/")) #loads Dendro.tree
get.extra.metrics(param.table, Dendro.split, OUTPUT.folder = OUTPUT.folder)
param.table.extended <- read.csv(file = paste(OUTPUT.folder, param.table.name, sep = "/"))
##6b. graphs
make.dendro.plot.ts(ts.data = Dendro.split[[3]], params = param.table[3, ], day = seq(365))
View(Dendro.split)
?make.dendro.plot.ts
?get.optimized.dendro
test_intra <- all_stems$stemID_7444
library(data.table)
test_intra <- setnames(test_intra,
old=c("treeID", "stemID", "sp", "dbh", "measure", "year", "new.band"),
new=c("TREE_ID", "UNIQUE_ID", "SP", "ORG_DBH", "GAP_WIDTH", "YEAR", "NEW_BAND"))
newcols <- c("SKIP", "ADJUST", "REMOVE")
test_intra[,newcols] <- 0
test_intra$SITE <- "SCBI"
test_intra$ORG_DBH <- test_intra$ORG_DBH/10
library(lubridate)
test_intra$DOY <- as.Date(with(test_intra, paste(YEAR, month, day, sep="-")), "%Y-%m-%d")
test_intra$DOY <- yday(test_intra$DOY)
test_intra$SITE <- "SCBI"
#creates separate column creating band numbers starting at 1, then increasing by 1 for each NEW_BAND=1 change
band.index <- as.numeric(table(test_intra$dendroID))
test_intra$BAND_NUM <- unlist(mapply(rep, seq(length(band.index)), length.out = band.index))
#remove NAs in caliper measurements
test_intra <- subset(test_intra, complete.cases(test_intra$GAP_WIDTH))
get.optimized.dendro(test_intra, OUTPUT.folder = "C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/Dendrobands/results/McMahon_code_output")
param.table.name = "Param_table.csv"
Dendro.data.name = "Dendro_data.Rdata"
Dendro.split.name = "Dendro_data_split.Rdata"
OUTPUT.folder <- "C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/Dendrobands/results/McMahon_code_output"
param.table <- read.csv(file = paste(OUTPUT.folder, param.table.name, sep = "/"))
load(file = paste(OUTPUT.folder, Dendro.data.name, sep = "/")) # loads Dendro.complete
load(file = paste(OUTPUT.folder, Dendro.split.name, sep = "/")) #loads Dendro.split
load(file = paste(OUTPUT.folder, "Dendro_Tree.Rdata", sep = "/")) #loads Dendro.tree
get.extra.metrics(param.table, Dendro.split, OUTPUT.folder = OUTPUT.folder)
param.table.extended <- read.csv(file = paste(OUTPUT.folder, param.table.name, sep = "/"))
View(Dendro.split)
test_intra <- all_stems$stemID_10045
library(data.table)
test_intra <- setnames(test_intra,
old=c("treeID", "stemID", "sp", "dbh", "measure", "year", "new.band"),
new=c("TREE_ID", "UNIQUE_ID", "SP", "ORG_DBH", "GAP_WIDTH", "YEAR", "NEW_BAND"))
newcols <- c("SKIP", "ADJUST", "REMOVE")
test_intra[,newcols] <- 0
test_intra$SITE <- "SCBI"
test_intra$ORG_DBH <- test_intra$ORG_DBH/10
library(lubridate)
test_intra$DOY <- as.Date(with(test_intra, paste(YEAR, month, day, sep="-")), "%Y-%m-%d")
test_intra$DOY <- yday(test_intra$DOY)
test_intra$SITE <- "SCBI"
#creates separate column creating band numbers starting at 1, then increasing by 1 for each NEW_BAND=1 change
band.index <- as.numeric(table(test_intra$dendroID))
test_intra$BAND_NUM <- unlist(mapply(rep, seq(length(band.index)), length.out = band.index))
#remove NAs in caliper measurements
test_intra <- subset(test_intra, complete.cases(test_intra$GAP_WIDTH))
get.optimized.dendro(test_intra, OUTPUT.folder = "C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/Dendrobands/results/McMahon_code_output")
param.table.name = "Param_table.csv"
Dendro.data.name = "Dendro_data.Rdata"
Dendro.split.name = "Dendro_data_split.Rdata"
OUTPUT.folder <- "C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/Dendrobands/results/McMahon_code_output"
param.table <- read.csv(file = paste(OUTPUT.folder, param.table.name, sep = "/"))
load(file = paste(OUTPUT.folder, Dendro.data.name, sep = "/")) # loads Dendro.complete
load(file = paste(OUTPUT.folder, Dendro.split.name, sep = "/")) #loads Dendro.split
load(file = paste(OUTPUT.folder, "Dendro_Tree.Rdata", sep = "/")) #loads Dendro.tree
get.extra.metrics(param.table, Dendro.split, OUTPUT.folder = OUTPUT.folder)
param.table.extended <- read.csv(file = paste(OUTPUT.folder, param.table.name, sep = "/"))
View(Dendro.split)
View(Dendro.tree)
View(Dendro.complete)
View(Dendro.tree)
View(Dendro.tree[[1]])
##6b. graphs
make.dendro.plot.ts(ts.data = Dendro.split[[3]], params = param.table[3, ], day = seq(365))
make.dendro.plot.tree(Dendro.ind = Dendro.tree[[1]], param.tab = subset(param.table, TREE_ID == Dendro.tree[[1]]$TREE_ID[1]))
?res.comp
library(pointRes)
?res.comp
#4. finding pointer years and resistance metrics ####
library(pointRes)
library(dplR)
library(data.table)
##4a. canopy ####
setwd("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/SCBI-ForestGEO-Data/tree_cores/chronologies/current_chronologies/complete/separated by canopy position/canopy_cores")
dirs_can <- dir("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/SCBI-ForestGEO-Data/tree_cores/chronologies/current_chronologies/complete/separated by canopy position/canopy_cores", pattern = "_canopy.rwl")
dirs_can <- dirs_can[dirs_can != "frni_canopy.rwl" & dirs_can != "frni_drop_canopy.rwl" & dirs_can != "caco_drop_canopy.rwl"]
sp_can <- gsub("_drop_canopy.rwl", "", dirs_can)
canopy <- list()
canopy_table <- NULL
for (i in seq(along=dirs_can)){
for (j in seq(along=sp_can)){
if (i==j){
file <- dirs_can[[i]]
rings <- read.rwl(file) #read in rwl file
area <- bai.in(rings) #convert to bai.in
testr <- res.comp(area, nb.yrs=5, res.thresh.neg = 30, series.thresh = 50) #get resilience metrics
canopy[[i]] <- testr
testr_table <- data.frame(testr$out)
testr_table <- testr_table[testr_table$nb.series > 4, ] #remove where there are < 4 series
testr_table$sp <- sp_can[[j]]
testr_table$position <- "canopy"
canopy_table <- rbind(canopy_table, testr_table)
}
values <- paste0(sp_can, "_can_res")
names(canopy) <- values
##4b. subcanopy ####
setwd("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/SCBI-ForestGEO-Data/tree_cores/chronologies/current_chronologies/complete/separated by canopy position/subcanopy_cores")
dirs_subcan <- dir("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/SCBI-ForestGEO-Data/tree_cores/chronologies/current_chronologies/complete/separated by canopy position/subcanopy_cores", pattern = "_subcanopy.rwl")
dirs_subcan <- dirs_subcan[dirs_subcan != "frni_drop_subcanopy.rwl" & dirs_subcan != "caco_drop_subcanopy.rwl"]
sp_subcan <- gsub("_drop_subcanopy.rwl", "", dirs_subcan)
subcanopy <- list()
subcanopy_table <- NULL
for (i in seq(along=dirs_subcan)){
for (j in seq(along=sp_subcan)){
if (i==j){
file <- dirs_subcan[[i]]
rings <- read.rwl(file) #read in rwl file
area <- bai.in(rings) #convert to bai.in
test <- res.comp(area, nb.yrs=5, res.thresh.neg = 30, series.thresh = 50) #get resilience metrics
subcanopy[[i]] <- test
test_table <- data.frame(test$out)
test_table <- test_table[test_table$nb.series > 4, ] #remove where there are < 4 series
test_table$sp <- sp_subcan[[j]]
test_table$position <- "subcanopy"
subcanopy_table <- rbind(subcanopy_table, test_table)
}
values_sub <- paste0(sp_subcan, "_subcan_res")
names(subcanopy) <- values_sub
##4c. df for pointer years of all trees combined ####
full_ind <- rbind(canopy_table, subcanopy_table) #full table of indices for canopy and subcanopy cores
pointers <- full_ind[full_ind$nature == -1, ]
library(dplyr)
years_point <- count(pointers, vars=year) #counts the occurrences of each unique year
colnames(years_point) <- c("yr", "n.pointer")
years_point <- years_point[order(years_point$n.pointer, decreasing=TRUE), ]
setwd("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/McGregor_climate-sensitivity-variation")
#write.csv(pointers, "occurrence_of_pointer_yrs.csv", row.names=FALSE)
##4d. resistance metrics for all trees ####
neil_list <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/McGregor_climate-sensitivity-variation/core_list_for_neil.csv", stringsAsFactors = FALSE)
neil_list$tag <- paste0("X", neil_list$tag) #to match the colnames of can_resist below
pointer_years <- years_point$yr[1:6] #from above in #3c
##canopy ####
#this loop says, for the different species in the list "canopy" (names(canopy)), create a dataframe of only the resistance index. Make a list of the colnames, which are the individual trees. Then, assign species identifiers for each one from Neil's core list, subset by the defined pointer years, and melt the data before rbinding.
tag_n <- names(canopy)
trees_canopy <- NULL
for (i in seq(along=1:length(tag_n))){
can_resist <- data.frame(canopy[[i]]$resist)
years <- rownames(can_resist)
colnames(can_resist) <- gsub("A", "", colnames(can_resist))
tree_series <- colnames(can_resist)
# for (j in seq(along=tree_series)){
#  trees <- tree_series[[j]]
ind <- can_resist
ind_neil <- neil_list[neil_list$tag %in% tree_series, ]
#  colnames(ind) <- trees
ind$year <- years
ind$sp <- unique(ind_neil$sp)
ind$position <- "canopy"
ind <- ind[ind$year %in% pointer_years, ]
change <- melt(ind)
setnames(change, old=c("variable", "value"), new=c("tree", "resist.value"))
change$tree <- gsub("X", "", change$tree)
change$tree <- gsub("^0", "", change$tree)
trees_canopy <- rbind(trees_canopy, change)
}
##subcanopy ####
#this loop says, for the different species in the list "subcanopy" (names(subcanopy)), create a dataframe of only the resistance index. Make a list of the colnames, which are the individual trees. Then, assign species identifiers for each one from Neil's core list, subset by the defined pointer years, and melt the data before rbinding.
tag_n <- names(subcanopy)
trees_subcanopy <- NULL
for (i in seq(along=1:length(tag_n))){
sub_resist <- data.frame(subcanopy[[i]]$resist)
years <- rownames(sub_resist)
colnames(sub_resist) <- gsub("A", "", colnames(sub_resist))
tree_series <- colnames(sub_resist)
# for (j in seq(along=tree_series)){
#  trees <- tree_series[[j]]
ind <- sub_resist
ind_neil <- neil_list[neil_list$tag %in% tree_series, ]
#  colnames(ind) <- trees
ind$year <- years
ind$sp <- unique(ind_neil$sp)
ind$position <- "subcanopy"
ind <- ind[ind$year %in% pointer_years, ]
change <- melt(ind)
setnames(change, old=c("variable", "value"), new=c("tree", "resist.value"))
change$tree <- gsub("X", "", change$tree)
change$tree <- gsub("^0", "", change$tree)
trees_subcanopy <- rbind(trees_subcanopy, change)
}
##rbind together ####
trees_all <- rbind(trees_canopy, trees_subcanopy)
trees_all$year <- as.numeric(trees_all$year)
lmm.nullsp <- lmer(resist.value ~ 1 + (1 | sp / tree), data=trees_all, REML=FALSE)
lmm.nullyear <- lmer(resist.value ~ 1 + (1 | year), data=trees_all, REML=FALSE)
lmm.random <- lmer(resist.value ~ 1 + (1 | sp / tree) + (1 | year), data=trees_all, REML=FALSE)
lmm.positionsp <- lmer(resist.value ~ position + (1 | sp / tree), data=trees_all, REML=FALSE)
lmm.positionyear <- lmer(resist.value ~ position + (1 | year), data=trees_all, REML=FALSE)
lmm.full <- lmer(resist.value ~ position + (1 | sp / tree) + (1 | year), data=trees_all, REML=FALSE)
#add tlp
lmm.tlpsp <- lmer(resist.value ~ tlp + (1 | sp), data=trees_all, REML=FALSE)
lmm.tlpyear <- lmer(resist.value ~ tlp + (1 | year), data=trees_all, REML=FALSE)
#lmm.fixed <- lmer(resist.value ~ position + tlp, data=trees_all, REML=FALSE)
#not technically a mixed effects model because no random effects
lmm.fixedsp <- lmer(resist.value ~ position + tlp + (1 | sp), data=trees_all, REML=FALSE)
lmm.fixedyear <- lmer(resist.value ~ position + tlp + (1 | year), data=trees_all, REML=FALSE)
lmm.combined <- lmer(resist.value ~ position + tlp + (1 | sp) + (1 | year), data=trees_all, REML=FALSE)
cand.models <- list(lmm.nullsp, lmm.nullyear, lmm.random, lmm.positionsp, lmm.positionyear, lmm.full, lmm.tlpsp, lmm.tlpyear, lmm.fixedsp, lmm.fixedyear, lmm.combined)
names(cand.models) <- c("lmm.nullsp", "lmm.nullyear", "lmm.random", "lmm.positionsp", "lmm.positionyear", "lmm.full", "lmm.tlpsp", "lmm.tlpyear", "lmm.fixedsp", "lmm.fixedyear", "lmm.combined")
#this function looks through all the models above to say what is the best one (what fits the best)
var_aic <- aictab(cand.models, second.ord=TRUE, sort=TRUE)
library(lme4)
library(AICcmodavg)
library(car)
lmm.nullsp <- lmer(resist.value ~ 1 + (1 | sp / tree), data=trees_all, REML=FALSE)
lmm.nullyear <- lmer(resist.value ~ 1 + (1 | year), data=trees_all, REML=FALSE)
lmm.random <- lmer(resist.value ~ 1 + (1 | sp / tree) + (1 | year), data=trees_all, REML=FALSE)
lmm.positionsp <- lmer(resist.value ~ position + (1 | sp / tree), data=trees_all, REML=FALSE)
lmm.positionyear <- lmer(resist.value ~ position + (1 | year), data=trees_all, REML=FALSE)
lmm.full <- lmer(resist.value ~ position + (1 | sp / tree) + (1 | year), data=trees_all, REML=FALSE)
#add tlp
lmm.tlpsp <- lmer(resist.value ~ tlp + (1 | sp), data=trees_all, REML=FALSE)
lmm.tlpyear <- lmer(resist.value ~ tlp + (1 | year), data=trees_all, REML=FALSE)
#lmm.fixed <- lmer(resist.value ~ position + tlp, data=trees_all, REML=FALSE)
#not technically a mixed effects model because no random effects
lmm.fixedsp <- lmer(resist.value ~ position + tlp + (1 | sp), data=trees_all, REML=FALSE)
lmm.fixedyear <- lmer(resist.value ~ position + tlp + (1 | year), data=trees_all, REML=FALSE)
lmm.combined <- lmer(resist.value ~ position + tlp + (1 | sp) + (1 | year), data=trees_all, REML=FALSE)
cand.models <- list(lmm.nullsp, lmm.nullyear, lmm.random, lmm.positionsp, lmm.positionyear, lmm.full, lmm.tlpsp, lmm.tlpyear, lmm.fixedsp, lmm.fixedyear, lmm.combined)
names(cand.models) <- c("lmm.nullsp", "lmm.nullyear", "lmm.random", "lmm.positionsp", "lmm.positionyear", "lmm.full", "lmm.tlpsp", "lmm.tlpyear", "lmm.fixedsp", "lmm.fixedyear", "lmm.combined")
#this function looks through all the models above to say what is the best one (what fits the best)
var_aic <- aictab(cand.models, second.ord=TRUE, sort=TRUE)
lmm.nullsp <- lmer(resist.value ~ 1 + (1 | sp / tree), data=trees_all, REML=FALSE)
lmm.nullyear <- lmer(resist.value ~ 1 + (1 | year), data=trees_all, REML=FALSE)
lmm.random <- lmer(resist.value ~ 1 + (1 | sp / tree) + (1 | year), data=trees_all, REML=FALSE)
lmm.positionsp <- lmer(resist.value ~ position + (1 | sp / tree), data=trees_all, REML=FALSE)
lmm.positionyear <- lmer(resist.value ~ position + (1 | year), data=trees_all, REML=FALSE)
lmm.full <- lmer(resist.value ~ position + (1 | sp / tree) + (1 | year), data=trees_all, REML=FALSE)
cand.models <- list(lmm.nullsp, lmm.nullyear, lmm.random, lmm.positionsp, lmm.positionyear, lmm.full) #, lmm.tlpsp, lmm.tlpyear, lmm.fixedsp, lmm.fixedyear, lmm.combined)
names(cand.models) <- c("lmm.nullsp", "lmm.nullyear", "lmm.random", "lmm.positionsp", "lmm.positionyear", "lmm.full") #, "lmm.tlpsp", "lmm.tlpyear", "lmm.fixedsp", "lmm.fixedyear", "lmm.combined")
#this function looks through all the models above to say what is the best one (what fits the best)
var_aic <- aictab(cand.models, second.ord=TRUE, sort=TRUE)
##5c. Run the best model, changing REML to TRUE ####
lmm.full <- lmer(resist.value ~ position + (1 | sp) + (1 | year), data=trees_all)
summary(lmm.full)
p <- ggplot(trees_all, aes(x=resist.value)) +
geom_density() +
facet_wrap(position ~ year)
ggplot(trees_all, aes(x=resist.value)) +
geom_density() +
facet_wrap(position ~ year)
group_by()
?group_by
trees_all <- group_by(trees_all, year, position)
ggplot(trees_all, aes(x=resist.value)) +
geom_density() +
facet_wrap(position ~ year)
ggplot(trees_all, aes(x=resist.value)) +
geom_density() +
facet_wrap(year ~ position)
