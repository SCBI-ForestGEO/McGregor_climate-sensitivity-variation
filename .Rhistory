test_table <- data.frame(test$out)
test_table <- test_table[test_table$nb.series > 4, ] #remove where there are < 4 series
test_table$sp <- sp_subcan[[j]]
test_table$position <- "subcanopy"
subcanopy_table <- rbind(subcanopy_table, test_table)
}
values_sub <- paste0(sp_subcan, "_subcan_res")
names(subcanopy) <- values_sub
##4c. df for pointer years of all trees combined ####
full_ind <- rbind(canopy_table, subcanopy_table) #full table of indices for canopy and subcanopy cores
pointers <- full_ind[full_ind$nature == -1, ]
library(dplyr)
years_point <- count(pointers, vars=year) #counts the occurrences of each unique year
colnames(years_point) <- c("yr", "n.pointer")
years_point <- years_point[order(years_point$n.pointer, decreasing=TRUE), ]
setwd("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/McGregor_climate-sensitivity-variation")
#write.csv(pointers, "occurrence_of_pointer_yrs.csv", row.names=FALSE)
##4d. resistance metrics for all trees ####
neil_list <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/McGregor_climate-sensitivity-variation/core_list_for_neil.csv", stringsAsFactors = FALSE)
neil_list$tag <- paste0("X", neil_list$tag) #to match the colnames of can_resist below
pointer_years <- years_point$yr[1:6] #from above in #3c
##canopy ####
#this loop says, for the different species in the list "canopy" (names(canopy)), create a dataframe of only the resistance index. Make a list of the colnames, which are the individual trees. Then, assign species identifiers for each one from Neil's core list, subset by the defined pointer years, and melt the data before rbinding.
tag_n <- names(canopy)
trees_canopy <- NULL
for (i in seq(along=1:length(tag_n))){
can_resist <- data.frame(canopy[[i]]$resist)
years <- rownames(can_resist)
colnames(can_resist) <- gsub("A", "", colnames(can_resist))
tree_series <- colnames(can_resist)
# for (j in seq(along=tree_series)){
#  trees <- tree_series[[j]]
ind <- can_resist
ind_neil <- neil_list[neil_list$tag %in% tree_series, ]
#  colnames(ind) <- trees
ind$year <- years
ind$sp <- unique(ind_neil$sp)
ind$position <- "canopy"
ind <- ind[ind$year %in% pointer_years, ]
change <- melt(ind)
setnames(change, old=c("variable", "value"), new=c("tree", "resist.value"))
change$tree <- gsub("X", "", change$tree)
change$tree <- gsub("^0", "", change$tree)
trees_canopy <- rbind(trees_canopy, change)
}
##subcanopy ####
#this loop says, for the different species in the list "subcanopy" (names(subcanopy)), create a dataframe of only the resistance index. Make a list of the colnames, which are the individual trees. Then, assign species identifiers for each one from Neil's core list, subset by the defined pointer years, and melt the data before rbinding.
tag_n <- names(subcanopy)
trees_subcanopy <- NULL
for (i in seq(along=1:length(tag_n))){
sub_resist <- data.frame(subcanopy[[i]]$resist)
years <- rownames(sub_resist)
colnames(sub_resist) <- gsub("A", "", colnames(sub_resist))
tree_series <- colnames(sub_resist)
# for (j in seq(along=tree_series)){
#  trees <- tree_series[[j]]
ind <- sub_resist
ind_neil <- neil_list[neil_list$tag %in% tree_series, ]
#  colnames(ind) <- trees
ind$year <- years
ind$sp <- unique(ind_neil$sp)
ind$position <- "subcanopy"
ind <- ind[ind$year %in% pointer_years, ]
change <- melt(ind)
setnames(change, old=c("variable", "value"), new=c("tree", "resist.value"))
change$tree <- gsub("X", "", change$tree)
change$tree <- gsub("^0", "", change$tree)
trees_subcanopy <- rbind(trees_subcanopy, change)
}
##rbind together ####
trees_all <- rbind(trees_canopy, trees_subcanopy)
trees_all$year <- as.numeric(trees_all$year)
View(trees_all)
library(esquisse)
esquise::esquisser()
esquisse::esquisser()
ggplot(data = trees_all) +
aes(x = year, y = resist.value, color = sp) +
geom_point() +
theme_minimal() +
facet_wrap(vars(position))
?scale_fill_discrete
ggplot(data = trees_all) +
aes(x = year, y = resist.value, color = sp) +
geom_point() +
scale_fill_brewer(palette="rainbow")
library(RColorBrewer)
display.brewer.all()
ggplot(data = trees_all) +
aes(x = year, y = resist.value, color = sp) +
geom_point() +
scale_fill_brewer(palette="paired")
ggplot(data = trees_all) +
aes(x = year, y = resist.value, color = sp) +
geom_point() +
scale_fill_brewer(palette="paired") +
theme_minimal() +
facet_wrap(vars(position))
ggplot(trees_all, aes(x=resist.value)) +
geom_density() +
facet_wrap(year ~ position)
#
boxplot(resist.value ~ position, data=trees_all)
View(years_point)
View(pointers)
View(years_point)
#graph showing resistance value by species by year by canopy position
ggplot(data = trees_all) +
aes(x = year, y = resist.value, color = sp) +
geom_point() +
scale_color_brewer(palette="paired") +
theme_minimal() +
facet_wrap(vars(position))
#graph showing resistance value by species by year by canopy position
ggplot(data = trees_all) +
aes(x = year, y = resist.value, color = sp) +
geom_point() +
scale_color_brewer(palette="Paired") +
theme_minimal() +
facet_wrap(vars(position))
pointer_years <- years_point$yr[1:2,5] #from above in #3c
pointer_years <- years_point$yr[c(1:2,5)] #from above in #3c
##canopy ####
#this loop says, for the different species in the list "canopy" (names(canopy)), create a dataframe of only the resistance index. Make a list of the colnames, which are the individual trees. Then, assign species identifiers for each one from Neil's core list, subset by the defined pointer years, and melt the data before rbinding.
tag_n <- names(canopy)
trees_canopy <- NULL
for (i in seq(along=1:length(tag_n))){
can_resist <- data.frame(canopy[[i]]$resist)
years <- rownames(can_resist)
colnames(can_resist) <- gsub("A", "", colnames(can_resist))
tree_series <- colnames(can_resist)
# for (j in seq(along=tree_series)){
#  trees <- tree_series[[j]]
ind <- can_resist
ind_neil <- neil_list[neil_list$tag %in% tree_series, ]
#  colnames(ind) <- trees
ind$year <- years
ind$sp <- unique(ind_neil$sp)
ind$position <- "canopy"
ind <- ind[ind$year %in% pointer_years, ]
change <- melt(ind)
setnames(change, old=c("variable", "value"), new=c("tree", "resist.value"))
change$tree <- gsub("X", "", change$tree)
change$tree <- gsub("^0", "", change$tree)
trees_canopy <- rbind(trees_canopy, change)
}
##subcanopy ####
#this loop says, for the different species in the list "subcanopy" (names(subcanopy)), create a dataframe of only the resistance index. Make a list of the colnames, which are the individual trees. Then, assign species identifiers for each one from Neil's core list, subset by the defined pointer years, and melt the data before rbinding.
tag_n <- names(subcanopy)
trees_subcanopy <- NULL
for (i in seq(along=1:length(tag_n))){
sub_resist <- data.frame(subcanopy[[i]]$resist)
years <- rownames(sub_resist)
colnames(sub_resist) <- gsub("A", "", colnames(sub_resist))
tree_series <- colnames(sub_resist)
# for (j in seq(along=tree_series)){
#  trees <- tree_series[[j]]
ind <- sub_resist
ind_neil <- neil_list[neil_list$tag %in% tree_series, ]
#  colnames(ind) <- trees
ind$year <- years
ind$sp <- unique(ind_neil$sp)
ind$position <- "subcanopy"
ind <- ind[ind$year %in% pointer_years, ]
change <- melt(ind)
setnames(change, old=c("variable", "value"), new=c("tree", "resist.value"))
change$tree <- gsub("X", "", change$tree)
change$tree <- gsub("^0", "", change$tree)
trees_subcanopy <- rbind(trees_subcanopy, change)
}
##rbind together ####
trees_all <- rbind(trees_canopy, trees_subcanopy)
trees_all$year <- as.numeric(trees_all$year)
View(trees_all)
library(lme4)
library(AICcmodavg)
library(car)
lmm.nullsp <- lmer(resist.value ~ 1 + (1 | sp / tree), data=trees_all, REML=FALSE)
lmm.nullyear <- lmer(resist.value ~ 1 + (1 | year), data=trees_all, REML=FALSE)
lmm.random <- lmer(resist.value ~ 1 + (1 | sp / tree) + (1 | year), data=trees_all, REML=FALSE)
lmm.positionsp <- lmer(resist.value ~ position + (1 | sp / tree), data=trees_all, REML=FALSE)
lmm.positionyear <- lmer(resist.value ~ position + (1 | year), data=trees_all, REML=FALSE)
lmm.full <- lmer(resist.value ~ position + (1 | sp / tree) + (1 | year), data=trees_all, REML=FALSE)
cand.models <- list(lmm.nullsp, lmm.nullyear, lmm.random, lmm.positionsp, lmm.positionyear, lmm.full) #, lmm.tlpsp, lmm.tlpyear, lmm.fixedsp, lmm.fixedyear, lmm.combined)
names(cand.models) <- c("lmm.nullsp", "lmm.nullyear", "lmm.random", "lmm.positionsp", "lmm.positionyear", "lmm.full") #, "lmm.tlpsp", "lmm.tlpyear", "lmm.fixedsp", "lmm.fixedyear", "lmm.combined")
#this function looks through all the models above to say what is the best one (what fits the best)
var_aic <- aictab(cand.models, second.ord=TRUE, sort=TRUE)
View(var_aic)
##5b. determine the best model from anova (using the model candidates above) ####
#interestingly, this gives a similar result to running AICc, with Pr(>Chisq) acting as a kind of p-value for showing which model is best to use.
anova(lmm.nullsp, lmm.nullyear, lmm.random, lmm.positionsp, lmm.positionyear, lmm.full)
#
boxplot(resist.value ~ sp, data=trees_all)
#graph showing resistance value by species by year by canopy position
ggplot(data = trees_all) +
aes(x = year, y = resist.value, color = sp) +
geom_point() +
scale_color_brewer(palette="Paired") +
theme_minimal() +
facet_wrap(vars(position))
##4e. determine proportion of resistance values per sp ####
prop <- data.frame("sp" = unique(trees_all$sp))
View(prop)
prop$can_value>1 <- ""
for (i in seq(along=prop$sp)){
for (j in seq(along=unique(trees_all$sp))){
if (i==j){
prop$value.over1 <- ifelse(prop$sp == trees_all$sp[[j]], length(trees_all[trees_all$sp == trees_all$sp[[j]] & trees_all$resist.value >= 1, ]))
# prop$can.value.over1 <- ""
# prop$sub.value.over1
}
prop$sp == trees_all$sp[[j]]
trees_all[trees_all$sp == trees_all$sp[[j]] & trees_all$resist.value >= 1, ]
prop$value.over1 <- ifelse(prop$sp == trees_all$sp[[j]], length(trees_all[trees_all$sp == trees_all$sp[[j]] & trees_all$resist.value >= 1, ]), prop$value.over1)
prop$value.over1 <- NA
prop$can.value.over1 <- NA
prop$sub.value.over1 <- NA
prop$value.over1 <- ifelse(prop$sp == trees_all$sp[[j]], length(trees_all[trees_all$sp == trees_all$sp[[j]] & trees_all$resist.value >= 1, ]), prop$value.over1)
View(prop)
temp <- trees_all[trees_all$sp == trees_all$sp[[j]] & trees_all$resist.value>=1, ]
View(temp)
?length
?sum
prop$value.over1 <- ifelse(prop$sp == temp$sp, length(temp$resist.value), prop$value.over1)
View(temp)
length(temp$resist.value)
View(temp)
sum(1:nrow(temp$resist.value), na.rm=TRUE)
sum(nrow(temp$resist.value), na.rm=TRUE)
temp <- temp[!is.na(temp$resist.value), ]
prop$value.over1 <- ifelse(prop$sp[[i]] == temp$sp, length(temp$resist.value), prop$value.over1)
nrow(temp$resist.value)
nrow(temp)
prop$value.over1 <- ifelse(prop$sp[[i]] == temp$sp, nrow(temp), prop$value.over1)
prop$sp[[i]] == temp$sp
prop$sp[[i]]
temp$sp
prop$sp[[i]] == temp$sp
prop$value.over1[[i]] <- ifelse(prop$sp[[i]] == temp$sp, nrow(temp), prop$value.over1)
prop$value.over1 <- ifelse(prop$sp[[i]] == temp$sp[[i]], nrow(temp), prop$value.over1)
View(prop)
for (i in seq(along=prop$sp)){
for (j in seq(along=unique(trees_all$sp))){
if (i==j){
temp <- trees_all[trees_all$sp == trees_all$sp[[j]] & trees_all$resist.value>=1, ]
temp <- temp[!is.na(temp$resist.value), ]
prop$value.over1 <- ifelse(prop$sp[[i]] == temp$sp[[i]], nrow(temp), prop$value.over1)
# prop$can.value.over1 <- ""
# prop$sub.value.over1
}
View(prop)
View(temp)
trees_all$sp[[j]]
unique(trees_all$sp)
trees_all.sp <- unique(trees_all$sp)
for (i in seq(along=prop$sp)){
for (j in seq(along=unique(trees_all.sp))){
if (i==j){
temp <- trees_all[trees_all$sp == trees_all.sp[[j]] & trees_all$resist.value>=1, ]
temp <- temp[!is.na(temp$resist.value), ]
prop$value.over1 <- ifelse(prop$sp[[i]] == temp$sp[[i]], nrow(temp), prop$value.over1)
# prop$can.value.over1 <- ""
# prop$sub.value.over1
}
for (i in seq(along=prop$sp)){
for (j in seq(along=unique(trees_all.sp))){
if (i==j){
temp <- trees_all[trees_all$sp == trees_all.sp[[j]] & trees_all$resist.value>=1, ]
temp <- temp[!is.na(temp$resist.value), ]
prop$value.over1 <- ifelse(prop$sp[[i]] == temp$sp, nrow(temp), prop$value.over1)
# prop$can.value.over1 <- ""
# prop$sub.value.over1
}
for (i in seq(along=prop$sp)){
for (j in seq(along=unique(trees_all.sp))){
if (i==j){
temp <- trees_all[trees_all$sp == trees_all.sp[[j]] & trees_all$resist.value>=1, ]
temp <- temp[!is.na(temp$resist.value), ]
prop$value.over1 <- nrow(temp)
# prop$can.value.over1 <- ""
# prop$sub.value.over1
}
View(prop)
View(temp)
for (i in seq(along=prop$sp)){
for (j in seq(along=unique(trees_all.sp))){
if (i==j){
temp <- trees_all[trees_all$sp == trees_all.sp[[j]] & trees_all$resist.value>=1, ]
temp <- temp[!is.na(temp$resist.value), ]
prop$value.over1[[i]] <- nrow(temp)
# prop$can.value.over1 <- ""
# prop$sub.value.over1
}
View(prop)
View(temp)
for (i in seq(along=prop$sp)){
for (j in seq(along=unique(trees_all.sp))){
if (i==j){
temp <- trees_all[trees_all$sp == trees_all.sp[[j]] & trees_all$resist.value>=1, ]
temp <- temp[!is.na(temp$resist.value), ]
prop$value.over1[[i]] <- nrow(temp)
prop$can.value.over1[[i]] <- ifelse(temp$position == "canopy", nrow(temp), prop$can.value.over1)
# prop$sub.value.over1
}
prop$can.value.over1[[i]] <- nrow(temp[temp$position == "canopy", ])
View(prop)
View(temp)
for (i in seq(along=prop$sp)){
for (j in seq(along=unique(trees_all.sp))){
if (i==j){
temp <- trees_all[trees_all$sp == trees_all.sp[[j]] & trees_all$resist.value>=1, ]
temp <- temp[!is.na(temp$resist.value), ]
prop$value.over1[[i]] <- nrow(temp)
prop$can.value.over1[[i]] <- nrow(temp[temp$position == "canopy", ])
# prop$sub.value.over1
}
View(prop)
for (i in seq(along=prop$sp)){
for (j in seq(along=unique(trees_all.sp))){
if (i==j){
temp <- trees_all[trees_all$sp == trees_all.sp[[j]] & trees_all$resist.value>=1, ]
temp <- temp[!is.na(temp$resist.value), ]
prop$value.over1[[i]] <- nrow(temp)
prop$can.value.over1[[i]] <- nrow(temp[temp$position == "canopy", ])
prop$sub.value.over1[[i]] <- nrow(temp[temp$position == "subcanopy", ])
}
View(prop)
trees_all.sp
##4g. add in ring porosity qualifications ####
porosity <- data.frame("sp" = c("cagl",  "caovl", "cato", "fagr", "fram", "juni",  "litu",  "pist",  "qual",  "qupr",  "quru",  "quve"), "ring_porosity" = c("ring", "ring", "ring", "diffuse", "ring", "semi-ring", "diffuse", NA, "ring", "ring", "ring", "ring"))
View(porosity)
#combine with trees_all
trees_all$ring_porosity <- porosity$ring_porosity[match(trees_all$sp, porosity$sp)]
View(trees_all)
rm(porosity)
trees_all <- rbind(trees_canopy, trees_subcanopy)
trees_all$year <- as.numeric(trees_all$year)
##4g. add in ring porosity qualifications ####
ring_porosity <- data.frame("sp" = c("cagl",  "caovl", "cato", "fagr", "fram", "juni",  "litu",  "pist",  "qual",  "qupr",  "quru",  "quve"), "rp" = c("ring", "ring", "ring", "diffuse", "ring", "semi-ring", "diffuse", NA, "ring", "ring", "ring", "ring"))
#combine with trees_all
trees_all$rp <- ring_porosity$rp[match(trees_all$sp, ring_porosity$rp)]
lmm.nullsp <- lmer(resist.value ~ 1 + (1 | sp / tree), data=trees_all, REML=FALSE)
lmm.nullyear <- lmer(resist.value ~ 1 + (1 | year), data=trees_all, REML=FALSE)
lmm.random <- lmer(resist.value ~ 1 + (1 | sp / tree) + (1 | year), data=trees_all, REML=FALSE)
lmm.positionsp <- lmer(resist.value ~ position + (1 | sp / tree), data=trees_all, REML=FALSE)
lmm.positionyear <- lmer(resist.value ~ position + (1 | year), data=trees_all, REML=FALSE)
lmm.full <- lmer(resist.value ~ position + (1 | sp / tree) + (1 | year), data=trees_all, REML=FALSE)
#add a climate variable to the model
lmm.rpsp <- lmer(resist.value ~ rp + (1 | sp), data=trees_all, REML=FALSE)
lmm.rpyear <- lmer(resist.value ~ rp + (1 | year), data=trees_all, REML=FALSE)
#lmm.fixed <- lmer(resist.value ~ position + rp, data=trees_all, REML=FALSE)
#not technically a mixed effects model because no random effects
lmm.fixedsp <- lmer(resist.value ~ position + rp + (1 | sp), data=trees_all, REML=FALSE)
lmm.fixedyear <- lmer(resist.value ~ position + rp + (1 | year), data=trees_all, REML=FALSE)
lmm.combined <- lmer(resist.value ~ position + rp + (1 | sp) + (1 | year), data=trees_all, REML=FALSE)
View(trees_all)
#add a climate variable to the model
lmm.rpsp <- lmer(resist.value ~ rp + (1 | sp), data=trees_all, REML=FALSE)
View(ring_porosity)
#combine with trees_all
trees_all$rp <- ring_porosity$rp[match(trees_all$sp, ring_porosity$sp)]
lmm.rpsp <- lmer(resist.value ~ rp + (1 | sp), data=trees_all, REML=FALSE)
lmm.rpyear <- lmer(resist.value ~ rp + (1 | year), data=trees_all, REML=FALSE)
#lmm.fixed <- lmer(resist.value ~ position + rp, data=trees_all, REML=FALSE)
#not technically a mixed effects model because no random effects
lmm.fixedsp <- lmer(resist.value ~ position + rp + (1 | sp), data=trees_all, REML=FALSE)
lmm.fixedyear <- lmer(resist.value ~ position + rp + (1 | year), data=trees_all, REML=FALSE)
lmm.combined <- lmer(resist.value ~ position + rp + (1 | sp) + (1 | year), data=trees_all, REML=FALSE)
cand.models <- list(lmm.nullsp, lmm.nullyear, lmm.random, lmm.positionsp, lmm.positionyear, lmm.full, lmm.rpsp, lmm.rpyear, lmm.fixedsp, lmm.fixedyear, lmm.combined)
names(cand.models) <- c("lmm.nullsp", "lmm.nullyear", "lmm.random", "lmm.positionsp", "lmm.positionyear", "lmm.full", "lmm.rpsp", "lmm.rpyear", "lmm.fixedsp", "lmm.fixedyear", "lmm.combined")
#this function looks through all the models above to say what is the best one (what fits the best)
var_aic <- aictab(cand.models, second.ord=TRUE, sort=TRUE)
View(var_aic)
effects <- colnames(trees_all)
?as.formula
effects <- c("position", "(1 | year)", "(1 | sp / tree)", "rp", "tlp")
# create all combinations of ind_vars
effects_comb <-
unlist( sapply( seq_len(length(effects)),
function(i) {
apply( combn(effects,i), 2, function(x) paste(x, collapse = "+"))
}))
effects_comb
response <- "resist.value"
# pair with dep_vars:
var_comb <- expand.grid(response, effects_comb)
View(var_comb)
# formulas for all combinations. $Var1 is the response, and $Var2 is the effect
formula_vec <- sprintf("%s ~ %s", var_comb$Var1, var_comb$Var2)
# create models
lmm_all <- lapply( formula_vec, function(f)   {
fit1 <- lmer( f, data = trees_all)
#fit1$coefficients <- coef( summary(fit1))
return(fit1)
})
# create models
lmm_all <- lapply( formula_vec, function(f)   {
fit1 <- lmer(f, data = trees_all)
#fit1$coefficients <- coef( summary(fit1))
return(fit1)
})
?lapply
# create models
lmm_all <- lapply(formula_vec, function(x){
fit1 <- lmer(f, data = trees_all)
#fit1$coefficients <- coef( summary(fit1))
return(fit1)
})
fit1 <- lmer(x, data = trees_all)
# create models
lmm_all <- lapply(formula_vec, function(x){
fit1 <- lmer(x, data = trees_all)
#fit1$coefficients <- coef( summary(fit1))
return(fit1)
})
formula_vec
# create models
lmm_all <- lapply(formula_vec, function(x){
fit1 <- lmer(x, data = trees_all)
#fit1$coefficients <- coef( summary(fit1))
return(fit1)
})
View(var_comb)
var_comb <- var_comb[var_comb$Var2 %in% "(", ]
# pair response with effect and sub out combinations that don't include random effects
var_comb <- expand.grid(response, effects_comb)
var_comb <- var_comb["(" %in% var_comb$Var2, ]
# pair response with effect and sub out combinations that don't include random effects
var_comb <- expand.grid(response, effects_comb)
View(var_comb)
var_comb["1" %in% var_comb$Var2, ]
grepl("1" %in% var_comb$Var2)
grepl("1", var_comb$Var2)
var_comb <- var_comb[grepl("1", var_comb$Var2), ]
View(var_comb)
View(trees_all)
##4f. add in turgor loss point values ####
#add in tlp values (from Krista github issue #6 https://github.com/SCBI-ForestGEO/McGregor_climate-sensitivity-variation/issues/6)
turgor <- data.frame("sp" = c("cagl", "caovl", "fagr", "fram", "juni", "litu", "pist", "qual", "qupr", "quru", "quve", "caco", "cato", "frni"), "tlp" = c(-2.1282533, -2.24839333, -2.57164, -2.1012133, -2.75936, -1.9212933, NA, -2.58412, -2.3601733, -2.6395867, -2.3879067, -2.1324133, -2.31424, NA))
#combine with trees_all
trees_all$tlp <- turgor$tlp[match(trees_all$sp, turgor$sp)]
View(trees_all)
# formulas for all combinations. $Var1 is the response, and $Var2 is the effect
formula_vec <- sprintf("%s ~ %s", var_comb$Var1, var_comb$Var2)
# create models
lmm_all <- lapply(formula_vec, function(x){
fit1 <- lmer(x, data = trees_all)
#fit1$coefficients <- coef( summary(fit1))
return(fit1)
})
names(lmm_all) <- formula_vec
View(lmm_all)
?var_aic
library(lme4)
library(AICcmodavg)
library(car)
?aictab
var_aic <- aictab(lmm_all, second.ord=TRUE, sort=TRUE)
# create models
lmm_all <- lapply(formula_vec, function(x){
fit1 <- lmer(x, data = trees_all, REML=FALSE)
#fit1$coefficients <- coef( summary(fit1))
return(fit1)
})
names(lmm_all) <- formula_vec
var_aic <- aictab(lmm_all, second.ord=TRUE, sort=TRUE)
View(var_aic)
?anova
anova(lmm_all)
anova(lmm_all[[1:n]])
anova(lmm_all[[1:24]])
q <- sapply(lmm_all, anova, simplify=FALSE)
q
q <- sapply(lmm_all, anova)
q
q <- sapply(lmm_all, aov, simplify=FALSE)
?aov
mapply(anova, lmm_all)
mapply(anova, lmm_all, simplify=FALSE)
mapply(anova, lmm_all, lmm_all, simplify=FALSE)
mapply(anova, lmm_all, lmm_all)
mapply(anova, lmm_all, lmm_all, SIMPLIFY = FALSE)
mapply(anova, lmm_all, SIMPLIFY = FALSE)
anova(lmm.full, lmm.random)
View(prop)
View(var_aic)
var_comb <- var_comb[grepl("year", var_comb$Var2, )]
var_comb <- var_comb[grepl("year", var_comb$Var2), ]
View(var_comb)
# formulas for all combinations. $Var1 is the response, and $Var2 is the effect
formula_vec <- sprintf("%s ~ %s", var_comb$Var1, var_comb$Var2)
# create list of model outputs
lmm_all <- lapply(formula_vec, function(x){
fit1 <- lmer(x, data = trees_all, REML=FALSE)
#fit1$coefficients <- coef( summary(fit1))
return(fit1)
})
names(lmm_all) <- formula_vec
var_aic <- aictab(lmm_all, second.ord=TRUE, sort=TRUE)
View(var_aic)
##5b. determine the best model from anova (using the model candidates above) ####
#interestingly, this gives a similar result to running AICc, with Pr(>Chisq) acting as a kind of p-value for showing which model is best to use.
anova(lmm.nullsp, lmm.nullyear, lmm.random, lmm.positionsp, lmm.positionyear, lmm.full)
View(lmm_all)
summary(lmm_all[[13]])
coef(summary(lmm_all[[13]]))[ , "Estimate"]
qqp(residuals(lmm_all[[13]]), "norm")
#What this plot does is create a dashed horizontal line representing zero: an average of zero deviation from the best-fit line. It also creates a solid line that represents the residual deviation from the best-fit line.
# If the solid line doesn't cover the dashed line, that would mean the best-fit line does not fit particularly well.
plot(fitted(lmm_all[[13]]), residuals(lmm_all[[13]]), xlab = "Fitted Values", ylab = "Residuals")
abline(h=0, lty=2)
lines(smooth.spline(fitted(lmm_all[[13]]), residuals(lmm_all[[13]])))
