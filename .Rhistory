}
var_comb <- unique(var_comb[,1:2])
formula_vec <- sprintf("%s ~ %s", var_comb$Var1, var_comb$Var2)
lmm_all <- lapply(formula_vec, function(x){
fit1 <- lmer(x, data = model_df[[j]], REML=FALSE,
control = lmerControl(optimizer ="Nelder_Mead"))
return(fit1)
})
names(lmm_all) <- formula_vec
var_aic <- aictab(lmm_all, second.ord=TRUE, sort=TRUE) #rank based on AICc
var_aic$Modnames <- as.character(var_aic$Modnames)
best_mod_traits$best_model[[i]] <- var_aic$Modnames[[1]]
#get all mods <2 dAIC
var_aic <- var_aic[var_aic$Delta_AICc <= 2, ]
top <- var_aic[,c(1,4)]
top$Delta_AICc <- round(top$Delta_AICc, 2)
top$scenario <- mods[[i]]
top$coef <- NA
for (z in seq(along = lmm_all)){
for (w in seq(along=1:nrow(var_aic))){
if (names(lmm_all[z]) == var_aic$Modnames[[w]]){
#run the best model alone with REML=TRUE
fit1 <- lmer(formula_vec[[z]], data = model_df[[j]], REML=TRUE,
control = lmerControl(optimizer ="Nelder_Mead"))
#get coefficients and put in table
coeff <- data.frame(coef(summary(fit1))[ , "Estimate"]) ##2
coeff[,2] <- rownames(coeff)
coeff[,1] <- round(coeff[,1], 3)
colnames(coeff) <- c(paste0("[", names(model_df[j]), "] ","Model #", w), "model_var")
#put r2 in table
delta <- data.frame(var_aic$Delta_AICc[[w]])
colnames(delta) <- paste0("[", names(model_df[j]), "] ","Model #", w)
delta$model_var <- "dAICc"
r <- rsquared(fit1) #gives R^2 values for models. "Marginal" is the R^2 for just the fixed effects, "Conditional" is the R^2 for everything.
r <- data.frame(r[,6])
colnames(r) <- paste0("[", names(model_df[j]), "] ","Model #", w)
r$model_var <- "r^2"
r[,1] <- round(r[,1], 2)
coeff <- rbind(delta, r, coeff)
coeff_list[[paste0("coeff_", names(model_df[j]), "_", w)]] <- coeff
}
}
}
}
}
top_models <- rbind(top_models, top)
}
write.csv(best_mod_traits, "manuscript/tables_figures/tested_traits_best.csv", row.names=FALSE)
write.csv(top_models, "manuscript/tables_figures/top_models_dAIC.csv", row.names=FALSE)
##make table of coefficients and r2, then reorder table
#reorder the list
# coeff_list <- coeff_list[c(3,2,1,4,6,5,7:9,16:17,13,15,11,14,12,18,10)] #18 models
# coeff_list <- coeff_list[c(2,1,4,5,3,6:7,9,8,11,12,10)] #12 models
# coeff_list <- coeff_list[c(2,3,1,4,6,5,7,8:10,15,13,12,14,11)] #15 models
coeff_list <- coeff_list[c(4,2,6,3,1,5, #trees_all_sub
9,8,10,7,11, #x1966
13,12,14,15, #x1977
22,23,19,17,21,20,18,24,16)] #x1999
merge.all <- function(x, y) {
merge(x, y, all=TRUE, by="model_var")
}
coeff_table <- Reduce(merge.all, coeff_list)
coeff_table[,2:ncol(coeff_table)] <- round(coeff_table[,2:ncol(coeff_table)], 3)
coeff_new <- as.data.frame(t(coeff_table[,-1]))
colnames(coeff_new) <- coeff_table$model_var
# coeff_new$year1966 <- ifelse(!is.na(coeff_new$year1977), 0, NA) #only applicable if "year" is a significant variable
coeff_new$codominant <- ifelse(!is.na(coeff_new$position_alldominant), 0, NA)
coeff_new$rpdiffuse <- ifelse(!is.na(coeff_new$rpring), 0, NA)
coeff_new <- coeff_new[, c("dAICc","r^2", "(Intercept)", "height.ln.m",
"position_alldominant", "codominant", "position_allintermediate","position_allsuppressed",
"rpdiffuse", "rpring", "rpsemi-ring", "TWI.ln", "PLA_dry_percent", "mean_TLP_Mpa")]
# colnames(coeff_new) <- c("dAICc", "r^2", "Intercept", "1966", "1977", "1999", "ln[H]", "D", "C", "I", "S", "ln[TWI]", "PLA", "TLP") #only if year is variable
colnames(coeff_new) <- c("dAICc", "r^2", "Intercept","ln[H]", "D", "C", "I", "S", "diffuse", "ring", "semi-ring", "ln[TWI]", "PLA", "TLP")
coeff_new <- setDT(coeff_new, keep.rownames = TRUE)[]
setnames(coeff_new, old="rn", new="rank")
patterns <- c("\\[", "x", "\\]")
for(i in seq(along=patterns)){
coeff_new$rank <- gsub(patterns[[i]], "", coeff_new$rank)
}
write.csv(coeff_new, "manuscript/tables_figures/tested_traits_best_coeff.csv", row.names=FALSE)
View(coeff)
View(best_mod_traits)
View(coeff_table)
View(best_mod_traits)
library(RCurl)
leaf_traits <- read.csv(text=getURL("https://raw.githubusercontent.com/EcoClimLab/HydraulicTraits/master/data/SCBI/processed_trait_data/SCBI_all_traits_table_species_level.csv?token=AJNRBEPDTUEGGQUCPMMGPQ25WRPM4"), stringsAsFactors = FALSE)
library(pointRes)
library(dplR)
library(data.table)
library(tools)
library(dplyr)
library(reshape2)
#NB ####
##to be clear, I wrote this code before I realized that some of the work done in these loops had already been done in the outputs of res.comp (specifically out.select). However, since the code runs well, and I double-checked that it was giving the same outputs as analyzing out.select, I'm keeping it as is.
#Note about FRNI and CACO
#originally, getting the pointer years was done without caco because of too few cores. Now that we have the pointer years, we're adding them back in for the full analysis.
#we thought about including frni (combining the canopy and subcanopy cores because only 1 canopy), but we excluded for two reasons
##1. including frni doesn't impact the model much, and
##2. frni is the 19th most productive species, whereas every other species we have is the top 12.
#Note about PIST
##we originally included pist but ultimately we have no leaf trait data for this species, so we excluded it
##4a. determine pointer years
###all cores together ####
#this is a combination of the two canopy and subcanopy groupings below
rings <- read.rwl("data/core_files/all_species_except_FRNI_PIST.rwl") #read in rwl file
widths <- rings #for consistency with original code
area <- bai.in(rings) #convert to bai.in
resil_metrics <- res.comp(area, nb.yrs=5, res.thresh.neg = 30, series.thresh = 25) #get resilience metrics
resil_pointers <- data.frame(resil_metrics$out)
resil_pointers <- resil_pointers[resil_pointers$nb.series >=4, ]
pointers <- resil_pointers[resil_pointers$nature == -1, ]
pointers <- pointers[,c(1:3,5)]
pointers <- pointers[order(pointers$nb.series, decreasing=TRUE), ]
rownames(pointers) <- 1:nrow(pointers)
#get specific resist values for all trees
neil_list <- read.csv("data/core_list_for_neil.csv", stringsAsFactors = FALSE)
neil_sp <- unique(neil_list$sp)
neil_list$tag <- paste0("X", neil_list$tag) #to match the colnames of can_resist below
pointer_years_simple <- c(1966, 1977, 1999)
resist <- data.frame(resil_metrics$resist)
years <- rownames(resist)
colnames(resist) <- gsub("A", "", colnames(resist))
tree_series <- colnames(resist)
ind <- resist
ind_neil <- neil_list[neil_list$tag %in% tree_series, ]
ind$year <- years
ind$year <- as.numeric(ind$year)
ind <- ind[ind$year %in% c(1966,1977,1999), ]
ind$year <- as.character(ind$year) #to melt
change <- melt(ind)
setnames(change, old=c("variable", "value"), new=c("tree", "resist.value"))
#bring in species from neil_list
change$sp <- ind_neil$sp[match(change$tree, ind_neil$tag)]
change$tree <- gsub("X", "", change$tree)
change$tree <- gsub("^0", "", change$tree)
#this is trees_all
trees_all <- change[complete.cases(change), ]
library(ggplot2)
library(devtools) #for sourcing functions for regression equations
library(rgdal) #to read in shapefiles
library(broom) #for the tidy function
library(sf) #for mapping
library(ggthemes) #for removing graticules when making pdf
library(rgeos) #for distance calculation
library(RCurl) #for reading in URLs
library(readxl)
library(raster) #for TWI
library(elevatr) #for TWI
library(dynatopmodel) #for TWI
##5a. add in ring porosity qualifications ####
ring_porosity <- data.frame("sp" = c("cagl",  "caovl", "cato", "fagr", "fram", "juni",  "litu",  "pist",  "qual",  "qupr",  "quru",  "quve", "caco", "frni"), "rp" = c("ring", "ring", "ring", "diffuse", "ring", "semi-ring", "diffuse", NA, "ring", "ring", "ring", "ring", "ring", "ring"))
trees_all$rp <- ring_porosity$rp[match(trees_all$sp, ring_porosity$sp)]
#gives count of each rp value
rp_test <- trees_all[!duplicated(trees_all$tree), ]
rp_test$tree <- as.numeric(rp_test$tree)
ggplot(data = rp_test) +
aes(x = rp) +
geom_bar(fill = "#0c4c8a") +
theme_minimal() +
facet_wrap(vars(position))
##5b. add in leaf traits ####
#this comes from the hydraulic traits repo, "SCBI_all_traits_table_species_level.csv"
##leaf traits gained from this include PLA_dry_percent, LMA_g_per_m2, Chl_m2_per_g, and WD [wood density]
leaf_traits <- read.csv(text=getURL("https://raw.githubusercontent.com/EcoClimLab/HydraulicTraits/master/data/SCBI/processed_trait_data/SCBI_all_traits_table_species_level.csv?token=AJNRBEPDTUEGGQUCPMMGPQ25WRPM4"), stringsAsFactors = FALSE)
leaf_traits <- leaf_traits[, c(1,8,12,26,28)]
for (i in seq(along=2:ncol(leaf_traits))){
trait <- colnames(leaf_traits[2:ncol(leaf_traits)])
trees_all[, trait[[i]]] <- leaf_traits[, trait[[i]]][match(trees_all$sp, leaf_traits$sp)]
}
##5bi. add in SLA data (here for reference) ####
### I initially was going to include SLA but Krista mentioned that SLA is the inverse of LMA, so for the purposes of this modelling, they're equal. We're focused more on having SCBI-specific data when possible, so we're using LMA.
# traits_sla <- read_excel("data/traits/photosynthesis_traits.xlsx", sheet = "Data")
# traits_sla$species <- paste(traits_sla$Genus, traits_sla$Species)
# SLA <- traits_sla
# SLA$Genus.spp <- paste0(gsub("^(..).*", "\\1", SLA$Genus.spp),
#                         gsub("^.* (..).*", "\\1", SLA$Genus.spp))
# SLA$Genus.spp <- tolower(SLA$Genus.spp)
# SLA <- SLA[SLA$Genus %in% c("Carya", "Fraxinus", "Fagus", "Juglans", "Liriodendron", "Pinus", "Quercus"), ]
# SLA <- SLA[SLA$Genus.spp %in% neil_sp & !is.na(SLA$SLA), ]
# SLA <- SLA[order(SLA$Genus.spp), ]
# SLA <- SLA[c(10,20,28)]
# unique(SLA$Genus.spp)
#
# mean_SLA <-
#   group_by(SLA, Genus.spp) %>%
#   summarize(SLA_mean = mean(SLA))
#
# trees_all$SLA_mean <- mean_SLA$SLA_mean[match(trees_all$sp, mean_SLA$Genus.spp)]
##5bii. add in p50 and p88 (here for reference) ####
#after review, we have decided to not focus on p50 and p80
# #get P50 from traits table
# hydra <- read.csv(text=getURL("https://raw.githubusercontent.com/EcoClimLab/HydraulicTraits/master/results/SCBI_best_fits.csv?token=AJNRBEP62SALMQHAV45TP2S5HCCPK"))
#
# #Anderegg 2018 found that p50 and p80 came out significant in modelling
# trees_all$p50.MPa <- hydra$psi_0.5_kl50[match(trees_all$sp, hydra$data.type)]
# trees_all$p80.MPa <- hydra$psi_0.5_kl80[match(trees_all$sp, hydra$data.type)]
#after review, we have decided to not focus on pmin or HSM
# trees_all$Pmin.MPa <- 1.1122*trees_all$mean_TLP_Mpa + 0.3849
# trees_all$hsm.MPa <- trees_all$Pmin.MPa - trees_all$p50.MPa
# meh <- trees_all[!duplicated(trees_all$sp), ]
# meh <- meh[, c("sp", "mean_TLP_Mpa", "Pmin.MPa")]
# meh$psi_Kmax_0.5 <- hydra$psi_Kmax_0.5[match(meh$sp, hydra$data.type)]
#
##5c. add in elevation data ####
elev <- read.csv(text=getURL("https://raw.githubusercontent.com/SCBI-ForestGEO/SCBI-ForestGEO-Data/master/spatial_data/elevation/full_stem_elevation_2013.csv"))
trees_all$elev.m <- elev$dem_sigeo[match(trees_all$tree, elev$tag)]
##5d. add in distance to water (here for reference) ####
# ## mapping code here is taken from survey_maps.R in Dendrobands Rscripts folder.
#
# ## I have not found a way to make this not involve personal directories without moving all the data to my folder, which I'm hesitant about doing due to data redundancy.
# scbi_plot <- readOGR("D:/Dropbox (Smithsonian)/Github_Ian/SCBI-ForestGEO-Data/spatial_data/shapefiles/20m_grid.shp")
# deer <- readOGR("D:/Dropbox (Smithsonian)/Github_Ian/SCBI-ForestGEO-Data/spatial_data/shapefiles/deer_exclosure_2011.shp")
# roads <- readOGR("D:/Dropbox (Smithsonian)/Github_Ian/SCBI-ForestGEO-Data/spatial_data/shapefiles/SCBI_roads_edits.shp")
# streams <- readOGR("D:/Dropbox (Smithsonian)/Github_Ian/SCBI-ForestGEO-Data/spatial_data/shapefiles/SCBI_streams_edits.shp")
# NS_divide <- readOGR("D:/Dropbox (Smithsonian)/Github_Ian/Dendrobands/resources/maps/shapefiles/NS_divide1.shp")
#
# #convert all shp to dataframe so that it can be used by ggplot
# #if tidy isn't working, can also do: xxx_df <- as(xxx, "data.frame")
# scbi_plot_df <- tidy(scbi_plot)
# deer_df <- tidy(deer)
# roads_df <- tidy(roads)
# streams_df <- tidy(streams)
# NS_divide_df <- tidy(NS_divide)
#
# ## now we get into code specific for this analysis
# neil_map <- neil_list
# neil_map$tag <- gsub("X", "", neil_map$tag)
# neil_map$tag <- as.numeric(neil_map$tag)
# neil_map <- neil_map[, c(1:6,23:24)]
#
# map <- ggplot() +
#   geom_path(data = scbi_plot_df, aes(x = long, y = lat, group = group))+
#   geom_path(data=roads_df, aes(x=long, y=lat, group=group),
#             color="#996600", linetype=2)+
#   geom_path(data=streams_df, aes(x=long, y=lat, group=group), color="blue")+
#   geom_path(data=deer_df, aes(x=long, y=lat, group=group), size=1.1)+
#   geom_point(data=neil_map, aes(x=NAD83_X, y=NAD83_Y), shape=19)+
#   geom_text(data=neil_map, aes(x=NAD83_X, y=NAD83_Y, label=tag),
#             size=3, hjust=1.25, nudge_y=-1, nudge_x=1, check_overlap=TRUE)+
#   theme(plot.title=element_text(vjust=0.1))+
#   coord_sf(crs = "crs = +proj=merc", xlim=c(747350,747800), ylim=c(4308500, 4309125))
#
# ## calculating the distance requires some conversion. First, the points of the cored trees from neil_map must be in their own dataframe before they can be converted to a SpatialPoints object.
# neil_map_sub <- neil_map[, c(7:8)]
# neil_points <- SpatialPoints(neil_map_sub, proj4string = CRS(as.character("+proj=merc")))
#
# ## here, the minimum distance to water is calculated before binding with neil_map.
# ## A warning says that neil_points and streams are projected differently, but the output has been verified to be accurate.
# distance_water <- data.frame(apply(gDistance(neil_points, streams, byid=TRUE), 2, min))
# colnames(distance_water) <- "distance_water"
# distance <- cbind(neil_map, distance_water)
#
# ## next, do a log transformation on the distances before adding as a column to trees_all (similar to the dbh calculations below)
# distance$distance.ln.m <- log(distance$distance_water)
# trees_all$distance.ln.m <- distance$distance.ln.m[match(trees_all$tree, distance$tag)]
#
# ## this is to double check the accuracy of the map.
# distance_short <- distance[distance$distance_water <= 30, ]
#
# map <- ggplot() +
#   geom_path(data = scbi_plot_df, aes(x = long, y = lat, group = group))+
#   geom_path(data=roads_df, aes(x=long, y=lat, group=group),
#             color="#996600", linetype=2)+
#   geom_path(data=streams_df, aes(x=long, y=lat, group=group), color="blue")+
#   geom_path(data=deer_df, aes(x=long, y=lat, group=group), size=1.1)+
#   geom_point(data=distance_short, aes(x=NAD83_X, y=NAD83_Y), shape=19)+
#   geom_text(data=distance_short, aes(x=NAD83_X, y=NAD83_Y, label=tag),
#             size=3, hjust=1.25, nudge_y=-1, nudge_x=1, check_overlap=TRUE)+
#   theme(plot.title=element_text(vjust=0.1))+
#   coord_sf(crs = "crs = +proj=merc", xlim=c(747350,747800), ylim=c(4308500, 4309125))
#
##5e. add in dbh for each year ####
###original method ####
# dbh <- trees_all[, c(1:4)]
# dbh$dbh2013 <- elev$dbh[match(dbh$tree, elev$tag)]
#
# #create df with bark thickness log values and intercept values from Krista's paper (supplemental info)
# #https://besjournals.onlinelibrary.wiley.com/doi/epdf/10.1111/1365-2435.12470
# #fagr does not have bark thickness measured because it is negligible
# bark <- data.frame(
#   "sp" = c("acru", "fagr", "litu", "nysy", "caco", "cagl", "caovl", "cato", "fram", "juni", "qual", "qupr", "quru", "quve", "ulru"),
#   "bark_thick_ln" = c(-2.564, 0, -0.659, -0.611, -1.917, -0.495, -2.504, -0.945, 0.318, -0.293, -1.231, -0.647, -0.789, 1.5, 1.133),
#   "intercept" = c(0.599, 0, 0.425, 0.413, 0.503, 0.316, 0.703, 0.396, 0.295, 0.385, 0.526, 0.423, 0.341, 0.053, -0.057))
#
# bark$bark_thick <- ifelse(bark$bark_thick_ln != 0, exp(bark$bark_thick_ln), bark$bark_thick_ln)
#
# bark$bark_thick <- exp(bark$bark_thick_ln)
#
# dbh$bark_thick <- bark$bark_thick[match(dbh$sp, bark$sp)]
# dbh$intercept <- bark$intercept[match(dbh$sp, bark$sp)]
#
# #the main equation is based on ring widths. We have determined the equation to be
# # rw(pointer_year) <- 0.5*dbh2013 - bark_thick*(dbh2013^intercept) - sum(rw(pointer_year):rw(end)). The first part of the equation is here. Summing the pointer years happens with the "q" df below in the loop.
# dbh$rw_prelim <- (0.5*dbh$dbh2013) - (dbh$bark_thick*(dbh$dbh2013^dbh$intercept))
#
#
# dbh$dbh_old.mm <- "0" #in prep for below
# dbh$dbh_old.mm <- as.numeric(dbh$dbh_old.mm)
#
# for (i in seq(along=widths)){
#   df <- widths[[i]] #the list "widths" comes from #4a-4b
#   colnames(df) <- gsub("A", "", colnames(df)) #remove "A"
#   colnames(df) <- gsub("^0", "", colnames(df)) #remove leading 0
#
#   cols <- colnames(df) #define cols for below
#   colnames(df) <- gsub("^", "x", colnames(df)) #add "x" to make calling colnames below feasible
#
#   for (j in seq(along=cols)){
#     for (k in seq(along=colnames(df))){
#       ring_ind <- cols[[j]]
#       ring_col <- colnames(df)[[k]]
#
#       if(j==k){
#         #the output of this loop is 3 separate columns for each year's old dbh, hence why it is set to q as a dataframe before being combined below. Pointer_years_simple comes from #4d.
#         q <- data.frame(sapply(pointer_years_simple, function(x){
#           rw <- df[rownames(df)>=x, ]
#           ifelse(dbh$year == x & dbh$tree == ring_ind,
#                  dbh$rw_prelim - sum(rw[, ring_col], na.rm=TRUE), 0)
#         }))
#
#         q$dbh_old.mm <- q[,1] +q[,2] + q[,3] #add columns together
#         # q$dbh_old.mm <- q[,1] +q[,2] + q[,3] + q[,4]
#         dbh$dbh_old.mm <- dbh$dbh_old.mm + q$dbh_old.mm #combine with dbh
#       }
#     }
#   }
# }
#
# # check <- dbh[dbh$dbh_old.mm == 0, ] #check if any tree was missed
#
# trees_all$dbh_old.mm <- dbh$dbh_old.mm
# trees_all$dbh_old.mm <- ifelse(trees_all$dbh_old.mm < 0, 0, trees_all$dbh_old.mm)
# trees_all$dbh_old.mm <- ifelse(trees_all$dbh_old.mm > 0, trees_all$dbh_old.mm/10, trees_all$dbh_old.mm)
# trees_all$dbh_ln <- ifelse(trees_all$dbh_old.mm == 0, NA, log(trees_all$dbh_old.mm))
###new method ####
bark <- read.csv("data/traits/SCBI_bark_depth.csv")
# bark <- bark[bark$species %in% sp_can | bark$species %in% sp_subcan, ]
bark <- bark[bark$species %in% unique(trees_all$sp), ]
#1. Calculate diameter_nobark for 2008 = DBH.mm.2008-2*bark.depth.mm
bark$diam_nobark_2008.mm <- bark$DBH.mm.2008 - 2*bark$bark.depth.mm
#2. log-transform both diam_nobark_2008 (x) and bark.depth.mm (y)
#3. Fit a linear model, and use model to predict log(bark.depth.mm)
source_gist("524eade46135f6348140")
ggplot(data = bark, aes(x = log(diam_nobark_2008.mm), y = log(bark.depth.mm))) +
stat_smooth_func(geom="text",method="lm",hjust=0.16, vjust=-1,parse=TRUE) +
geom_smooth(method="lm", se=FALSE, color="black") +
geom_point(color = "#0c4c8a") +
theme_minimal() +
facet_wrap(vars(species))
#no total regression equation at bottom because all species are accounted for in dataset.
bark$predict_barkthick.ln.mm <- NA
bark$predict_barkthick.ln.mm <-
ifelse(bark$species == "caco", -1.56+0.416*log(bark$diam_nobark_2008.mm),
ifelse(bark$species == "cagl", -0.393+0.268*log(bark$diam_nobark_2008.mm),
ifelse(bark$species == "caovl", -2.18+0.651*log(bark$diam_nobark_2008.mm),
ifelse(bark$species == "cato", -0.477+0.301*log(bark$diam_nobark_2008.mm),
ifelse(bark$species == "fram", 0.418+0.268*log(bark$diam_nobark_2008.mm),
ifelse(bark$species == "juni", 0.346+0.279*log(bark$diam_nobark_2008.mm),
ifelse(bark$species == "litu", -1.14+0.463*log(bark$diam_nobark_2008.mm),
ifelse(bark$species == "qual", -2.09+0.637*log(bark$diam_nobark_2008.mm),
ifelse(bark$species == "qupr", -1.31+0.528*log(bark$diam_nobark_2008.mm),
ifelse(bark$species == "quru", -0.593+0.292*log(bark$diam_nobark_2008.mm),
ifelse(bark$species == "quve", 0.245+0.219*log(bark$diam_nobark_2008.mm),
bark$predict_barkthick.ln)))))))))))
#4. Take exponent of bark.depth.mm and make sure predicted values look good.
bark$predict_barkthick.mm <- exp(bark$predict_barkthick.ln.mm)
range(bark$predict_barkthick.mm - bark$bark.depth.mm)
View(bark)
##set up dbh dataframe
dbh <- trees_all[, c(1:4)]
scbi.stem1 <- read.csv(text=getURL("https://raw.githubusercontent.com/SCBI-ForestGEO/SCBI-ForestGEO-Data/master/tree_main_census/data/census-csv-files/scbi.stem1.csv"), stringsAsFactors = FALSE)
unique(bark$species)
scbi.stem1$dbh <- as.numeric(scbi.stem1$dbh)
##set up dbh dataframe
dbh <- trees_all[, c(1:4)]
scbi.stem1 <- read.csv(text=getURL("https://raw.githubusercontent.com/SCBI-ForestGEO/SCBI-ForestGEO-Data/master/tree_main_census/data/census-csv-files/scbi.stem1.csv"), stringsAsFactors = FALSE)
scbi.stem1$dbh <- as.numeric(scbi.stem1$dbh)
dbh$dbh2008.mm <- scbi.stem1$dbh[match(dbh$tree, scbi.stem1$tag)]
mean_bark <- aggregate(bark$bark.depth.mm, by=list(bark$species), mean) #mm
View(mean_bark)
colnames(mean_bark) <- c("sp", "mean_bark_2008.mm")
dbh$mean_bark_2008.mm <- ifelse(dbh$sp %in% mean_bark$sp, mean_bark$mean_bark_2008.mm[match(dbh$sp, mean_bark$sp)], mean(bark$bark.depth.mm))
dbh$mean_bark_2008.mm <- round(dbh$mean_bark_2008.mm, 2)
##define this column before loop
dbh$diam_nobark_old.mm <- 0
df <- rings #the original file read-in from read.rwl
colnames(df) <- gsub("A", "", colnames(df)) #remove "A"
colnames(df) <- gsub("^0", "", colnames(df)) #remove leading 0
cols <- colnames(df) #define cols for below
colnames(df) <- gsub("^", "x", colnames(df)) #add "x" to make calling colnames below feasible
for (j in seq(along=cols)){
for (k in seq(along=colnames(df))){
ring_ind <- cols[[j]]
ring_col <- colnames(df)[[k]]
if(j==k){
#the output of this loop is 3 separate columns for each year's old dbh, hence why it is set to q as a dataframe before being combined below. Pointer_years_simple comes from #4d.
q <- data.frame(sapply(pointer_years_simple, function(x){
rw <- df[rownames(df)>=x, ]
ifelse(dbh$year == x & dbh$tree == ring_ind,
dbh$dbh2008.mm - 2*(dbh$mean_bark_2008.mm) - sum(rw[rownames(rw) %in% c(x:2008), ring_col], na.rm=TRUE), 0)
}))
q$diam_nobark_old.mm <- q[,1] +q[,2] + q[,3] #add columns together
# q$dbh_old.mm <- q[,1] +q[,2] + q[,3] + q[,4]
dbh$diam_nobark_old.mm <- dbh$diam_nobark_old.mm + q$diam_nobark_old.mm #combine with dbh (it's the same order of rows) #mm
}
}
}
#the full equation at the bottom is the regression equation for all these species put together. "fagr" is given a bark thickness of 0 because it is negligble
#these equations are the same as above in #3 of this code section
dbh$bark_thick_old.ln.mm <- NA
dbh$bark_thick_old.ln.mm <-
ifelse(dbh$sp == "caco", -1.56+0.416*log(dbh$diam_nobark_old.mm),
ifelse(dbh$sp == "cagl", -0.393+0.268*log(dbh$diam_nobark_old.mm),
ifelse(dbh$sp == "caovl", -2.18+0.651*log(dbh$diam_nobark_old.mm),
ifelse(dbh$sp == "cato", -0.477+0.301*log(dbh$diam_nobark_old.mm),
ifelse(dbh$sp == "fram", 0.418+0.268*log(dbh$diam_nobark_old.mm),
ifelse(dbh$sp == "juni", 0.346+0.279*log(dbh$diam_nobark_old.mm),
ifelse(dbh$sp == "litu", -1.14+0.463*log(dbh$diam_nobark_old.mm),
ifelse(dbh$sp == "qual", -2.09+0.637*log(dbh$diam_nobark_old.mm),
ifelse(dbh$sp == "qupr", -1.31+0.528*log(dbh$diam_nobark_old.mm),
ifelse(dbh$sp == "quru", -0.593+0.292*log(dbh$diam_nobark_old.mm),
ifelse(dbh$sp == "quve", 0.245+0.219*log(dbh$diam_nobark_old.mm),
ifelse(dbh$sp == "fagr", 0,
-1.01+0.213*log(dbh$diam_nobark_old.mm)))))))))))))
warnings()
unique(dbh$sp)
View(dbh)
meh <- dbh[is.nan(dbh$bark_thick_old.ln.mm), ]
View(meh)
#the full equation at the bottom is the regression equation for all these species put together. "fagr" is given a bark thickness of 0 because it is negligble
#these equations are the same as above in #3 of this code section
dbh$bark_thick_old.ln.mm <- NA
dbh$bark_thick_old.ln.mm <-
ifelse(dbh$sp == "caco", -1.56+0.416*log(dbh$diam_nobark_old.mm),
ifelse(dbh$sp == "cagl", -0.393+0.268*log(dbh$diam_nobark_old.mm),
ifelse(dbh$sp == "caovl", -2.18+0.651*log(dbh$diam_nobark_old.mm),
ifelse(dbh$sp == "cato", -0.477+0.301*log(dbh$diam_nobark_old.mm),
ifelse(dbh$sp == "fram", 0.418+0.268*log(dbh$diam_nobark_old.mm),
ifelse(dbh$sp == "juni", 0.346+0.279*log(dbh$diam_nobark_old.mm),
ifelse(dbh$sp == "litu", -1.14+0.463*log(dbh$diam_nobark_old.mm),
ifelse(dbh$sp == "qual", -2.09+0.637*log(dbh$diam_nobark_old.mm),
ifelse(dbh$sp == "qupr", -1.31+0.528*log(dbh$diam_nobark_old.mm),
ifelse(dbh$sp == "quru", -0.593+0.292*log(dbh$diam_nobark_old.mm),
ifelse(dbh$sp == "quve", 0.245+0.219*log(dbh$diam_nobark_old.mm),
ifelse(dbh$sp == "fagr", 0))))))))))))
dbh$bark_thick_old.ln.mm <-
ifelse(dbh$sp == "caco", -1.56+0.416*log(dbh$diam_nobark_old.mm),
ifelse(dbh$sp == "cagl", -0.393+0.268*log(dbh$diam_nobark_old.mm),
ifelse(dbh$sp == "caovl", -2.18+0.651*log(dbh$diam_nobark_old.mm),
ifelse(dbh$sp == "cato", -0.477+0.301*log(dbh$diam_nobark_old.mm),
ifelse(dbh$sp == "fram", 0.418+0.268*log(dbh$diam_nobark_old.mm),
ifelse(dbh$sp == "juni", 0.346+0.279*log(dbh$diam_nobark_old.mm),
ifelse(dbh$sp == "litu", -1.14+0.463*log(dbh$diam_nobark_old.mm),
ifelse(dbh$sp == "qual", -2.09+0.637*log(dbh$diam_nobark_old.mm),
ifelse(dbh$sp == "qupr", -1.31+0.528*log(dbh$diam_nobark_old.mm),
ifelse(dbh$sp == "quru", -0.593+0.292*log(dbh$diam_nobark_old.mm),
ifelse(dbh$sp == "quve", 0.245+0.219*log(dbh$diam_nobark_old.mm),
dbh$sp == "fagr", 0)))))))))))
#the full equation at the bottom is the regression equation for all these species put together. "fagr" is given a bark thickness of 0 because it is negligble
#these equations are the same as above in #3 of this code section
dbh$bark_thick_old.ln.mm <- NA
dbh$bark_thick_old.ln.mm <-
ifelse(dbh$sp == "caco", -1.56+0.416*log(dbh$diam_nobark_old.mm),
ifelse(dbh$sp == "cagl", -0.393+0.268*log(dbh$diam_nobark_old.mm),
ifelse(dbh$sp == "caovl", -2.18+0.651*log(dbh$diam_nobark_old.mm),
ifelse(dbh$sp == "cato", -0.477+0.301*log(dbh$diam_nobark_old.mm),
ifelse(dbh$sp == "fram", 0.418+0.268*log(dbh$diam_nobark_old.mm),
ifelse(dbh$sp == "juni", 0.346+0.279*log(dbh$diam_nobark_old.mm),
ifelse(dbh$sp == "litu", -1.14+0.463*log(dbh$diam_nobark_old.mm),
ifelse(dbh$sp == "qual", -2.09+0.637*log(dbh$diam_nobark_old.mm),
ifelse(dbh$sp == "qupr", -1.31+0.528*log(dbh$diam_nobark_old.mm),
ifelse(dbh$sp == "quru", -0.593+0.292*log(dbh$diam_nobark_old.mm),
ifelse(dbh$sp == "quve", 0.245+0.219*log(dbh$diam_nobark_old.mm),
0)))))))))))
warnings()
View(dbh)
ggplot(data = bark, aes(x = log(diam_nobark_2008.mm), y = log(bark.depth.mm))) +
stat_smooth_func(geom="text",method="lm",hjust=0.16, vjust=-0.5,parse=TRUE) +
geom_smooth(method="lm", se=FALSE, color="black") +
geom_point(color = "#0c4c8a") +
theme_minimal() +
facet_wrap(vars(species))
ggplot(data = bark, aes(x = log(diam_nobark_2008.mm), y = log(bark.depth.mm))) +
stat_smooth_func(geom="text",method="lm",hjust=0.1, vjust=-0.5,parse=TRUE) +
geom_smooth(method="lm", se=FALSE, color="black") +
geom_point(color = "#0c4c8a") +
theme_minimal() +
facet_wrap(vars(species))
ggplot(data = bark, aes(x = log(diam_nobark_2008.mm), y = log(bark.depth.mm))) +
stat_smooth_func(geom="text",method="lm",hjust=-1, vjust=-0.5,parse=TRUE) +
geom_smooth(method="lm", se=FALSE, color="black") +
geom_point(color = "#0c4c8a") +
theme_minimal() +
facet_wrap(vars(species))
ggplot(data = bark, aes(x = log(diam_nobark_2008.mm), y = log(bark.depth.mm))) +
stat_smooth_func(geom="text",method="lm",hjust=1.5, vjust=-0.5,parse=TRUE) +
geom_smooth(method="lm", se=FALSE, color="black") +
geom_point(color = "#0c4c8a") +
theme_minimal() +
facet_wrap(vars(species))
ggplot(data = bark, aes(x = log(diam_nobark_2008.mm), y = log(bark.depth.mm))) +
stat_smooth_func(geom="text",method="lm",hjust=1.16, vjust=-0.5,parse=TRUE) +
geom_smooth(method="lm", se=FALSE, color="black") +
geom_point(color = "#0c4c8a") +
theme_minimal() +
facet_wrap(vars(species))
ggplot(data = bark, aes(x = log(diam_nobark_2008.mm), y = log(bark.depth.mm))) +
stat_smooth_func(geom="text",method="lm",hjust=0.16, vjust=-0.5,parse=TRUE) +
geom_smooth(method="lm", se=FALSE, color="black") +
geom_point(color = "#0c4c8a") +
theme_minimal() +
facet_wrap(vars(species))
