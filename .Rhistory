(data_bi$quadrat %in% c(216:232))|
(data_bi$quadrat %in% c(316:332))|
(data_bi$quadrat %in% c(416:432))|
(data_bi$quadrat %in% c(516:532))|
(data_bi$quadrat %in% c(616:624))|
(data_bi$quadrat %in% c(716:724))|
(data_bi$quadrat %in% c(816:824)), 4,
ifelse((data_bi$quadrat %in% c(916:924))|
(data_bi$quadrat %in% c(1016:1024))|
(data_bi$quadrat %in% c(1116:1124))|
(data_bi$quadrat %in% c(1216:1224))|
(data_bi$quadrat %in% c(1316:1324))|
(data_bi$quadrat %in% c(1416,1417,1422)), 5,
ifelse((data_bi$quadrat %in% c(1419))|
(data_bi$quadrat %in% c(1516:1524))|
(data_bi$quadrat %in% c(1616:1624))|
(data_bi$quadrat %in% c(1716:1724))|
(data_bi$quadrat %in% c(1816:1824))|
(data_bi$quadrat %in% c(1916:1924))|
(data_bi$quadrat %in% c(2016:2024)), 6,
ifelse((data_bi$quadrat %in% c(625:632))|
(data_bi$quadrat %in% c(725:732))|
(data_bi$quadrat %in% c(825:832))|
(data_bi$quadrat %in% c(925:932))|
(data_bi$quadrat %in% c(1025:1029,1031,1032)), 7,
ifelse((data_bi$quadrat %in% c(1030))|
(data_bi$quadrat %in% c(1125:1132))|
(data_bi$quadrat %in% c(1225:1232))|
(data_bi$quadrat %in% c(1325:1332))|
(data_bi$quadrat %in% c(1425:1432)), 8,
ifelse((data_bi$quadrat %in% c(1525:1532))|
(data_bi$quadrat %in% c(1625:1632))|
(data_bi$quadrat %in% c(1725:1732))|
(data_bi$quadrat %in% c(1825:1832))|
(data_bi$quadrat %in% c(1925:1932))|
(data_bi$quadrat %in% c(2025:2032)), 9, "")))))))))
View(data_bi)
matrix <- function(data_bi, table_title) {
rbind(c(table_title, rep('', ncol(data_bi)-1)), # title
names(data_bi), # column names
unname(sapply(data_bi, as.character))) # data
}
temp <- matrix(data_bi, table_title=('Biannual Survey       Spr.Date:                       Spr.SurveyID:                  Spr.Recorder:                   |FallDate:                       FallSurveyID:                 FallRecorder:'))
library(xlsx)
write.xlsx(temp, "field_form_biannual_2019.xlsx", row.names=FALSE, col.names=FALSE) #we write the file to .xlsx to more easily change print settings and cell dimensions
View(data_bi)
##2a. spring survey data entry ####
data_biannual <- data_bi
setnames(data_biannual, old=c("Spring measure", "codes&notes_spr"), new=c("measure", "codes"))
library(data.table)
setnames(data_biannual, old=c("Spring measure", "codes&notes_spr"), new=c("measure", "codes"))
View(data_biannual)
data_biannual <- data_biannual[!names(data_biannual) == c("Fall measure", "codes&notes_fall")]
data_biannual <- data_biannual[!colnames(data_biannual) == c("Fall measure", "codes&notes_fall")]
View(data_biannual)
colnames(data_bianunl)
colnames(data_biannual)
data_biannual <- data_biannual[!colnames(data_biannual) %in% c("Fall measure", "codes&notes_fall")]
View(data_biannual)
newcols <- c("survey.ID", "year", "month", "day", "notes", "field.recorders", "data.enter")
data_biannual[,newcols] <- ""
View(data_biannual)
data_biannual <- data_bi
library(data.table)
setnames(data_biannual, old=c("stem", "Spring measure", "codes&notes_spr", "crown", "illum"), new=c("stemtag", "measure", "codes", "crown.condition", "crown.illum"))
data_biannual <- data_biannual[!colnames(data_biannual) %in% c("Fall measure", "codes&notes_fall", "dbh", "lx", "ly")]
newcols <- c("survey.ID", "year", "month", "day", "notes", "field.recorders", "data.enter")
data_biannual[,newcols] <- ""
data_biannual <- data_biannual[, c("tag", "stemtag", "sp", "quadrat", "survey.ID", "year", "month", "day", "measure", "crown.condition", "crown.illum", "codes", "notes", "field.recorders", "data.enter", "area")]
colnames(data_biannual)
setnames(data_biannual, old=c("stem", "Spring measure", "codes&notes_spr", "crown", "illum"), new=c("stemtag", "measure", "codes", "crown.condition", "crown.illum"))
##2a. spring survey data entry ####
data_biannual <- data_bi
View(data_biannual)
View(data_bi)
colnames(data_biannual$stem) <- "stemtag"
names(data_biannual$stem) <- "stemtag"
View(data_biannual)
#1 Create field_form biannual ####
setwd("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/Dendrobands/resources/field_forms")
##1a. if new trees added between last fall survey and spring survey, do this ####
data_2019 <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/Dendrobands/data/scbi.dendroAll_2019.csv")
data_2018 <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/Dendrobands/data/scbi.dendroAll_2018.csv")
prevmeasbi <- subset(data_2018,survey.ID=="2018.14" & biannual=="1") #subset by previous survey.ID to get previous measure. If printing this for the spring survey, use the last survey.ID from last year.
data_bi <- data_2019
data_bi$prevmeas <- prevmeasbi$measure[match(data_bi$stemID, prevmeasbi$stemID)]
data_bi<-data_bi[ ,c("tag", "stemtag", "sp", "dbh", "quadrat", "lx", "ly", "measure", "crown.condition", "crown.illum", "codes", "prevmeas")]
data_bi$prevmeas <- ifelse(!is.na(data_bi$measure), data_bi$measure, data_bi$prevmeas)
check <- data_bi[is.na(data_bi$prevmeas), ]
data_bi$measure = NA
data_bi$codes = NA
data_bi$crown.condition = NA
data_bi$crown.illum = NA
data_bi$"Fall measure"= NA
library(dplyr)
data_bi<-data_bi %>% rename("Spring measure" = measure, "codes&notes_spr" = codes, "stem" = stemtag, "crown" = crown.condition, "illum" = crown.illum)
cols <- colnames(data_bi[,c(8:11,13)])
data_bi[,cols] <- " "
data_bi$"codes&notes_fall" <- ""
data_bi<-data_bi[,c("tag", "stem", "sp", "dbh", "quadrat", "lx", "ly", "prevmeas", "Spring measure", "Fall measure", "crown", "illum", "codes&notes_spr", "codes&notes_fall")]
##1c. continue with code from either 1a. or 1b. ####
#assign values per tag by survey area (based on biannual map in https://github.com/SCBI-ForestGEO/Dendrobands/tree/master/maps)
data_bi$area <- ""
data_bi$area <-
ifelse((data_bi$quadrat %in% c(1301:1303))|
(data_bi$quadrat %in% c(1401:1404))|
(data_bi$quadrat %in% c(1501:1515))|
(data_bi$quadrat %in% c(1601:1615))|
(data_bi$quadrat %in% c(1701:1715))|
(data_bi$quadrat %in% c(1801:1815))|
(data_bi$quadrat %in% c(1901:1915))|
(data_bi$quadrat %in% c(2001:2015)), 1,
ifelse((data_bi$quadrat %in% c(504:507))|
(data_bi$quadrat %in% c(608))|
(data_bi$quadrat %in% c(703:712))|
(data_bi$quadrat %in% c(803:813))|
(data_bi$quadrat %in% c(901:913))|
(data_bi$quadrat %in% c(1003:1012))|
(data_bi$quadrat %in% c(1101:1112))|
(data_bi$quadrat %in% c(1201:1212))|
(data_bi$quadrat %in% c(1304:1311))|
(data_bi$quadrat %in% c(1405:1411)), 2,
ifelse((data_bi$quadrat %in% c(101:115))|
(data_bi$quadrat %in% c(201:215))|
(data_bi$quadrat %in% c(301:315))|
(data_bi$quadrat %in% c(401:415))|
(data_bi$quadrat %in% c(502,514,515,610,611,614
,615,701,702,713,714,715
,801,1001,1014,1313,1314
,1315,1413)), 3,
ifelse((data_bi$quadrat %in% c(116:132))|
(data_bi$quadrat %in% c(216:232))|
(data_bi$quadrat %in% c(316:332))|
(data_bi$quadrat %in% c(416:432))|
(data_bi$quadrat %in% c(516:532))|
(data_bi$quadrat %in% c(616:624))|
(data_bi$quadrat %in% c(716:724))|
(data_bi$quadrat %in% c(816:824)), 4,
ifelse((data_bi$quadrat %in% c(916:924))|
(data_bi$quadrat %in% c(1016:1024))|
(data_bi$quadrat %in% c(1116:1124))|
(data_bi$quadrat %in% c(1216:1224))|
(data_bi$quadrat %in% c(1316:1324))|
(data_bi$quadrat %in% c(1416,1417,1422)), 5,
ifelse((data_bi$quadrat %in% c(1419))|
(data_bi$quadrat %in% c(1516:1524))|
(data_bi$quadrat %in% c(1616:1624))|
(data_bi$quadrat %in% c(1716:1724))|
(data_bi$quadrat %in% c(1816:1824))|
(data_bi$quadrat %in% c(1916:1924))|
(data_bi$quadrat %in% c(2016:2024)), 6,
ifelse((data_bi$quadrat %in% c(625:632))|
(data_bi$quadrat %in% c(725:732))|
(data_bi$quadrat %in% c(825:832))|
(data_bi$quadrat %in% c(925:932))|
(data_bi$quadrat %in% c(1025:1029,1031,1032)), 7,
ifelse((data_bi$quadrat %in% c(1030))|
(data_bi$quadrat %in% c(1125:1132))|
(data_bi$quadrat %in% c(1225:1232))|
(data_bi$quadrat %in% c(1325:1332))|
(data_bi$quadrat %in% c(1425:1432)), 8,
ifelse((data_bi$quadrat %in% c(1525:1532))|
(data_bi$quadrat %in% c(1625:1632))|
(data_bi$quadrat %in% c(1725:1732))|
(data_bi$quadrat %in% c(1825:1832))|
(data_bi$quadrat %in% c(1925:1932))|
(data_bi$quadrat %in% c(2025:2032)), 9, "")))))))))
setwd("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/Dendrobands/resources/data_entry_forms")
data_biannual <- data_bi
library(data.table)
setnames(data_biannual, old=c("stem", "Spring measure", "codes&notes_spr", "crown", "illum"), new=c("stemtag", "measure", "codes", "crown.condition", "crown.illum"))
data_biannual <- data_biannual[!colnames(data_biannual) %in% c("Fall measure", "codes&notes_fall", "dbh", "lx", "ly")]
newcols <- c("survey.ID", "year", "month", "day", "notes", "field.recorders", "data.enter")
data_biannual[,newcols] <- ""
data_biannual <- data_biannual[, c("tag", "stemtag", "sp", "quadrat", "survey.ID", "year", "month", "day", "measure", "crown.condition", "crown.illum", "codes", "notes", "field.recorders", "data.enter", "area")]
View(data_biannual)
write.csv(data_biannual, "data_entry_biannual_spr2019.csv", row.names=FALSE)
setwd("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/Dendrobands/resources/maps")
dendro_trees <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/Dendrobands/data/dendro_trees.csv")
#to start off, filter by all the trees that are alive as of the end of last year's fall survey.
bands_2019 <- dendro_trees[is.na(dendro_trees$mortality.year), ]
bands_2019 <- bands_2019[complete.cases(bands_2018[, c("NAD83_X", "NAD83_Y")]),] # remove one tree with missing coordinates
bands_2019 <- bands_2019[complete.cases(bands_2019[, c("NAD83_X", "NAD83_Y")]),] # remove one tree with missing coordinates
library(ggplot2)
library(rgdal)
library(broom) #for the tidy function
library(sf) #for mapping
library(ggthemes) #for removing graticules when making pdf
scbi_plot <- readOGR("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/SCBI-ForestGEO-Data/spatial_data/shapefiles/20m_grid.shp")
deer <- readOGR("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/SCBI-ForestGEO-Data/spatial_data/shapefiles/deer_exclosure_2011.shp")
roads <- readOGR("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/SCBI-ForestGEO-Data/spatial_data/shapefiles/SCBI_roads_edits.shp")
streams <- readOGR("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/SCBI-ForestGEO-Data/spatial_data/shapefiles/SCBI_streams_edits.shp")
contour_10m <- readOGR("V:/SIGEO/GIS_data/dendroband surveys/dendroband intraannual/contour10m_SIGEO_clipped.shp")
survey_areas <- readOGR("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/Dendrobands/resources/maps/shapefiles/biannual_survey_areas.shp")
NS_divide <- readOGR("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/Dendrobands/resources/maps/shapefiles/NS_divide1.shp")
#convert all shp to dataframe so that it can be used by ggplot
#if tidy isn't working, can also do: xxx_df <- as(xxx, "data.frame")
scbi_plot_df <- tidy(scbi_plot)
deer_df <- tidy(deer)
roads_df <- tidy(roads)
streams_df <- tidy(streams)
survey_areas_df <- tidy(survey_areas)
NS_divide_df <- tidy(NS_divide)
contour_10m_df <- tidy(contour_10m)
#x and y give the x/yposition on the plot; sprintf says to add 0 for single digits, the x/y=seq(...,length.out) says fit the label within these parameters, fitting the length of the label evenly.
##this code adds the row and column numbers based on coordinates
rows <- annotate("text", x = seq(747350, 747365, length.out = 32), y = seq(4309125, 4308505, length.out = 32), label = sprintf("%02d", 32:1) , size=5.25, color="black")
cols <- annotate("text", x = seq(747390, 747765, length.out = 20), y = seq(4308495, 4308505, length.out = 20), label = sprintf("%02d", 1:20), size=5.4, color="black")
#these are the numbers for the survey areas, following the survey_area shp border areas
section1 <- annotate("text", x= 747730, y= 4308705, label = "1", size=6, fontface=2)
section2 <- annotate("text", x= 747630, y= 4308683, label = "2", size=6, fontface=2)
section3 <- annotate("text", x= 747450, y= 4308717, label = "3", size=6, fontface=2)
section4 <- annotate("text", x= 747445, y= 4309000, label = "4", size=6, fontface=2)
section5 <- annotate("text", x= 747567, y= 4308920, label = "5", size=6, fontface=2)
section6 <- annotate("text", x= 747687, y= 4308923, label = "6", size=6, fontface=2)
section7 <- annotate("text", x= 747520, y= 4309100, label = "7", size=6, fontface=2)
section8 <- annotate("text", x= 747605, y= 4309100, label = "8", size=6, fontface=2)
section9 <- annotate("text", x= 747725, y= 4309045, label = "9", size=6, fontface=2)
#biannual survey map ####
map <- ggplot() +
geom_path(data = scbi_plot_df, aes(x = long, y = lat, group = group))+
geom_path(data=roads_df, aes(x=long, y=lat, group=group),
color="#996600", linetype=2)+
geom_path(data=streams_df, aes(x=long, y=lat, group=group), color="blue")+
geom_path(data=survey_areas_df, aes(x=long, y=lat, group=group), size=1.1)+
geom_point(data=bands_2018, aes(x=NAD83_X, y=NAD83_Y), shape=19)+
geom_text(data=bands_2018, aes(x=NAD83_X, y=NAD83_Y, label=tag),
size=3, hjust=1.25, nudge_y=-1, nudge_x=1, check_overlap=TRUE)+
labs(title="Dendrobands_Biannual_2019")+
theme(plot.title=element_text(vjust=0.1))+
coord_sf(crs = "crs = +proj=merc", xlim=c(747350,747800), ylim=c(4308500, 4309125))
#now, we add the row and column labels
##to get rid of the graticules (the lat/lon labels and lines), you need to have both "theme" calls in the following function.
pdf("dendroband_biannual_map.pdf", width = 8.5, height=11)
map +
rows +
cols +
section1 + section2 + section3 + section4 + section5 + section6 + section7 + section8 + section9 +
theme_map()+
theme(panel.grid.major = element_line(colour = 'transparent'))
dev.off() #when printing, choose "fit to page"
map <- ggplot() +
geom_path(data = scbi_plot_df, aes(x = long, y = lat, group = group))+
geom_path(data=roads_df, aes(x=long, y=lat, group=group),
color="#996600", linetype=2)+
geom_path(data=streams_df, aes(x=long, y=lat, group=group), color="blue")+
geom_path(data=survey_areas_df, aes(x=long, y=lat, group=group), size=1.1)+
geom_point(data=bands_2019, aes(x=NAD83_X, y=NAD83_Y), shape=19)+
geom_text(data=bands_2019, aes(x=NAD83_X, y=NAD83_Y, label=tag),
size=3, hjust=1.25, nudge_y=-1, nudge_x=1, check_overlap=TRUE)+
labs(title="Dendrobands_Biannual_2019")+
theme(plot.title=element_text(vjust=0.1))+
coord_sf(crs = "crs = +proj=merc", xlim=c(747350,747800), ylim=c(4308500, 4309125))
#now, we add the row and column labels
##to get rid of the graticules (the lat/lon labels and lines), you need to have both "theme" calls in the following function.
pdf("dendroband_biannual_map.pdf", width = 8.5, height=11)
map +
rows +
cols +
section1 + section2 + section3 + section4 + section5 + section6 + section7 + section8 + section9 +
theme_map()+
theme(panel.grid.major = element_line(colour = 'transparent'))
dev.off() #when printing, choose "fit to page"
library(pointRes)
library(dplR)
library(data.table)
##4a. canopy ####
setwd("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/SCBI-ForestGEO-Data/tree_cores/chronologies/current_chronologies/complete/separated by canopy position/canopy_cores")
dirs_can <- dir("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/SCBI-ForestGEO-Data/tree_cores/chronologies/current_chronologies/complete/separated by canopy position/canopy_cores", pattern = "_canopy.rwl")
dirs_can <- dirs_can[dirs_can != "frni_canopy.rwl" & dirs_can != "frni_drop_canopy.rwl" & dirs_can != "caco_drop_canopy.rwl"]
sp_can <- gsub("_drop_canopy.rwl", "", dirs_can)
canopy <- list()
widths_can <- list()
canopy_table <- NULL
for (i in seq(along=dirs_can)){
for (j in seq(along=sp_can)){
if (i==j){
file <- dirs_can[[i]]
rings <- read.rwl(file) #read in rwl file
area <- bai.in(rings) #convert to bai.in
testr <- res.comp(area, nb.yrs=5, res.thresh.neg = 30, series.thresh = 50) #get resilience metrics
canopy[[i]] <- testr
widths_can[[i]] <- rings
testr_table <- data.frame(testr$out)
testr_table <- testr_table[testr_table$nb.series > 4, ] #remove where there are < 4 series
testr_table$sp <- sp_can[[j]]
testr_table$position <- "canopy"
canopy_table <- rbind(canopy_table, testr_table)
}
values <- paste0(sp_can, "_can_res")
names(canopy) <- values
values <- paste0(sp_can, "_canopy")
names(widths_can) <- values
##4b. subcanopy ####
setwd("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/SCBI-ForestGEO-Data/tree_cores/chronologies/current_chronologies/complete/separated by canopy position/subcanopy_cores")
dirs_subcan <- dir("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/SCBI-ForestGEO-Data/tree_cores/chronologies/current_chronologies/complete/separated by canopy position/subcanopy_cores", pattern = "_subcanopy.rwl")
#dirs_subcan <- dirs_subcan[dirs_subcan != "frni_drop_subcanopy.rwl" & dirs_subcan != "caco_drop_subcanopy.rwl"]
sp_subcan <- gsub("_drop_subcanopy.rwl", "", dirs_subcan)
subcanopy <- list()
widths_sub <- list()
subcanopy_table <- NULL
for (i in seq(along=dirs_subcan)){
for (j in seq(along=sp_subcan)){
if (i==j){
file <- dirs_subcan[[i]]
rings <- read.rwl(file) #read in rwl file
area <- bai.in(rings) #convert to bai.in
test <- res.comp(area, nb.yrs=5, res.thresh.neg = 30, series.thresh = 50) #get resilience metrics
subcanopy[[i]] <- test
widths_sub[[i]] <- rings
test_table <- data.frame(test$out)
test_table <- test_table[test_table$nb.series > 4, ] #remove where there are < 4 series
test_table$sp <- sp_subcan[[j]]
test_table$position <- "subcanopy"
subcanopy_table <- rbind(subcanopy_table, test_table)
}
values_sub <- paste0(sp_subcan, "_subcan_res")
names(subcanopy) <- values_sub
values <- paste0(sp_subcan, "_subcanopy")
names(widths_sub) <- values
widths <- c(widths_can, widths_sub) #combine into one, then delete. For use in #5d
widths_can <- NULL
widths_subcan <- NULL
##4c. df for pointer years of all trees combined ####
full_ind <- rbind(canopy_table, subcanopy_table) #full table of indices for canopy and subcanopy cores
pointers <- full_ind[full_ind$nature == -1, ]
library(dplyr)
years_point <- count(pointers, vars=year) #counts the occurrences of each unique year
colnames(years_point) <- c("yr", "n.pointer")
years_point <- years_point[order(years_point$n.pointer, decreasing=TRUE), ]
setwd("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/McGregor_climate-sensitivity-variation")
#write.csv(pointers, "occurrence_of_pointer_yrs.csv", row.names=FALSE)
##4d. resistance metrics for all trees ####
neil_list <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/McGregor_climate-sensitivity-variation/core_list_for_neil.csv", stringsAsFactors = FALSE)
neil_list$tag <- paste0("X", neil_list$tag) #to match the colnames of can_resist below
pointer_years <- head(years_point$yr) #from above in #4c
pointer_years <- pointer_years[!pointer_years %in% c(1911, 1947, 1991)]
###canopy ####
#this loop says, for the different species in the list "canopy" (names(canopy)), create a dataframe of only the resistance index. Make a list of the colnames, which are the individual trees. Then, assign species identifiers for each one from Neil's core list, subset by the defined pointer years, and melt the data before rbinding.
tag_n <- names(canopy)
trees_canopy <- NULL
for (i in seq(along=1:length(tag_n))){
can_resist <- data.frame(canopy[[i]]$resist)
years <- rownames(can_resist)
colnames(can_resist) <- gsub("A", "", colnames(can_resist))
tree_series <- colnames(can_resist)
# for (j in seq(along=tree_series)){
#  trees <- tree_series[[j]]
ind <- can_resist
ind_neil <- neil_list[neil_list$tag %in% tree_series, ]
#  colnames(ind) <- trees
ind$year <- years
ind$sp <- unique(ind_neil$sp)
ind$position <- "canopy"
ind <- ind[ind$year %in% pointer_years, ]
change <- melt(ind)
setnames(change, old=c("variable", "value"), new=c("tree", "resist.value"))
change$tree <- gsub("X", "", change$tree)
change$tree <- gsub("^0", "", change$tree)
trees_canopy <- rbind(trees_canopy, change)
}
###subcanopy ####
#this loop says, for the different species in the list "subcanopy" (names(subcanopy)), create a dataframe of only the resistance index. Make a list of the colnames, which are the individual trees. Then, assign species identifiers for each one from Neil's core list, subset by the defined pointer years, and melt the data before rbinding.
tag_n <- names(subcanopy)
trees_subcanopy <- NULL
for (i in seq(along=1:length(tag_n))){
sub_resist <- data.frame(subcanopy[[i]]$resist)
years <- rownames(sub_resist)
colnames(sub_resist) <- gsub("A", "", colnames(sub_resist))
tree_series <- colnames(sub_resist)
# for (j in seq(along=tree_series)){
#  trees <- tree_series[[j]]
ind <- sub_resist
ind_neil <- neil_list[neil_list$tag %in% tree_series, ]
#  colnames(ind) <- trees
ind$year <- years
ind$sp <- unique(ind_neil$sp)
ind$position <- "subcanopy"
ind <- ind[ind$year %in% pointer_years, ]
change <- melt(ind)
setnames(change, old=c("variable", "value"), new=c("tree", "resist.value"))
change$tree <- gsub("X", "", change$tree)
change$tree <- gsub("^0", "", change$tree)
trees_subcanopy <- rbind(trees_subcanopy, change)
}
###rbind together ####
trees_all <- rbind(trees_canopy, trees_subcanopy)
trees_all$year <- as.numeric(trees_all$year)
#subset out NAs for resistance values (not necessary, bc lmm will automatically exclude them)
trees_all <- trees_all[!is.na(trees_all$resist.value), ]
##4e. determine proportion of resistance values per sp ####
prop <- data.frame("sp" = unique(trees_all$sp))
prop$value.over1 <- NA
prop$can.value.over1 <- NA
prop$sub.value.over1 <- NA
trees_all.sp <- unique(trees_all$sp)
for (i in seq(along=prop$sp)){
for (j in seq(along=unique(trees_all.sp))){
if (i==j){
temp <- trees_all[trees_all$sp == trees_all.sp[[j]] & trees_all$resist.value>=1, ]
temp <- temp[!is.na(temp$resist.value), ]
prop$value.over1[[i]] <- nrow(temp)
prop$can.value.over1[[i]] <- nrow(temp[temp$position == "canopy", ])
prop$sub.value.over1[[i]] <- nrow(temp[temp$position == "subcanopy", ])
}
#5. add in climate and growth variables ####
##5a. add in turgor loss point values ####
#add in tlp values (from Krista github issue #6 https://github.com/SCBI-ForestGEO/McGregor_climate-sensitivity-variation/issues/6)
turgor <- data.frame("sp" = c("cagl", "caovl", "fagr", "fram", "juni", "litu", "pist", "qual", "qupr", "quru", "quve", "caco", "cato", "frni"), "tlp" = c(-2.1282533, -2.24839333, -2.57164, -2.1012133, -2.75936, -1.9212933, NA, -2.58412, -2.3601733, -2.6395867, -2.3879067, -2.1324133, -2.31424, NA))
trees_all$tlp <- turgor$tlp[match(trees_all$sp, turgor$sp)]
#tlp for pist is NA. Running the models below with this gives the min(AICc) for lmm.combined. Removing pist, however (because of the tlp NA), and running AICc and anova shows the best model to be lmm.random.
#trees_all <- trees_all[!trees_all$sp == "pist", ]
##5b. add in ring porosity qualifications ####
ring_porosity <- data.frame("sp" = c("cagl",  "caovl", "cato", "fagr", "fram", "juni",  "litu",  "pist",  "qual",  "qupr",  "quru",  "quve", "caco", "frni"), "rp" = c("ring", "ring", "ring", "diffuse", "ring", "semi-ring", "diffuse", NA, "ring", "ring", "ring", "ring", "ring", "ring"))
trees_all$rp <- ring_porosity$rp[match(trees_all$sp, ring_porosity$sp)]
##5c. add in elevation data ####
elev <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/SCBI-ForestGEO-Data/spatial_data/elevation/full_stem_elevation_2013.csv")
trees_all$elev_m <- elev$dem_sigeo[match(trees_all$tree, elev$tag)]
##5d. add in dbh in each year 1999 ####
dbh <- trees_all[, c(1:4)]
dbh$dbh2013 <- elev$dbh[match(dbh$tree, elev$tag)]
#create df with bark thickness log values and intercept values from Krista's paper (supplemental info)
#https://besjournals.onlinelibrary.wiley.com/doi/epdf/10.1111/1365-2435.12470
#fagr does not have bark thickness measured because it is negligible
bark <- data.frame(
"sp" = c("acru", "fagr", "litu", "nysy", "caco", "cagl", "caovl", "cato", "fram", "juni", "qual", "qupr", "quru", "quve", "ulru"),
"bark_thick" = c(-2.564, 0, -0.659, -0.611, -1.917, -0.495, -2.504, -0.945, 0.318, -0.293, -1.231, -0.647, -0.789, 1.5, 1.133),
"intercept" = c(0.599, 0, 0.425, 0.413, 0.503, 0.316, 0.703, 0.396, 0.295, 0.385, 0.526, 0.423, 0.341, 0.053, -0.057))
dbh$bark_thick <- bark$bark_thick[match(dbh$sp, bark$sp)]
dbh$intercept <- bark$intercept[match(dbh$sp, bark$sp)]
#the main equation is based on ring widths. We have determined the equation to be
# rw(pointer_year) <- 0.5*dbh2013 - bark_thick*(dbh2013^intercept) - sum(rw(pointer_year):rw(end)). The first part of the equation is here. Summing the pointer years happens with the "q" df below in the loop.
dbh$rw_prelim <- (0.5*dbh$dbh2013) - (dbh$bark_thick*(dbh$dbh2013^dbh$intercept))
dbh$dbh_old <- "0" #in prep for below
dbh$dbh_old <- as.numeric(dbh$dbh_old)
for (i in seq(along=widths)){
df <- widths[[i]] #the list "widths" comes from #4a-4b
colnames(df) <- gsub("A", "", colnames(df)) #remove "A"
colnames(df) <- gsub("^0", "", colnames(df)) #remove leading 0
cols <- colnames(df) #define cols for below
colnames(df) <- gsub("^", "x", colnames(df)) #add "x" to make calling colnames below feasible
for (j in seq(along=cols)){
for (k in seq(along=colnames(df))){
ring_ind <- cols[[j]]
ring_col <- colnames(df)[[k]]
if(j==k){
#the output of this loop is 3 separate columns for each year's old dbh, hence why it is set to q as a dataframe before being combined below
q <- data.frame(sapply(pointer_years, function(x){
rw <- df[rownames(df)>=x, ]
ifelse(dbh$year == x & dbh$tree == ring_ind,
dbh$rw_prelim - sum(rw[, ring_col], na.rm=TRUE), 0)
}))
q$dbh_old <- q[,1] +q[,2] + q[,3] #add columns together
dbh$dbh_old <- dbh$dbh_old + q$dbh_old #combine with dbh
}
# check <- dbh[dbh$dbh_old == 0, ] #check if any tree was missed
trees_all$dbh_old <- dbh$dbh_old
##5e. remove all NAs ####
trees_all <- trees_all[complete.cases(trees_all), ]
trees_all <- trees_all[trees_all$resist.value <= 2, ]
library(lme4)
library(AICcmodavg) #aictab function
library(car)
library(piecewiseSEM) #for R^2 values for all model outputs in a list
library(MuMIn) #for R^2 values of one model output
response <- "resist.value"
effects <- c("position", "tlp", "rp", "elev_m", "dbh_old", "year", "(1 | sp / tree)")
#create all combinations of random / fixed effects
effects_comb <-
unlist( sapply( seq_len(length(effects)),
function(i) {
apply( combn(effects,i), 2, function(x) paste(x, collapse = "+"))
}))
# pair response with effect and sub out combinations that don't include random effects
var_comb <- expand.grid(response, effects_comb)
var_comb <- var_comb[grepl("1", var_comb$Var2), ] #only keep in fixed/random combos
var_comb <- var_comb[grepl("year", var_comb$Var2), ] #keep year in for drought sake
# formulas for all combinations. $Var1 is the response, and $Var2 is the effect
formula_vec <- sprintf("%s ~ %s", var_comb$Var1, var_comb$Var2)
# create list of model outputs
lmm_all <- lapply(formula_vec, function(x){
fit1 <- lmer(x, data = trees_all, REML=FALSE)
#fit1$coefficients <- coef( summary(fit1))
return(fit1)
})
names(lmm_all) <- formula_vec
var_aic <- aictab(lmm_all, second.ord=TRUE, sort=TRUE) #rank based on AICc
r <- rsquared(lmm_all) #gives R^2 values for models. "Marginal" is the R^2 for just the fixed effects, "Conditional" is the R^2 for everything.
View(var_aic)
View(r)
range(r$Conditional)
#this plot shows regression line for certain variables against resistance values, separated by year and species
ggplot(trees_all, aes(x = rp, y = resist.value, colour = year)) +
facet_wrap(~sp, nrow=4) +
geom_point() +
theme_classic() +
geom_line(data = cbind(trees_all, pred = predict(lmm_all[[31]])), aes(y = pred)) +
theme(legend.position = "right")
#this plot shows regression line for certain variables against resistance values, separated by year and species
ggplot(trees_all, aes(x = old_dbh, y = resist.value, colour = year)) +
facet_wrap(~sp, nrow=4) +
geom_point() +
theme_classic() +
geom_line(data = cbind(trees_all, pred = predict(lmm_all[[31]])), aes(y = pred)) +
theme(legend.position = "right")
#this plot shows regression line for certain variables against resistance values, separated by year and species
ggplot(trees_all, aes(x = dbh_old, y = resist.value, colour = year)) +
facet_wrap(~sp, nrow=4) +
geom_point() +
theme_classic() +
geom_line(data = cbind(trees_all, pred = predict(lmm_all[[31]])), aes(y = pred)) +
theme(legend.position = "right")
