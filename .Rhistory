View(best_mod_traits)
View(top_models)
ord_lab <- c("trees_all", "x1966", "x1977", "x1999")
coeff_list1 <- list()
for(q in seq(along=ord_lab)){
coeff_list_temp <- coeff_list[grepl(ord_lab[[q]], names(coeff_list))]
coeff_list_temp <-
coeff_list_temp[
order(
match(
as.numeric(
str_extract(names(coeff_list_temp)[grepl(ord_lab[[q]], names(coeff_list_temp))], "[[:digit:]]$")),
ord))]
coeff_list1 <- c(coeff_list1, coeff_list_temp)
}
View(coeff_list)
# to run the loop below, this list (coeff_list) needs to be created. The numbers
# reflect the order of the top models in coeff_list, which was created earlier in #6.
# Change the numbers here to match the ordering in that list, but realize that this
# numbering is absolute, so the 18th element is #18, not 1977 #3.
coeff_list <- coeff_list[c(2,4,1,3,5,6, #trees_all_sub
8,7,9, #x1966
11,13,15,10,12,14, #x1977
20,16,18,19,21,17)] #x1999
View(coeff_list)
best_mod_traits <- data.frame("best_model" = NA,
"scenario" = c("all droughts", "1966", "1977", "1999")
)
best_mod_full <- c(unique(cand_full$variable), "(1|sp/tree)")
best_mod_full_year <- gsub("/tree", "", best_mod_full)
best_mod_full_year <- best_mod_full_year[!best_mod_full_year %in% c("year")]
#beginning of loop
mods <- names(model_df)
top_models <- NULL
coeff_list <- list()
for (i in seq(along=c(1:4))){
for (j in seq(along=model_df)){
#ALL YEARS
if(j == 1 & i == 1){
response <- "resist.value"
effects <- best_mod_full
#create all combinations of random / fixed effects
effects_comb <-
unlist(sapply(seq_len(length(effects)), function(i) {
apply( combn(effects,i), 2, function(x) paste(x, collapse = "+"))
}))
#pair response with effect and sub out combinations that don't include random effects
#in general, if two variables are >70% correlated, you can toss one of them without significantly affecting the results
var_comb <- expand.grid(response, effects_comb)
var_comb <- var_comb[grepl("1", var_comb$Var2), ] #only keep in fixed/random combos
var_comb$Var2 <- as.character(var_comb$Var2)
#can't have height and TWI separately when the interaction is in
for (q in seq(along=var_comb$Var2)){
cell <- var_comb$Var2[[q]]
if(grepl("\\*", cell)){
if(grepl("\\+TWI.ln", cell)){
var_comb$Var2[[q]] <- gsub("\\+TWI.ln", "", var_comb$Var2[[q]])
}
if(grepl("\\+height.ln.m", cell)){
var_comb$Var2[[q]] <- gsub("\\+height.ln.m\\+", "\\+", var_comb$Var2[[q]])
}
}
}
var_comb <- unique(var_comb[,1:2])
# formulas for all combinations. $Var1 is the response, and $Var2 is the effect
# for good stats, you should have no more total parameters than 1/10th the number of observations in your dataset
formula_vec <- sprintf("%s ~ %s", var_comb$Var1, var_comb$Var2)
lmm_all <- lapply(formula_vec, function(x){
fit1 <- lmer(x, data = model_df[[j]], REML=FALSE,
control = lmerControl(optimizer ="Nelder_Mead"))
return(fit1)
})
names(lmm_all) <- formula_vec
var_aic <- aictab(lmm_all, second.ord=TRUE, sort=TRUE) #rank based on AICc
var_aic$Modnames <- as.character(var_aic$Modnames)
best_mod_traits$best_model[[i]] <- var_aic$Modnames[[1]]
#get all mods <2 dAIC
var_aic <- var_aic[var_aic$Delta_AICc <= 2, ]
var_aic$mod_no <- rownames(var_aic)
top <- var_aic[,c(1,4)]
top$Delta_AICc <- round(top$Delta_AICc, 2)
top$scenario <- mods[[i]]
top$coef <- NA
for (z in seq(along = lmm_all)){
for (w in seq(along=1:nrow(var_aic))){
if (names(lmm_all[z]) == var_aic$Modnames[[w]]){
#run the best model alone with REML=TRUE
fit1 <- lmer(formula_vec[[z]], data = model_df[[j]], REML=TRUE,
control = lmerControl(optimizer ="Nelder_Mead"))
#get coefficients and put in table
coeff <- data.frame(coef(summary(fit1))[ , "Estimate"]) ##2
coeff[,2] <- rownames(coeff)
coeff[,1] <- round(coeff[,1], 3)
colnames(coeff) <- c(paste0("[All years] ","Model #", w), "model_var")
#put r2 in table
delta <- data.frame(var_aic$Delta_AICc[[w]])
colnames(delta) <- paste0("[All years] ","Model #", w)
delta$model_var <- "dAICc"
r <- rsquared(fit1) #gives R^2 values for models. "Marginal" is the R^2 for just the fixed effects, "Conditional" is the R^2 for everything.
r <- data.frame(r[,6])
colnames(r) <- paste0("[All years] ","Model #", w)
r$model_var <- "r^2"
r[,1] <- round(r[,1], 2)
coeff <- rbind(delta, r, coeff)
coeff_list[[paste0("coeff_", names(model_df[j]), "_", w)]] <- coeff
}
}
}
#INDIVIDUAL YEARS
} else if (j == i){
response <- "resist.value"
effects <- best_mod_full_year
#create all combinations of random / fixed effects
effects_comb <-
unlist( sapply( seq_len(length(effects)),
function(i) {
apply( combn(effects,i), 2, function(x) paste(x, collapse = "+"))
}))
var_comb <- expand.grid(response, effects_comb)
var_comb <- var_comb[grepl("1", var_comb$Var2), ] #only keep in fixed/random combos
var_comb$Var2 <- as.character(var_comb$Var2)
#can't have height and TWI separately when the interaction is in
for (q in seq(along=var_comb$Var2)){
cell <- var_comb$Var2[[q]]
if(grepl("\\*", cell)){
if(grepl("\\+TWI.ln", cell)){
var_comb$Var2[[q]] <- gsub("\\+TWI.ln", "", var_comb$Var2[[q]])
}
if(grepl("\\+height.ln.m", cell)){
var_comb$Var2[[q]] <- gsub("\\+height.ln.m\\+", "\\+", var_comb$Var2[[q]])
}
}
}
var_comb <- unique(var_comb[,1:2])
formula_vec <- sprintf("%s ~ %s", var_comb$Var1, var_comb$Var2)
lmm_all <- lapply(formula_vec, function(x){
fit1 <- lmer(x, data = model_df[[j]], REML=FALSE,
control = lmerControl(optimizer ="Nelder_Mead"))
return(fit1)
})
names(lmm_all) <- formula_vec
var_aic <- aictab(lmm_all, second.ord=TRUE, sort=TRUE) #rank based on AICc
var_aic$Modnames <- as.character(var_aic$Modnames)
best_mod_traits$best_model[[i]] <- var_aic$Modnames[[1]]
#get all mods <2 dAIC
var_aic <- var_aic[var_aic$Delta_AICc <= 2, ]
top <- var_aic[,c(1,4)]
top$Delta_AICc <- round(top$Delta_AICc, 2)
top$scenario <- mods[[i]]
top$coef <- NA
for (z in seq(along = lmm_all)){
for (w in seq(along=1:nrow(var_aic))){
if (names(lmm_all[z]) == var_aic$Modnames[[w]]){
#run the best model alone with REML=TRUE
fit1 <- lmer(formula_vec[[z]], data = model_df[[j]], REML=TRUE,
control = lmerControl(optimizer ="Nelder_Mead"))
#get coefficients and put in table
coeff <- data.frame(coef(summary(fit1))[ , "Estimate"]) ##2
coeff[,2] <- rownames(coeff)
coeff[,1] <- round(coeff[,1], 3)
colnames(coeff) <- c(paste0("[", names(model_df[j]), "] ","Model #", w), "model_var")
#put r2 in table
delta <- data.frame(var_aic$Delta_AICc[[w]])
colnames(delta) <- paste0("[", names(model_df[j]), "] ","Model #", w)
delta$model_var <- "dAICc"
r <- rsquared(fit1) #gives R^2 values for models. "Marginal" is the R^2 for just the fixed effects, "Conditional" is the R^2 for everything.
r <- data.frame(r[,6])
colnames(r) <- paste0("[", names(model_df[j]), "] ","Model #", w)
r$model_var <- "r^2"
r[,1] <- round(r[,1], 2)
coeff <- rbind(delta, r, coeff)
coeff_list[[paste0("coeff_", names(model_df[j]), "_", w)]] <- coeff
}
}
}
}
}
top_models <- rbind(top_models, top)
}
View(coeff_list)
# to run the loop below, this list (coeff_list) needs to be created. The numbers
# reflect the order of the top models in coeff_list, which was created earlier in ##6b.
# Change the numbers here to match the ordering in that list, but realize that this
# numbering is absolute, so the 18th element is #18, not 1977 #3.
coeff_list <- coeff_list[c(3,1,4,2,5,6, #trees_all_sub
8,7,9, #x1966
13,10,14,11,15,12, #x1977
17,21,18,19,16,20)] #x1999
View(coeff_list)
ord_lab <- c("trees_all", "x1966", "x1977", "x1999")
coeff_list1 <- list()
for(q in seq(along=ord_lab)){
coeff_list_temp <- coeff_list[grepl(ord_lab[[q]], names(coeff_list))]
coeff_list_temp <-
coeff_list_temp[
order(
match(
as.numeric(
str_extract(names(coeff_list_temp)
[grepl(ord_lab[[q]], names(coeff_list_temp))],
"[[:digit:]]$")), ord))]
coeff_list1 <- c(coeff_list1, coeff_list_temp)
}
View(coeff_list_temp)
names(coeff_list_temp)
coeff_list_temp <-
coeff_list_temp[
order(
match(
as.numeric(
str_extract(names(coeff_list_temp)
[grepl(ord_lab[[q]], names(coeff_list_temp))],
"[[:digit:]]$")), ord))]
coeff_list_temp <-
coeff_list_temp[
order(
match(
as.numeric(
str_extract(names(coeff_list_temp)
[grepl(ord_lab[[q]], names(coeff_list_temp))],
"[[:digit:]]$"))))]
str_extract(names(coeff_list_temp)
[grepl(ord_lab[[q]], names(coeff_list_temp))],
"[[:digit:]]$")
coeff_list_temp <-
coeff_list_temp[
order((as.numeric(
str_extract(names(coeff_list_temp)
[grepl(ord_lab[[q]], names(coeff_list_temp))],
"[[:digit:]]$")
)))]
View(coeff_list_temp)
best_mod_traits <- data.frame("best_model" = NA,
"scenario" = c("all droughts", "1966", "1977", "1999")
)
best_mod_full <- c(unique(cand_full$variable), "(1|sp/tree)")
best_mod_full_year <- gsub("/tree", "", best_mod_full)
best_mod_full_year <- best_mod_full_year[!best_mod_full_year %in% c("year")]
#beginning of loop
mods <- names(model_df)
top_models <- NULL
coeff_list <- list()
for (i in seq(along=c(1:4))){
for (j in seq(along=model_df)){
#ALL YEARS
if(j == 1 & i == 1){
response <- "resist.value"
effects <- best_mod_full
#create all combinations of random / fixed effects
effects_comb <-
unlist(sapply(seq_len(length(effects)), function(i) {
apply( combn(effects,i), 2, function(x) paste(x, collapse = "+"))
}))
#pair response with effect and sub out combinations that don't include random effects
#in general, if two variables are >70% correlated, you can toss one of them without significantly affecting the results
var_comb <- expand.grid(response, effects_comb)
var_comb <- var_comb[grepl("1", var_comb$Var2), ] #only keep in fixed/random combos
var_comb$Var2 <- as.character(var_comb$Var2)
#can't have height and TWI separately when the interaction is in
for (q in seq(along=var_comb$Var2)){
cell <- var_comb$Var2[[q]]
if(grepl("\\*", cell)){
if(grepl("\\+TWI.ln", cell)){
var_comb$Var2[[q]] <- gsub("\\+TWI.ln", "", var_comb$Var2[[q]])
}
if(grepl("\\+height.ln.m", cell)){
var_comb$Var2[[q]] <- gsub("\\+height.ln.m\\+", "\\+", var_comb$Var2[[q]])
}
}
}
var_comb <- unique(var_comb[,1:2])
# formulas for all combinations. $Var1 is the response, and $Var2 is the effect
# for good stats, you should have no more total parameters than 1/10th the number of observations in your dataset
formula_vec <- sprintf("%s ~ %s", var_comb$Var1, var_comb$Var2)
lmm_all <- lapply(formula_vec, function(x){
fit1 <- lmer(x, data = model_df[[j]], REML=FALSE,
control = lmerControl(optimizer ="Nelder_Mead"))
return(fit1)
})
names(lmm_all) <- formula_vec
var_aic <- aictab(lmm_all, second.ord=TRUE, sort=TRUE) #rank based on AICc
var_aic$Modnames <- as.character(var_aic$Modnames)
best_mod_traits$best_model[[i]] <- var_aic$Modnames[[1]]
#get all mods <2 dAIC
var_aic <- var_aic[var_aic$Delta_AICc <= 2, ]
var_aic$mod_no <- rownames(var_aic)
top <- var_aic[,c(1,4)]
top$Delta_AICc <- round(top$Delta_AICc, 2)
top$scenario <- mods[[i]]
top$coef <- NA
for (z in seq(along = lmm_all)){
for (w in seq(along=1:nrow(var_aic))){
if (names(lmm_all[z]) == var_aic$Modnames[[w]]){
#run the best model alone with REML=TRUE
fit1 <- lmer(formula_vec[[z]], data = model_df[[j]], REML=TRUE,
control = lmerControl(optimizer ="Nelder_Mead"))
#get coefficients and put in table
coeff <- data.frame(coef(summary(fit1))[ , "Estimate"]) ##2
coeff[,2] <- rownames(coeff)
coeff[,1] <- round(coeff[,1], 3)
colnames(coeff) <- c(paste0("[All years] ","Model #", w), "model_var")
#put r2 in table
delta <- data.frame(var_aic$Delta_AICc[[w]])
colnames(delta) <- paste0("[All years] ","Model #", w)
delta$model_var <- "dAICc"
r <- rsquared(fit1) #gives R^2 values for models. "Marginal" is the R^2 for just the fixed effects, "Conditional" is the R^2 for everything.
r <- data.frame(r[,6])
colnames(r) <- paste0("[All years] ","Model #", w)
r$model_var <- "r^2"
r[,1] <- round(r[,1], 2)
coeff <- rbind(delta, r, coeff)
coeff_list[[paste0("coeff_", names(model_df[j]), "_", w)]] <- coeff
}
}
}
#INDIVIDUAL YEARS
} else if (j == i){
response <- "resist.value"
effects <- best_mod_full_year
#create all combinations of random / fixed effects
effects_comb <-
unlist( sapply( seq_len(length(effects)),
function(i) {
apply( combn(effects,i), 2, function(x) paste(x, collapse = "+"))
}))
var_comb <- expand.grid(response, effects_comb)
var_comb <- var_comb[grepl("1", var_comb$Var2), ] #only keep in fixed/random combos
var_comb$Var2 <- as.character(var_comb$Var2)
#can't have height and TWI separately when the interaction is in
for (q in seq(along=var_comb$Var2)){
cell <- var_comb$Var2[[q]]
if(grepl("\\*", cell)){
if(grepl("\\+TWI.ln", cell)){
var_comb$Var2[[q]] <- gsub("\\+TWI.ln", "", var_comb$Var2[[q]])
}
if(grepl("\\+height.ln.m", cell)){
var_comb$Var2[[q]] <- gsub("\\+height.ln.m\\+", "\\+", var_comb$Var2[[q]])
}
}
}
var_comb <- unique(var_comb[,1:2])
formula_vec <- sprintf("%s ~ %s", var_comb$Var1, var_comb$Var2)
lmm_all <- lapply(formula_vec, function(x){
fit1 <- lmer(x, data = model_df[[j]], REML=FALSE,
control = lmerControl(optimizer ="Nelder_Mead"))
return(fit1)
})
names(lmm_all) <- formula_vec
var_aic <- aictab(lmm_all, second.ord=TRUE, sort=TRUE) #rank based on AICc
var_aic$Modnames <- as.character(var_aic$Modnames)
best_mod_traits$best_model[[i]] <- var_aic$Modnames[[1]]
#get all mods <2 dAIC
var_aic <- var_aic[var_aic$Delta_AICc <= 2, ]
top <- var_aic[,c(1,4)]
top$Delta_AICc <- round(top$Delta_AICc, 2)
top$scenario <- mods[[i]]
top$coef <- NA
for (z in seq(along = lmm_all)){
for (w in seq(along=1:nrow(var_aic))){
if (names(lmm_all[z]) == var_aic$Modnames[[w]]){
#run the best model alone with REML=TRUE
fit1 <- lmer(formula_vec[[z]], data = model_df[[j]], REML=TRUE,
control = lmerControl(optimizer ="Nelder_Mead"))
#get coefficients and put in table
coeff <- data.frame(coef(summary(fit1))[ , "Estimate"]) ##2
coeff[,2] <- rownames(coeff)
coeff[,1] <- round(coeff[,1], 3)
colnames(coeff) <- c(paste0("[", names(model_df[j]), "] ","Model #", w), "model_var")
#put r2 in table
delta <- data.frame(var_aic$Delta_AICc[[w]])
colnames(delta) <- paste0("[", names(model_df[j]), "] ","Model #", w)
delta$model_var <- "dAICc"
r <- rsquared(fit1) #gives R^2 values for models. "Marginal" is the R^2 for just the fixed effects, "Conditional" is the R^2 for everything.
r <- data.frame(r[,6])
colnames(r) <- paste0("[", names(model_df[j]), "] ","Model #", w)
r$model_var <- "r^2"
r[,1] <- round(r[,1], 2)
coeff <- rbind(delta, r, coeff)
coeff_list[[paste0("coeff_", names(model_df[j]), "_", w)]] <- coeff
}
}
}
}
}
top_models <- rbind(top_models, top)
}
ord_lab <- c("trees_all", "x1966", "x1977", "x1999")
coeff_list1 <- list()
for(q in seq(along=ord_lab)){
coeff_list_temp <- coeff_list[grepl(ord_lab[[q]], names(coeff_list))]
coeff_list_temp <-
coeff_list_temp[
order((as.numeric(
str_extract(names(coeff_list_temp)
[grepl(ord_lab[[q]], names(coeff_list_temp))],
"[[:digit:]]$")
)))]
coeff_list1 <- c(coeff_list1, coeff_list_temp)
}
View(coeff_list1)
merge.all <- function(x, y) {
merge(x, y, all=TRUE, by="model_var")
}
coeff_table <- Reduce(merge.all, coeff_list1)
coeff_table[,2:ncol(coeff_table)] <- round(coeff_table[,2:ncol(coeff_table)], 3)
coeff_new <- as.data.frame(t(coeff_table[,-1]))
colnames(coeff_new) <- coeff_table$model_var
# coeff_new$year1966 <- ifelse(!is.na(coeff_new$year1977), 0, NA) #only applicable if "year" is a significant variable
coeff_new$codominant <- ifelse(!is.na(coeff_new$position_alldominant), 0, NA)
coeff_new$rpdiffuse <- ifelse(!is.na(coeff_new$rpring), 0, NA)
# coeff_new <- coeff_new[, c("dAICc","r^2", "(Intercept)", "height.ln.m",
#                            "position_alldominant", "codominant", "position_allintermediate","position_allsuppressed",
#                           "rpdiffuse", "rpring", "rpsemi-ring", "TWI.ln", "PLA_dry_percent", "mean_TLP_Mpa")]
coeff_new <- coeff_new[, c("dAICc","r^2", "(Intercept)", "height.ln.m",
"position_alldominant", "codominant", "position_allintermediate","position_allsuppressed",
"rpdiffuse", "rpring", "TWI.ln", "PLA_dry_percent", "mean_TLP_Mpa")]
# colnames(coeff_new) <- c("dAICc", "r^2", "Intercept","ln[H]", "D", "C", "I", "S", "diffuse", "ring", "semi-ring", "ln[TWI]", "PLA", "TLP")
colnames(coeff_new) <- c("dAICc", "r^2", "Intercept","ln[H]", "D", "C", "I", "S", "diffuse", "ring", "ln[TWI]", "PLA", "TLP")
coeff_new <- setDT(coeff_new, keep.rownames = TRUE)[]
setnames(coeff_new, old="rn", new="rank")
patterns <- c("\\[", "x", "\\]")
for(i in seq(along=patterns)){
coeff_new$rank <- gsub(patterns[[i]], "", coeff_new$rank)
}
write.csv(coeff_new, "manuscript/tables_figures/tested_traits_best_coeff.csv", row.names=FALSE)
write.csv(coeff_new, "manuscript/tables_figures/tested_traits_best_coeff.csv", row.names=FALSE)
library(ggplot2)
library(RCurl)
library(tidyr)
library(grid)
library(gridExtra)
trees_all_full <- read.csv("manuscript/tables_figures/trees_all_full.csv", stringsAsFactors = FALSE)
trees_all_full <- read.csv("manuscript/tables_figures/trees_all_sub.csv", stringsAsFactors = FALSE)
graph_traits <- colnames(trees_all_full[, 7:11])
color <- c("dark green", "blue", "gold", "purple", "magenta")
for(i in seq(along=graph_traits)){
trait <- graph_traits[[i]]
trees_all_full$trait <- trees_all_full[, trait]
p <- ggplot(trees_all_full) +
geom_point(aes(x = trait, y = height.ln.m), color = color[[i]]) +
xlab(print(trait)) +
theme_minimal()
assign(paste0(trait, "_plot"), p)
}
graph <- grid.arrange(PLA_dry_percent_plot, LMA_g_per_m2_plot, Chl_m2_per_g_plot, mean_TLP_Mpa_plot, WD_g_per_cm3_plot, nrow=2, top = textGrob(expression(bold("Hydraulic Traits by Height"))))
View(trees_all_full)
graph_traits <- colnames(trees_all_full[, 5:9])
color <- c("dark green", "blue", "gold", "purple", "magenta")
for(i in seq(along=graph_traits)){
trait <- graph_traits[[i]]
trees_all_full$trait <- trees_all_full[, trait]
p <- ggplot(trees_all_full) +
geom_point(aes(x = trait, y = height.ln.m), color = color[[i]]) +
xlab(print(trait)) +
theme_minimal()
assign(paste0(trait, "_plot"), p)
}
graph <- grid.arrange(PLA_dry_percent_plot, LMA_g_per_m2_plot, Chl_m2_per_g_plot, mean_TLP_Mpa_plot, WD_g_per_cm3_plot, nrow=2, top = textGrob(expression(bold("Hydraulic Traits by Height"))))
WD_g_per_cm3_plot
PLA_dry_percent_plot
?gather
graph_traits <- graph_traits %>%
gather("PLA_dry_percent", "LMA_g_per_m2", "Chl_m2_per_g", "mean_TLP_Mpa", "WD_g_per_cm3", key = "trait", value = measure)
data_2018 <- read.csv(text=getURL("https://raw.githubusercontent.com/SCBI-ForestGEO/SCBI-ForestGEO-Data/master/tree_main_census/data/scbi.stem3.csv"), stringsAsFactors=FALSE)
data_2018 <- read.csv(text=getURL("https://raw.githubusercontent.com/SCBI-ForestGEO/SCBI-ForestGEO-Data/master/tree_main_census/data/census-csv-files/scbi.stem3.csv"), stringsAsFactors=FALSE)
data_live <- data_2018[data_2018$Tree_Status == "Live", ]
data_2018 <- read.csv(text=getURL("https://raw.githubusercontent.com/SCBI-ForestGEO/SCBI-ForestGEO-Data/master/tree_main_census/data/census-csv-files/scbi.stem3.csv"), stringsAsFactors=FALSE)
View(data_2018)
data_live <- data_2018[data_2018$Tree_Status == "A", ]
data_live <- data_2018[data_2018$status == "A", ]
data_live <- data_2018[data_2018$status == "A", ]
cru1901 <- read.csv(text=getURL("https://raw.githubusercontent.com/SCBI-ForestGEO/climate_sensitivity_cores/master/results/canopy_vs_subcanopy/1901_2009/tables/monthly_correlation/correlation_with_CRU_SCBI_1901_2016_climate_data.csv"), stringsAsFactors = FALSE)
library(ggplot2)
library(ggpubr)
#subset out caco, cato, and frni because they don't have pair of canopy and subcanopy
cru1901 <- cru1901[!(cru1901$Species %in% c("CACO_subcanopy", "CATO_subcanopy", "FRNI_subcanopy")), ]
cru1901_loop <- cru1901
#create separate identifier
cru1901_loop$position <- ifelse(grepl("subcanopy", cru1901$Species), "subcanopy", "canopy")
cru1901_loop$Species <- gsub("_[[:alpha:]]+$", "", cru1901$Species)
##########################################################################################
#2. box plots ####
cru1901_loop$variable <- as.character(cru1901_loop$variable)
clim <- unique(cru1901_loop$variable)
species <- unique(cru1901_loop$Species)
months <- c("curr.may", "curr.jun", "curr.jul", "curr.aug")
#creates a lattice graph showing box plot of variables grouped by species
ggplot(data = cru1901) +
aes(x = Species, y = coef, fill = variable) +
geom_boxplot() +
labs(title = "Correlation by species and variable",
y = "Correlation") +
facet_wrap( ~ Species, scales="free", nrow=4) +
theme_minimal()
cru1901_loop$Species <- as.factor(cru1901_loop$Species)
#this piece of code puts the graphs in date order
cru1901_loop <- within(cru1901_loop, month <- factor(month, levels=cru1901_loop$month[1:17]))
with(cru1901_loop, levels(month))
for (j in seq(along=clim)){
cru1901_sub <- cru1901_loop[cru1901_loop$variable %in% clim[[j]], ]
cru1901_sub <- group_by(cru1901_sub, month)
q <- ggplot(data = cru1901_sub) +
geom_boxplot(aes(x = position, y = coef, fill = position)) +
labs(title = paste0("Canopy vs subcanopy: ", clim[[j]]),
y = "Correlation") +
stat_compare_means(aes(x=position, y=coef), method="t.test", label.x.npc = 0, label.y.npc = 0.97) +
facet_wrap(~ month, scales="free", nrow=4) +
theme_minimal()
print(q)
}
q
q
