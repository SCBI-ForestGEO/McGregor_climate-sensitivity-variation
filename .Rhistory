#create all combinations of random / fixed effects
effects_comb <-
unlist( sapply( seq_len(length(effects)),
function(i) {
apply( combn(effects,i), 2, function(x) paste(x, collapse = "+"))
}))
#=make table
var_comb <- expand.grid(response, effects_comb)
var_comb <- var_comb[grepl("1", var_comb$Var2), ] #only keep in fixed+random combos
}
#formulas for all combinations.
formula_vec <- sprintf("%s ~ %s", var_comb$Var1, var_comb$Var2)
# create list of model outputs
lmm_all <- lapply(formula_vec, function(x){
fit1 <- lmer(x, data = model_df[[i]], REML=FALSE,
control = lmerControl(optimizer ="Nelder_Mead"))
return(fit1)
})
names(lmm_all) <- formula_vec
var_aic <- aictab(lmm_all, second.ord=TRUE, sort=TRUE) #rank based on AICc
r <- rsquared(lmm_all) #gives R^2 values for models. "Marginal" is the R^2 for just the fixed effects, "Conditional" is the R^2 for everything.
#fill in table
if(i == 1){
var_aic_sub <- var_aic[var_aic$Modnames == summary_mod_vars_all[[h]], ]
var_aic_null <- var_aic[var_aic$Modnames == summary_mod_null_all[[h]], ]
summary_models[,8][[h]] <- round(var_aic_null$Delta_AICc - var_aic_sub$Delta_AICc, 2)
var_aic_sub$Modnames <- as.character(var_aic_sub$Modnames)
for (z in seq(along = lmm_all)){
if (z == rownames(var_aic_sub)){
coeff <- data.frame(coef(summary(lmm_all[[z]]))[ , "Estimate"])
coeff[,2] <- rownames(coeff)
colnames(coeff) <- c("value", "model_var")
if (h == 3){
coeff$model_var <- gsub("subcanopy", "", coeff$model_var)
} else if (h == 4){
coeff$model_var <- gsub("subcanopy", "", coeff$model_var)
coeff$model_var <- gsub("height", "ht_nat_log", coeff$model_var)
} else if (h %in% 5:10){
coeff$model_var <- gsub("height", "ht_nat_log", coeff$model_var)
} else if (h == 11){
coeff$model_var <- gsub("ring", "", coeff$model_var)
coeff$model_var <- gsub("height", "ht_nat_log", coeff$model_var)
}
for (y in seq(along = coeff$model_var)){
same <- coeff$model_var[[y]]
if(grepl(same, summary_mod_vars_all[[h]])){
coeff_sub <- coeff[coeff$model_var == same, ]
}
summary_models[,8][[h]] <- ifelse(
(coeff_sub$value <0 & summary_models$response_predict[[h]] <0) |
(coeff_sub$value >0 & summary_models$response_predict[[h]] >0),
summary_models[,8][[h]], NA)
summary_models[,9][[h]] <- coeff_sub$value
}
View(summary_models)
View(coeff)
View(coeff_sub)
summary_models$response_predict[[h]]
coeff_sub$value
View(var_aic_sub)
summary_models <- data.frame(
"prediction" = c("1.0", "1.1", "1.2a", "1.2b", "1.2c1, 1.3a1", "1.2c2", "1.3b1", "1.3a2", "1.3b2", "2.1", "2.2"),
"model_vars_all_years" =
c("resist.value ~ dbh_ln+year+(1|sp/tree)",
"resist.value ~ height_ln+year+(1|sp/tree)",
"resist.value ~ position+year+(1|sp/tree)",
"resist.value ~ position+height_ln+year+(1|sp/tree)",
"resist.value ~ elev_m+height_ln+year+(1|sp/tree)",
"resist.value ~ elev_m*height_ln+height_ln+year+(1|sp/tree)",
"resist.value ~ distance_ln+height_ln+year+(1|sp/tree)",
"resist.value ~ distance_ln*height_ln+height_ln+year+(1|sp/tree)",
"resist.value ~ tlp+height_ln+year+(1|sp/tree)",
"resist.value ~ rp+height_ln+year+(1|sp/tree)"),
"null_model_all_years" = NA,
"model_vars_sep_years" = NA,
"null_model_sep_years" = NA,
"response_predict" = c(-1, -1, -1, -1, 1, 1, -1, 1, -1, -1, 1),
"response_sign" = c("-", "-", "canopy<subcanopy", "canopy<subcanopy", "+", "+", "-", "+", "-", "-", "ring>diffuse"),
"dAIC_all_years" = NA,
"coef_all_years" = NA,
"dAIC_1964.1966" = NA,
"coef_1964.1966" = NA,
"dAIC_1977" = NA,
"coef_1977" = NA,
"dAIC_1999" = NA,
"coef_1999" = NA,
"notes" = NA)
library(dplyr)
# change factor columns to character
summary_models %>% mutate_if(is.factor, as.character) -> summary_models
# fill in other columns
summary_models[c(1:3), 3] <- "resist.value ~ year+(1|sp/tree)"
summary_models[c(4:11), 3] <- "resist.value ~ height_ln+year+(1|sp/tree)"
summary_models$model_vars_sep_years <- gsub("year\\+|/tree", "", summary_models$model_vars_all_years)
summary_models$null_model_sep_years <- gsub("year\\+|/tree", "", summary_models$null_model_all_years)
#define vectors to be used in loop
summary_mod_vars_all <- summary_models$model_vars_all_years
summary_mod_vars_sep <- summary_models$model_vars_sep_years
summary_mod_null_all <- summary_models$null_model_all_years
summary_mod_null_sep <- summary_models$null_model_sep_years
##this loop goes through each mix of effects from each prediction (nrow(summary_models)), and runs those models for each of the datasets (all years and the three individual ones). For each iteration (44 total), it calculates dAIC (AIC of model with variable defined in model_vars columns minus the AIC of the null model).
for (i in seq_along(model_df)){
for (h in seq(along=summary_mod_vars_all)){
if (i==1){
#structure of creating the model strings come from 6a above.
response <- gsub(" ~.*", "", summary_mod_vars_all[[h]])
effects <- unlist(strsplit(summary_mod_vars_all[[h]], "\\+|~ "))[-1]
#create all combinations of random / fixed effects
effects_comb <-
unlist( sapply( seq_len(length(effects)),
function(i) {
apply( combn(effects,i), 2, function(x) paste(x, collapse = "+"))
}))
#make table
var_comb <- expand.grid(response, effects_comb)
var_comb <- var_comb[grepl("1", var_comb$Var2), ] #only keep in fixed/random combos
var_comb <- var_comb[grepl("year", var_comb$Var2), ] #keep year in for drought sake
} else {
#define response and effects
response <- gsub(" ~.*", "", summary_mod_vars_sep[[h]])
effects <- unlist(strsplit(summary_mod_vars_sep[[h]], "\\+|~ "))[-1]
# all fixed effects <- c("position", "tlp", "rp", "elev_m", "dbh_ln", "height_ln")
#create all combinations of random / fixed effects
effects_comb <-
unlist( sapply( seq_len(length(effects)),
function(i) {
apply( combn(effects,i), 2, function(x) paste(x, collapse = "+"))
}))
#=make table
var_comb <- expand.grid(response, effects_comb)
var_comb <- var_comb[grepl("1", var_comb$Var2), ] #only keep in fixed+random combos
}
#formulas for all combinations.
formula_vec <- sprintf("%s ~ %s", var_comb$Var1, var_comb$Var2)
# create list of model outputs
lmm_all <- lapply(formula_vec, function(x){
fit1 <- lmer(x, data = model_df[[i]], REML=FALSE,
control = lmerControl(optimizer ="Nelder_Mead"))
return(fit1)
})
names(lmm_all) <- formula_vec
var_aic <- aictab(lmm_all, second.ord=TRUE, sort=TRUE) #rank based on AICc
r <- rsquared(lmm_all) #gives R^2 values for models. "Marginal" is the R^2 for just the fixed effects, "Conditional" is the R^2 for everything.
#fill in table
if(i == 1){
#isolate the AIC values of the target (sub) and null models, then math
var_aic_sub <- var_aic[var_aic$Modnames == summary_mod_vars_all[[h]], ]
var_aic_null <- var_aic[var_aic$Modnames == summary_mod_null_all[[h]], ]
summary_models[,8][[h]] <- round(var_aic_null$Delta_AICc - var_aic_sub$Delta_AICc, 2)
var_aic_sub$Modnames <- as.character(var_aic_sub$Modnames)
#this loop says for the models run for this iteration of h, take the model output represented by the target model (1). Get the coefficients and put in df (2). Rename variables such that you only pull what you need (3) and extract the coefficient for the variable you want (4).
for (z in seq(along = lmm_all)){
if (z == rownames(var_aic_sub)){ ##1
coeff <- data.frame(coef(summary(lmm_all[[z]]))[ , "Estimate"]) ##2
coeff[,2] <- rownames(coeff)
colnames(coeff) <- c("value", "model_var")
if (h == 3){ ##3
coeff$model_var <- gsub("subcanopy", "", coeff$model_var)
} else if (h == 4){
coeff$model_var <- gsub("subcanopy", "", coeff$model_var)
coeff$model_var <- gsub("height", "ht_nat_log", coeff$model_var)
} else if (h %in% 5:10){
coeff$model_var <- gsub("height", "ht_nat_log", coeff$model_var)
} else if (h == 11){
coeff$model_var <- gsub("ring", "", coeff$model_var)
coeff$model_var <- gsub("height", "ht_nat_log", coeff$model_var)
}
for (y in seq(along = coeff$model_var)){ ##4
same <- coeff$model_var[[y]]
if(grepl(same, summary_mod_vars_all[[h]])){
coeff_sub <- coeff[coeff$model_var == same, ]
}
#update the coefficient value
summary_models[,9][[h]] <- coeff_sub$value
#update the table. If the sign conventions of the coefficient and the predicted response do not match, assign NA.
summary_models[,8][[h]] <- ifelse(
(coeff_sub$value <0 & summary_models$response_predict[[h]] <0) |
(coeff_sub$value >0 & summary_models$response_predict[[h]] >0),
summary_models[,8][[h]], NA)
}
else if (i == 2) {
#isolate the AIC values of the target (sub) and null models, then math
var_aic_sub <- var_aic[var_aic$Modnames == summary_mod_vars_sep[[h]], ]
var_aic_null <- var_aic[var_aic$Modnames == summary_mod_null_sep[[h]], ]
summary_models[,10][[h]] <- round(var_aic_null$Delta_AICc - var_aic_sub$Delta_AICc, 2)
var_aic_sub$Modnames <- as.character(var_aic_sub$Modnames)
#this loop says for the models run for this iteration of h, take the model output represented by the target model (1). Get the coefficients and put in df (2). Rename variables such that you only pull what you need (3) and extract the coefficient for the variable you want (4).
for (z in seq(along = lmm_all)){
if (z == rownames(var_aic_sub)){ ##1
coeff <- data.frame(coef(summary(lmm_all[[z]]))[ , "Estimate"]) ##2
coeff[,2] <- rownames(coeff)
colnames(coeff) <- c("value", "model_var")
if (h == 3){ ##3
coeff$model_var <- gsub("subcanopy", "", coeff$model_var)
} else if (h == 4){
coeff$model_var <- gsub("subcanopy", "", coeff$model_var)
coeff$model_var <- gsub("height", "ht_nat_log", coeff$model_var)
} else if (h %in% 5:10){
coeff$model_var <- gsub("height", "ht_nat_log", coeff$model_var)
} else if (h == 11){
coeff$model_var <- gsub("ring", "", coeff$model_var)
coeff$model_var <- gsub("height", "ht_nat_log", coeff$model_var)
}
for (y in seq(along = coeff$model_var)){ ##4
same <- coeff$model_var[[y]]
if(grepl(same, summary_mod_vars_all[[h]])){
coeff_sub <- coeff[coeff$model_var == same, ]
}
#update the coefficient value
summary_models[,11][[h]] <- coeff_sub$value
#update the table. If the sign conventions of the coefficient and the predicted response do not match, assign NA.
summary_models[,10][[h]] <- ifelse(
(coeff_sub$value <0 & summary_models$response_predict[[h]] <0) |
(coeff_sub$value >0 & summary_models$response_predict[[h]] >0),
summary_models[,10][[h]], NA)
}
else if (i == 3){
#isolate the AIC values of the target (sub) and null models, then math
var_aic_sub <- var_aic[var_aic$Modnames == summary_mod_vars_sep[[h]], ]
var_aic_null <- var_aic[var_aic$Modnames == summary_mod_null_sep[[h]], ]
summary_models[,12][[h]] <- round(var_aic_null$Delta_AICc - var_aic_sub$Delta_AICc, 2)
var_aic_sub$Modnames <- as.character(var_aic_sub$Modnames)
#this loop says for the models run for this iteration of h, take the model output represented by the target model (1). Get the coefficients and put in df (2). Rename variables such that you only pull what you need (3) and extract the coefficient for the variable you want (4).
for (z in seq(along = lmm_all)){
if (z == rownames(var_aic_sub)){ ##1
coeff <- data.frame(coef(summary(lmm_all[[z]]))[ , "Estimate"]) ##2
coeff[,2] <- rownames(coeff)
colnames(coeff) <- c("value", "model_var")
if (h == 3){ ##3
coeff$model_var <- gsub("subcanopy", "", coeff$model_var)
} else if (h == 4){
coeff$model_var <- gsub("subcanopy", "", coeff$model_var)
coeff$model_var <- gsub("height", "ht_nat_log", coeff$model_var)
} else if (h %in% 5:10){
coeff$model_var <- gsub("height", "ht_nat_log", coeff$model_var)
} else if (h == 11){
coeff$model_var <- gsub("ring", "", coeff$model_var)
coeff$model_var <- gsub("height", "ht_nat_log", coeff$model_var)
}
for (y in seq(along = coeff$model_var)){ ##4
same <- coeff$model_var[[y]]
if(grepl(same, summary_mod_vars_all[[h]])){
coeff_sub <- coeff[coeff$model_var == same, ]
}
#update the coefficient value
summary_models[,13][[h]] <- coeff_sub$value
#update the table. If the sign conventions of the coefficient and the predicted response do not match, assign NA.
summary_models[,12][[h]] <- ifelse(
(coeff_sub$value <0 & summary_models$response_predict[[h]] <0) |
(coeff_sub$value >0 & summary_models$response_predict[[h]] >0),
summary_models[,12][[h]], NA)
}
else if (i == 4){
#isolate the AIC values of the target (sub) and null models, then math
var_aic_sub <- var_aic[var_aic$Modnames == summary_mod_vars_sep[[h]], ]
var_aic_null <- var_aic[var_aic$Modnames == summary_mod_null_sep[[h]], ]
summary_models[,14][[h]] <- round(var_aic_null$Delta_AICc - var_aic_sub$Delta_AICc, 2)
var_aic_sub$Modnames <- as.character(var_aic_sub$Modnames)
#this loop says for the models run for this iteration of h, take the model output represented by the target model (1). Get the coefficients and put in df (2). Rename variables such that you only pull what you need (3) and extract the coefficient for the variable you want (4).
for (z in seq(along = lmm_all)){
if (z == rownames(var_aic_sub)){ ##1
coeff <- data.frame(coef(summary(lmm_all[[z]]))[ , "Estimate"]) ##2
coeff[,2] <- rownames(coeff)
colnames(coeff) <- c("value", "model_var")
if (h == 3){ ##3
coeff$model_var <- gsub("subcanopy", "", coeff$model_var)
} else if (h == 4){
coeff$model_var <- gsub("subcanopy", "", coeff$model_var)
coeff$model_var <- gsub("height", "ht_nat_log", coeff$model_var)
} else if (h %in% 5:10){
coeff$model_var <- gsub("height", "ht_nat_log", coeff$model_var)
} else if (h == 11){
coeff$model_var <- gsub("ring", "", coeff$model_var)
coeff$model_var <- gsub("height", "ht_nat_log", coeff$model_var)
}
for (y in seq(along = coeff$model_var)){ ##4
same <- coeff$model_var[[y]]
if(grepl(same, summary_mod_vars_all[[h]])){
coeff_sub <- coeff[coeff$model_var == same, ]
}
#update the coefficient value
summary_models[,15][[h]] <- coeff_sub$value
#update the table. If the sign conventions of the coefficient and the predicted response do not match, assign NA.
summary_models[,14][[h]] <- ifelse(
(coeff_sub$value <0 & summary_models$response_predict[[h]] <0) |
(coeff_sub$value >0 & summary_models$response_predict[[h]] >0),
summary_models[,14][[h]], NA)
}
View(summary_models)
#csv has a 1 in the title to make sure any notes in current file are not overwritten
write.csv(summary_models, "manuscript/results1.csv", row.names=FALSE)
##6ai. test predictions for paper ####
## create table to store results
summary_models <- data.frame(
"prediction" = c("1.0", "1.1", "1.2a", "1.2b", "1.2c1, 1.3a1", "1.2c2", "1.3b1", "1.3a2", "1.3b2", "2.1", "2.2"),
"model_vars_all_years" =
c("resist.value ~ dbh_ln+year+(1|sp/tree)",
"resist.value ~ height_ln+year+(1|sp/tree)",
"resist.value ~ position+year+(1|sp/tree)",
"resist.value ~ position+height_ln+year+(1|sp/tree)",
"resist.value ~ elev_m+height_ln+year+(1|sp/tree)",
"resist.value ~ elev_m*height_ln+height_ln+year+(1|sp/tree)",
"resist.value ~ distance_ln+height_ln+year+(1|sp/tree)",
"resist.value ~ distance_ln*height_ln+height_ln+year+(1|sp/tree)",
"resist.value ~ tlp+height_ln+year+(1|sp/tree)",
"resist.value ~ rp+height_ln+year+(1|sp/tree)"),
"null_model_all_years" = NA,
"model_vars_sep_years" = NA,
"null_model_sep_years" = NA,
"response_predict" = c(-1, -1, -1, -1, 1, 1, -1, 1, -1, -1, 1),
"response_sign" = c("-", "-", "canopy<subcanopy", "canopy<subcanopy", "+", "+", "-", "+", "-", "-", "ring>diffuse"),
"dAIC_all_years" = NA,
"coef_all_years" = NA,
"dAIC_1964.1966" = NA,
"coef_1964.1966" = NA,
"dAIC_1977" = NA,
"coef_1977" = NA,
"dAIC_1999" = NA,
"coef_1999" = NA,
"notes" = "")
View(summary_models)
##this loop goes through each mix of effects from each prediction (nrow(summary_models)), and runs those models for each of the datasets (all years and the three individual ones). For each iteration (44 total), it calculates dAIC (AIC of model with variable defined in model_vars columns minus the AIC of the null model) and the coefficients before putting them in the table created above.
for (i in seq_along(model_df)){
for (h in seq(along=summary_mod_vars_all)){
if (i==1){
#structure of creating the model strings come from 6a above.
response <- gsub(" ~.*", "", summary_mod_vars_all[[h]])
effects <- unlist(strsplit(summary_mod_vars_all[[h]], "\\+|~ "))[-1]
#create all combinations of random / fixed effects
effects_comb <-
unlist( sapply( seq_len(length(effects)),
function(i) {
apply( combn(effects,i), 2, function(x) paste(x, collapse = "+"))
}))
#make table
var_comb <- expand.grid(response, effects_comb)
var_comb <- var_comb[grepl("1", var_comb$Var2), ] #only keep in fixed/random combos
var_comb <- var_comb[grepl("year", var_comb$Var2), ] #keep year in for drought sake
}
else {
#define response and effects
response <- gsub(" ~.*", "", summary_mod_vars_sep[[h]])
effects <- unlist(strsplit(summary_mod_vars_sep[[h]], "\\+|~ "))[-1]
# all fixed effects <- c("position", "tlp", "rp", "elev_m", "dbh_ln", "height_ln")
#create all combinations of random / fixed effects
effects_comb <-
unlist( sapply( seq_len(length(effects)),
function(i) {
apply( combn(effects,i), 2, function(x) paste(x, collapse = "+"))
}))
#=make table
var_comb <- expand.grid(response, effects_comb)
var_comb <- var_comb[grepl("1", var_comb$Var2), ] #only keep in fixed+random combos
}
#formulas for all combinations.
formula_vec <- sprintf("%s ~ %s", var_comb$Var1, var_comb$Var2)
# create list of model outputs
lmm_all <- lapply(formula_vec, function(x){
fit1 <- lmer(x, data = model_df[[i]], REML=FALSE,
control = lmerControl(optimizer ="Nelder_Mead"))
return(fit1)
})
names(lmm_all) <- formula_vec
var_aic <- aictab(lmm_all, second.ord=TRUE, sort=TRUE) #rank based on AICc
r <- rsquared(lmm_all) #gives R^2 values for models. "Marginal" is the R^2 for just the fixed effects, "Conditional" is the R^2 for everything.
#fill in table
if(i == 1){
#isolate the AIC values of the target (sub) and null models, then math
var_aic_sub <- var_aic[var_aic$Modnames == summary_mod_vars_all[[h]], ]
var_aic_null <- var_aic[var_aic$Modnames == summary_mod_null_all[[h]], ]
summary_models[,8][[h]] <- round(var_aic_null$Delta_AICc - var_aic_sub$Delta_AICc, 2)
var_aic_sub$Modnames <- as.character(var_aic_sub$Modnames)
#this loop says for the models run for this iteration of h, take the model output represented by the target model (1). Get the coefficients and put in df (2). Rename variables such that you only pull what you need (3) and extract the coefficient for the variable you want (4).
for (z in seq(along = lmm_all)){
if (z == rownames(var_aic_sub)){ ##1
coeff <- data.frame(coef(summary(lmm_all[[z]]))[ , "Estimate"]) ##2
coeff[,2] <- rownames(coeff)
colnames(coeff) <- c("value", "model_var")
if (h == 3){ ##3
coeff$model_var <- gsub("subcanopy", "", coeff$model_var)
} else if (h == 4){
coeff$model_var <- gsub("subcanopy", "", coeff$model_var)
coeff$model_var <- gsub("height", "ht_nat_log", coeff$model_var)
} else if (h %in% 5:10){
coeff$model_var <- gsub("height", "ht_nat_log", coeff$model_var)
} else if (h == 11){
coeff$model_var <- gsub("ring", "", coeff$model_var)
coeff$model_var <- gsub("height", "ht_nat_log", coeff$model_var)
}
for (y in seq(along = coeff$model_var)){ ##4
same <- coeff$model_var[[y]]
if(grepl(same, summary_mod_vars_all[[h]])){
coeff_sub <- coeff[coeff$model_var == same, ]
}
#update the coefficient value
summary_models[,9][[h]] <- coeff_sub$value
#update the table. If the sign conventions of the coefficient and the predicted response do not match, assign NA.
# summary_models[,8][[h]] <- ifelse(
#   (coeff_sub$value <0 & summary_models$response_predict[[h]] <0) |
#     (coeff_sub$value >0 & summary_models$response_predict[[h]] >0),
#                                   summary_models[,8][[h]], NA)
#
}
else if (i == 2) {
#isolate the AIC values of the target (sub) and null models, then math
var_aic_sub <- var_aic[var_aic$Modnames == summary_mod_vars_sep[[h]], ]
var_aic_null <- var_aic[var_aic$Modnames == summary_mod_null_sep[[h]], ]
summary_models[,10][[h]] <- round(var_aic_null$Delta_AICc - var_aic_sub$Delta_AICc, 2)
var_aic_sub$Modnames <- as.character(var_aic_sub$Modnames)
#this loop says for the models run for this iteration of h, take the model output represented by the target model (1). Get the coefficients and put in df (2). Rename variables such that you only pull what you need (3) and extract the coefficient for the variable you want (4).
for (z in seq(along = lmm_all)){
if (z == rownames(var_aic_sub)){ ##1
coeff <- data.frame(coef(summary(lmm_all[[z]]))[ , "Estimate"]) ##2
coeff[,2] <- rownames(coeff)
colnames(coeff) <- c("value", "model_var")
if (h == 3){ ##3
coeff$model_var <- gsub("subcanopy", "", coeff$model_var)
} else if (h == 4){
coeff$model_var <- gsub("subcanopy", "", coeff$model_var)
coeff$model_var <- gsub("height", "ht_nat_log", coeff$model_var)
} else if (h %in% 5:10){
coeff$model_var <- gsub("height", "ht_nat_log", coeff$model_var)
} else if (h == 11){
coeff$model_var <- gsub("ring", "", coeff$model_var)
coeff$model_var <- gsub("height", "ht_nat_log", coeff$model_var)
}
for (y in seq(along = coeff$model_var)){ ##4
same <- coeff$model_var[[y]]
if(grepl(same, summary_mod_vars_all[[h]])){
coeff_sub <- coeff[coeff$model_var == same, ]
}
#update the coefficient value
summary_models[,11][[h]] <- coeff_sub$value
#update the table. If the sign conventions of the coefficient and the predicted response do not match, assign NA.
# summary_models[,10][[h]] <- ifelse(
#   (coeff_sub$value <0 & summary_models$response_predict[[h]] <0) |
#     (coeff_sub$value >0 & summary_models$response_predict[[h]] >0),
#   summary_models[,10][[h]], NA)
}
else if (i == 3){
#isolate the AIC values of the target (sub) and null models, then math
var_aic_sub <- var_aic[var_aic$Modnames == summary_mod_vars_sep[[h]], ]
var_aic_null <- var_aic[var_aic$Modnames == summary_mod_null_sep[[h]], ]
summary_models[,12][[h]] <- round(var_aic_null$Delta_AICc - var_aic_sub$Delta_AICc, 2)
var_aic_sub$Modnames <- as.character(var_aic_sub$Modnames)
#this loop says for the models run for this iteration of h, take the model output represented by the target model (1). Get the coefficients and put in df (2). Rename variables such that you only pull what you need (3) and extract the coefficient for the variable you want (4).
for (z in seq(along = lmm_all)){
if (z == rownames(var_aic_sub)){ ##1
coeff <- data.frame(coef(summary(lmm_all[[z]]))[ , "Estimate"]) ##2
coeff[,2] <- rownames(coeff)
colnames(coeff) <- c("value", "model_var")
if (h == 3){ ##3
coeff$model_var <- gsub("subcanopy", "", coeff$model_var)
} else if (h == 4){
coeff$model_var <- gsub("subcanopy", "", coeff$model_var)
coeff$model_var <- gsub("height", "ht_nat_log", coeff$model_var)
} else if (h %in% 5:10){
coeff$model_var <- gsub("height", "ht_nat_log", coeff$model_var)
} else if (h == 11){
coeff$model_var <- gsub("ring", "", coeff$model_var)
coeff$model_var <- gsub("height", "ht_nat_log", coeff$model_var)
}
for (y in seq(along = coeff$model_var)){ ##4
same <- coeff$model_var[[y]]
if(grepl(same, summary_mod_vars_all[[h]])){
coeff_sub <- coeff[coeff$model_var == same, ]
}
#update the coefficient value
summary_models[,13][[h]] <- coeff_sub$value
#update the table. If the sign conventions of the coefficient and the predicted response do not match, assign NA.
# summary_models[,12][[h]] <- ifelse(
#   (coeff_sub$value <0 & summary_models$response_predict[[h]] <0) |
#     (coeff_sub$value >0 & summary_models$response_predict[[h]] >0),
#   summary_models[,12][[h]], NA)
}
else if (i == 4){
#isolate the AIC values of the target (sub) and null models, then math
var_aic_sub <- var_aic[var_aic$Modnames == summary_mod_vars_sep[[h]], ]
var_aic_null <- var_aic[var_aic$Modnames == summary_mod_null_sep[[h]], ]
summary_models[,14][[h]] <- round(var_aic_null$Delta_AICc - var_aic_sub$Delta_AICc, 2)
var_aic_sub$Modnames <- as.character(var_aic_sub$Modnames)
#this loop says for the models run for this iteration of h, take the model output represented by the target model (1). Get the coefficients and put in df (2). Rename variables such that you only pull what you need (3) and extract the coefficient for the variable you want (4).
for (z in seq(along = lmm_all)){
if (z == rownames(var_aic_sub)){ ##1
coeff <- data.frame(coef(summary(lmm_all[[z]]))[ , "Estimate"]) ##2
coeff[,2] <- rownames(coeff)
colnames(coeff) <- c("value", "model_var")
if (h == 3){ ##3
coeff$model_var <- gsub("subcanopy", "", coeff$model_var)
} else if (h == 4){
coeff$model_var <- gsub("subcanopy", "", coeff$model_var)
coeff$model_var <- gsub("height", "ht_nat_log", coeff$model_var)
} else if (h %in% 5:10){
coeff$model_var <- gsub("height", "ht_nat_log", coeff$model_var)
} else if (h == 11){
coeff$model_var <- gsub("ring", "", coeff$model_var)
coeff$model_var <- gsub("height", "ht_nat_log", coeff$model_var)
}
for (y in seq(along = coeff$model_var)){ ##4
same <- coeff$model_var[[y]]
if(grepl(same, summary_mod_vars_all[[h]])){
coeff_sub <- coeff[coeff$model_var == same, ]
}
#update the coefficient value
summary_models[,15][[h]] <- coeff_sub$value
#update the table. If the sign conventions of the coefficient and the predicted response do not match, assign NA.
# summary_models[,14][[h]] <- ifelse(
#   (coeff_sub$value <0 & summary_models$response_predict[[h]] <0) |
#     (coeff_sub$value >0 & summary_models$response_predict[[h]] >0),
#   summary_models[,14][[h]], NA)
}
View(summary_models)
