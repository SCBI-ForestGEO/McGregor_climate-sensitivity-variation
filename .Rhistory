# if (h!=12){
#   summary_models[,8][[h]] <- ifelse(
#     (coeff_sub$value <0 & summary_models$response_predict[[h]] <0) |
#       (coeff_sub$value >0 & summary_models$response_predict[[h]] >0),
#     summary_models[,8][[h]], NA)
# }
if(h==12){
coeff <- coeff[-1,]
coeff_max <- coeff[coeff$value == max(coeff$value), ]
summary_models[,21][[h]] <- coeff_max$model_var
}
else if (i == 2) {
#isolate the AIC values of the target (sub) and null models, then math
var_aic_sub <- var_aic[var_aic$Modnames == summary_mod_vars_sep[[h]], ]
var_aic_null <- var_aic[var_aic$Modnames == summary_mod_null_sep[[h]], ]
summary_models[,11][[h]] <- round(var_aic_null$Delta_AICc - var_aic_sub$Delta_AICc, 2)
var_aic_sub$Modnames <- as.character(var_aic_sub$Modnames)
#this loop says for the models run for this iteration of h, take the model output represented by the target model (1). Get the coefficients and put in df (2). Rename variables such that you only pull what you need (3) and extract the coefficient for the variable you want (4).
for (z in seq(along = lmm_all)){
if (z == rownames(var_aic_sub)){ ##1
coeff <- data.frame(coef(summary(lmm_all[[z]]))[ , "Estimate"]) ##2
coeff[,2] <- rownames(coeff)
colnames(coeff) <- c("value", "model_var")
if (h == 3){ ##3
coeff$model_var <- gsub("subcanopy", "", coeff$model_var)
} else if (h == 4){
coeff$model_var <- gsub("subcanopy", "", coeff$model_var)
coeff$model_var <- gsub("height", "ht_nat_log", coeff$model_var)
} else if (h %in% 5:10){
coeff$model_var <- gsub("height", "ht_nat_log", coeff$model_var)
} else if (h == 11){
coeff$model_var <- gsub("ring", "", coeff$model_var)
coeff$model_var <- gsub("height", "ht_nat_log", coeff$model_var)
} else if (h == 12){
coeff$model_var <- gsub("subcanopy", "", coeff$model_var)
coeff$model_var <- gsub("ring", "", coeff$model_var)
coeff$model_var <- gsub("height", "ht_nat_log", coeff$model_var)
full_mod_1966 <- var_aic[!duplicated(var_aic$Delta_AICc), ]
full_mod_1966 <- full_mod_1966[1:10, c(1,4)]
full_mod_1966[11,] <- var_aic_sub[,c(1,4)]
colnames(full_mod_1966) <- c("Modnames_1966", "dAIC_1966")
}
for (y in seq(along = coeff$model_var)){ ##4
same <- coeff$model_var[[y]]
if(grepl(same, summary_mod_vars_all[[h]])){
coeff_sub <- coeff[coeff$model_var == same, ]
}
#update the coefficient value
summary_models[,12][[h]] <- ifelse(coeff_sub$value<0, -1, 1)
summary_models[,13][[h]] <- ifelse(h == 12, NA, coeff_sub$value)
#update the table. If the sign conventions of the coefficient and the predicted response do not match, assign NA.
# if (h!=12){
#   summary_models[,10][[h]] <- ifelse(
#     (coeff_sub$value <0 & summary_models$response_predict[[h]] <0) |
#       (coeff_sub$value >0 & summary_models$response_predict[[h]] >0),
#     summary_models[,10][[h]], NA)
# }
if(h==12){
coeff <- coeff[-1,]
coeff_max <- coeff[coeff$value == max(coeff$value), ]
summary_models[,22][[h]] <- coeff_max$model_var
}
else if (i == 3){
#isolate the AIC values of the target (sub) and null models, then math
var_aic_sub <- var_aic[var_aic$Modnames == summary_mod_vars_sep[[h]], ]
var_aic_null <- var_aic[var_aic$Modnames == summary_mod_null_sep[[h]], ]
summary_models[,14][[h]] <- round(var_aic_null$Delta_AICc - var_aic_sub$Delta_AICc, 2)
var_aic_sub$Modnames <- as.character(var_aic_sub$Modnames)
#this loop says for the models run for this iteration of h, take the model output represented by the target model (1). Get the coefficients and put in df (2). Rename variables such that you only pull what you need (3) and extract the coefficient for the variable you want (4).
for (z in seq(along = lmm_all)){
if (z == rownames(var_aic_sub)){ ##1
coeff <- data.frame(coef(summary(lmm_all[[z]]))[ , "Estimate"]) ##2
coeff[,2] <- rownames(coeff)
colnames(coeff) <- c("value", "model_var")
if (h == 3){ ##3
coeff$model_var <- gsub("subcanopy", "", coeff$model_var)
} else if (h == 4){
coeff$model_var <- gsub("subcanopy", "", coeff$model_var)
coeff$model_var <- gsub("height", "ht_nat_log", coeff$model_var)
} else if (h %in% 5:10){
coeff$model_var <- gsub("height", "ht_nat_log", coeff$model_var)
} else if (h == 11){
coeff$model_var <- gsub("ring", "", coeff$model_var)
coeff$model_var <- gsub("height", "ht_nat_log", coeff$model_var)
} else if (h == 12){
coeff$model_var <- gsub("subcanopy", "", coeff$model_var)
coeff$model_var <- gsub("ring", "", coeff$model_var)
coeff$model_var <- gsub("height", "ht_nat_log", coeff$model_var)
full_mod_1977 <- var_aic[!duplicated(var_aic$Delta_AICc), ]
full_mod_1977 <- full_mod_1977[1:10, c(1,4)]
full_mod_1977[11,] <- var_aic_sub[,c(1,4)]
colnames(full_mod_1977) <- c("Modnames_1977", "dAIC_1977")
}
for (y in seq(along = coeff$model_var)){ ##4
same <- coeff$model_var[[y]]
if(grepl(same, summary_mod_vars_all[[h]])){
coeff_sub <- coeff[coeff$model_var == same, ]
}
#update the coefficient value
summary_models[,15][[h]] <- ifelse(coeff_sub$value<0, -1, 1)
summary_models[,16][[h]] <- ifelse(h == 12, NA, coeff_sub$value)
#update the table. If the sign conventions of the coefficient and the predicted response do not match, assign NA.
# if(h!=12){
#   summary_models[,12][[h]] <- ifelse(
#     (coeff_sub$value <0 & summary_models$response_predict[[h]] <0) |
#       (coeff_sub$value >0 & summary_models$response_predict[[h]] >0),
#     summary_models[,12][[h]], NA)
# }
if(h==12){
coeff <- coeff[-1,]
coeff_max <- coeff[coeff$value == max(coeff$value), ]
summary_models[,23][[h]] <- coeff_max$model_var
}
else if (i == 4){
#isolate the AIC values of the target (sub) and null models, then math
var_aic_sub <- var_aic[var_aic$Modnames == summary_mod_vars_sep[[h]], ]
var_aic_null <- var_aic[var_aic$Modnames == summary_mod_null_sep[[h]], ]
summary_models[,17][[h]] <- round(var_aic_null$Delta_AICc - var_aic_sub$Delta_AICc, 2)
var_aic_sub$Modnames <- as.character(var_aic_sub$Modnames)
#this loop says for the models run for this iteration of h, take the model output represented by the target model (1). Get the coefficients and put in df (2). Rename variables such that you only pull what you need (3) and extract the coefficient for the variable you want (4).
for (z in seq(along = lmm_all)){
if (z == rownames(var_aic_sub)){ ##1
coeff <- data.frame(coef(summary(lmm_all[[z]]))[ , "Estimate"]) ##2
coeff[,2] <- rownames(coeff)
colnames(coeff) <- c("value", "model_var")
if (h == 3){ ##3
coeff$model_var <- gsub("subcanopy", "", coeff$model_var)
} else if (h == 4){
coeff$model_var <- gsub("subcanopy", "", coeff$model_var)
coeff$model_var <- gsub("height", "ht_nat_log", coeff$model_var)
} else if (h %in% 5:10){
coeff$model_var <- gsub("height", "ht_nat_log", coeff$model_var)
} else if (h == 11){
coeff$model_var <- gsub("ring", "", coeff$model_var)
coeff$model_var <- gsub("height", "ht_nat_log", coeff$model_var)
} else if (h == 12){
coeff$model_var <- gsub("subcanopy", "", coeff$model_var)
coeff$model_var <- gsub("ring", "", coeff$model_var)
coeff$model_var <- gsub("height", "ht_nat_log", coeff$model_var)
full_mod_1999 <- var_aic[!duplicated(var_aic$Delta_AICc), ]
full_mod_1999 <- full_mod_1999[1:10, c(1,4)]
full_mod_1999[11,] <- var_aic_sub[,c(1,4)]
colnames(full_mod_1999) <- c("Modnames_1999", "dAIC_1999")
full_mod_all <- cbind(full_mod, full_mod_1966, full_mod_1977, full_mod_1999)
}
for (y in seq(along = coeff$model_var)){ ##4
same <- coeff$model_var[[y]]
if(grepl(same, summary_mod_vars_all[[h]])){
coeff_sub <- coeff[coeff$model_var == same, ]
}
#update the coefficient value
summary_models[,18][[h]] <- ifelse(coeff_sub$value<0, -1, 1)
summary_models[,19][[h]] <- ifelse(h == 12, NA, coeff_sub$value)
#update the table. If the sign conventions of the coefficient and the predicted response do not match, assign NA.
# if (h!=12){
#   summary_models[,14][[h]] <- ifelse(
#     (coeff_sub$value <0 & summary_models$response_predict[[h]] <0) |
#       (coeff_sub$value >0 & summary_models$response_predict[[h]] >0),
#     summary_models[,14][[h]], NA)
# }
if (h==12){
coeff <- coeff[-1,]
coeff_max <- coeff[coeff$value == max(coeff$value), ]
summary_models[,24][[h]] <- coeff_max$model_var
}
##5g. add in tree heights ####
## taken from the canopy_heights script
trees_all$height_ln <- ifelse(trees_all$sp == "caco", (0.55+0.766*trees_all$dbh_ln),
ifelse(trees_all$sp == "cagl", (0.652+0.751*trees_all$dbh_ln),
ifelse(trees_all$sp == "caovl", (0.9+0.659*trees_all$dbh_ln),
ifelse(trees_all$sp == "cato", (0.879+0.668*trees_all$dbh_ln),
ifelse(trees_all$sp == "fagr", (0.513+0.712*trees_all$dbh_ln),
ifelse(trees_all$sp == "litu", (1.57+0.488*trees_all$dbh_ln),
ifelse(trees_all$sp == "quru", (1.13+0.54*trees_all$dbh_ln),
(0.849+0.659*trees_all$dbh_ln))))))))
trees_all$height <- exp(trees_all$height_ln) #cm
##5h. add in all crown positions ####
positions <- read.csv(text=getURL("https://raw.githubusercontent.com/SCBI-ForestGEO/SCBI-ForestGEO-Data/master/tree_dimensions/tree_crowns/cored_dendroband_crown_position_data/dendro_cored_full.csv"))
trees_all$position_all <- positions$crown.position[match(trees_all$tree, positions$tag)]
trees_all$position_all <- gsub("D", "dominant", trees_all$position_all)
trees_all$position_all <- gsub("C", "co-dominant", trees_all$position_all)
trees_all$position_all <- gsub("I", "intermediate", trees_all$position_all)
trees_all$position_all <- gsub("S", "suppressed", trees_all$position_all)
#this has been proven to be roughly equivalent to position_all, so we're sticking with position_all
# trees_all$illum <- positions$illum[match(trees_all$tree, positions$tag)]
# trees_all$illum <- as.character(trees_all$illum)
#this csv has avg/min/max dbh for each canopy position by sp
# positionsp <- read.csv("data/core_chronologies_by_crownposition.csv")
##5i. remove all NAs and one bad tree ####
trees_all <- trees_all[complete.cases(trees_all), ]
##fram 140939 has been mislabeled. It is recorded as having a small dbh when that is the second stem. In terms of canopy position, though, it fell between time of coring and when positions were recorded, thus we do not know its position.
trees_all <- trees_all[!trees_all$tree == 140939, ]
##5j. remove resistance values >2 ####
trees_all <- trees_all[trees_all$resist.value <=2,]
##5k. make subsets for individual years, combine all to list ####
# x1964 <- trees_all[trees_all$year == 1964, ]
x1966 <- trees_all[trees_all$year == 1966, ]
x1977 <- trees_all[trees_all$year == 1977, ]
x1999 <- trees_all[trees_all$year == 1999, ]
model_df <- list(trees_all, x1966, x1977, x1999)
names(model_df) <- c("all_years", "x1966", "x1977", "x1999")
library(lme4)
library(AICcmodavg) #aictab function
library(car)
library(piecewiseSEM) #for R^2 values for all model outputs in a list
library(MuMIn) #for R^2 values of one model output
library(stringr)
library(dplyr)
##6a. Determine best model to use with AICc ####
##6ai. test predictions for paper and put in table
##initial table with models based on github issue predictions ####
summary_models <- data.frame(
"prediction" = c("1.0", "1.1", "1.2a", "1.2b", "1.2c1, 1.3a1", "1.2c2", "1.3b1", "1.3a2", "1.3b2", "2.1", "2.2", "4"),
"model_vars_all_years" =
c("resist.value ~ dbh_ln+year+(1|sp/tree)",
"resist.value ~ height_ln+year+(1|sp/tree)",
"resist.value ~ position_all+year+(1|sp/tree)",
"resist.value ~ position_all+height_ln+year+(1|sp/tree)",
"resist.value ~ elev_m+height_ln+year+(1|sp/tree)",
"resist.value ~ elev_m*height_ln+height_ln+year+(1|sp/tree)",
"resist.value ~ distance_ln+height_ln+year+(1|sp/tree)",
"resist.value ~ distance_ln*height_ln+height_ln+year+(1|sp/tree)",
"resist.value ~ tlp+height_ln+year+(1|sp/tree)",
"resist.value ~ rp+height_ln+year+(1|sp/tree)",
"resist.value ~ sap_ratio+position_all+height_ln+height_ln*elev_m+distance_ln+tlp+rp+year+(1|sp/tree)"),
"null_model_all_years" = NA,
"model_vars_sep_years" = NA,
"null_model_sep_years" = NA,
"response_predict" = c(-1, -1, -1, -1, 1, 1, -1, 1, -1, -1, 1, NA),
"response_sign" = c("-", "-", "dominant < codominant < intermediate < supressed", "dominant < codominant < intermediate < supressed", "+", "+", "-", "+", "-", "-", "ring>diffuse", "+"),
"dAIC_all_years" = NA,
"response_obs_all" = NA,
"coef_all_years" = NA,
"dAIC_1964.1966" = NA,
"response_obs_1964.1966" = NA,
"coef_1964.1966" = NA,
"dAIC_1977" = NA,
"response_obs_1977" = NA,
"coef_1977" = NA,
"dAIC_1999" = NA,
"response_obs_1999" = NA,
"coef_1999" = NA,
"notes" = "",
"coef_all_big" = NA,
"coef_1966_big" = NA,
"coef_1977_big" = NA,
"coef_1999_big" = NA)
# change factor columns to character
summary_models %>% mutate_if(is.factor, as.character) -> summary_models
# fill in other columns
summary_models[c(1:3), 3] <- "resist.value ~ year+(1|sp/tree)"
summary_models[c(4:12), 3] <- "resist.value ~ height_ln+year+(1|sp/tree)"
summary_models$model_vars_sep_years <- gsub("year\\+|/tree", "", summary_models$model_vars_all_years)
summary_models$null_model_sep_years <- gsub("year\\+|/tree", "", summary_models$null_model_all_years)
#define vectors to be used in loop
summary_mod_vars_all <- summary_models$model_vars_all_years
summary_mod_vars_sep <- summary_models$model_vars_sep_years
summary_mod_null_all <- summary_models$null_model_all_years
summary_mod_null_sep <- summary_models$null_model_sep_years
##this loop goes through each mix of effects from each prediction (nrow(summary_models)), and runs those models for each of the datasets (all years and the three individual ones). For each iteration (44 total), it calculates dAIC (AIC of model with variable defined in model_vars columns minus the AIC of the null model) and the coefficients before putting them in the table created above.
for (i in seq_along(model_df)){
for (h in seq(along=summary_mod_vars_all)){
if (i==1){
#structure of creating the model strings come from 6a above.
response <- gsub(" ~.*", "", summary_mod_vars_all[[h]])
effects <- unlist(strsplit(summary_mod_vars_all[[h]], "\\+|~ "))[-1]
#create all combinations of random / fixed effects
effects_comb <-
unlist( sapply( seq_len(length(effects)),
function(i) {
apply( combn(effects,i), 2, function(x) paste(x, collapse = "+"))
}))
#make table
var_comb <- expand.grid(response, effects_comb)
var_comb <- var_comb[grepl("1", var_comb$Var2), ] #only keep in fixed/random combos
var_comb <- var_comb[grepl("year", var_comb$Var2), ] #keep year in for drought sake
}
else {
#define response and effects
response <- gsub(" ~.*", "", summary_mod_vars_sep[[h]])
effects <- unlist(strsplit(summary_mod_vars_sep[[h]], "\\+|~ "))[-1]
# all fixed effects <- c("position", "tlp", "rp", "elev_m", "dbh_ln", "height_ln")
#create all combinations of random / fixed effects
effects_comb <-
unlist( sapply( seq_len(length(effects)),
function(i) {
apply( combn(effects,i), 2, function(x) paste(x, collapse = "+"))
}))
#=make table
var_comb <- expand.grid(response, effects_comb)
var_comb <- var_comb[grepl("1", var_comb$Var2), ] #only keep in fixed+random combos
}
#formulas for all combinations.
formula_vec <- sprintf("%s ~ %s", var_comb$Var1, var_comb$Var2)
# create list of model outputs
lmm_all <- lapply(formula_vec, function(x){
fit1 <- lmer(x, data = model_df[[i]], REML=FALSE,
control = lmerControl(optimizer ="Nelder_Mead"))
return(fit1)
})
names(lmm_all) <- formula_vec
var_aic <- aictab(lmm_all, second.ord=TRUE, sort=TRUE) #rank based on AICc
r <- rsquared(lmm_all) #gives R^2 values for models. "Marginal" is the R^2 for just the fixed effects, "Conditional" is the R^2 for everything.
#fill in table
if(i == 1){
#isolate the AIC values of the target (sub) and null models, then math
var_aic_sub <- var_aic[var_aic$Modnames == summary_mod_vars_all[[h]], ]
var_aic_null <- var_aic[var_aic$Modnames == summary_mod_null_all[[h]], ]
summary_models[,8][[h]] <- round(var_aic_null$Delta_AICc - var_aic_sub$Delta_AICc, 2)
var_aic_sub$Modnames <- as.character(var_aic_sub$Modnames)
#this loop says for the models run for this iteration of h, take the model output represented by the target model (1). Get the coefficients and put in df (2). Rename variables such that you only pull what you need (3) and extract the coefficient for the variable you want (4).
for (z in seq(along = lmm_all)){
if (z == rownames(var_aic_sub)){ ##1
coeff <- data.frame(coef(summary(lmm_all[[z]]))[ , "Estimate"]) ##2
coeff[,2] <- rownames(coeff)
colnames(coeff) <- c("value", "model_var")
if (h == 3){ ##3
coeff$model_var <- gsub("subcanopy", "", coeff$model_var)
} else if (h == 4){
coeff$model_var <- gsub("subcanopy", "", coeff$model_var)
coeff$model_var <- gsub("height", "ht_nat_log", coeff$model_var)
} else if (h %in% 5:10){
coeff$model_var <- gsub("height", "ht_nat_log", coeff$model_var)
} else if (h == 11){
coeff$model_var <- gsub("ring", "", coeff$model_var)
coeff$model_var <- gsub("height", "ht_nat_log", coeff$model_var)
} else if (h == 12){
coeff$model_var <- gsub("subcanopy", "", coeff$model_var)
coeff$model_var <- gsub("ring", "", coeff$model_var)
coeff$model_var <- gsub("height", "ht_nat_log", coeff$model_var)
full_mod <- var_aic[!duplicated(var_aic$Delta_AICc), ]
full_mod <- full_mod[1:10, c(1,4)]
full_mod[11,] <- var_aic_sub[,c(1,4)]
colnames(full_mod) <- c("Modnames_all_years", "dAIC_all_years")
}
for (y in seq(along = coeff$model_var)){ ##4
same <- coeff$model_var[[y]]
if(grepl(same, summary_mod_vars_all[[h]])){
coeff_sub <- coeff[coeff$model_var == same, ]
}
#update the coefficient value
summary_models[,9][[h]] <- ifelse(coeff_sub$value<0, -1, 1)
summary_models[,10][[h]] <- ifelse(h == 12, NA, coeff_sub$value)
#update the table. If the sign conventions of the coefficient and the predicted response do not match, assign NA.
# if (h!=12){
#   summary_models[,8][[h]] <- ifelse(
#     (coeff_sub$value <0 & summary_models$response_predict[[h]] <0) |
#       (coeff_sub$value >0 & summary_models$response_predict[[h]] >0),
#     summary_models[,8][[h]], NA)
# }
if(h==12){
coeff <- coeff[-1,]
coeff_max <- coeff[coeff$value == max(coeff$value), ]
summary_models[,21][[h]] <- coeff_max$model_var
}
else if (i == 2) {
#isolate the AIC values of the target (sub) and null models, then math
var_aic_sub <- var_aic[var_aic$Modnames == summary_mod_vars_sep[[h]], ]
var_aic_null <- var_aic[var_aic$Modnames == summary_mod_null_sep[[h]], ]
summary_models[,11][[h]] <- round(var_aic_null$Delta_AICc - var_aic_sub$Delta_AICc, 2)
var_aic_sub$Modnames <- as.character(var_aic_sub$Modnames)
#this loop says for the models run for this iteration of h, take the model output represented by the target model (1). Get the coefficients and put in df (2). Rename variables such that you only pull what you need (3) and extract the coefficient for the variable you want (4).
for (z in seq(along = lmm_all)){
if (z == rownames(var_aic_sub)){ ##1
coeff <- data.frame(coef(summary(lmm_all[[z]]))[ , "Estimate"]) ##2
coeff[,2] <- rownames(coeff)
colnames(coeff) <- c("value", "model_var")
if (h == 3){ ##3
coeff$model_var <- gsub("subcanopy", "", coeff$model_var)
} else if (h == 4){
coeff$model_var <- gsub("subcanopy", "", coeff$model_var)
coeff$model_var <- gsub("height", "ht_nat_log", coeff$model_var)
} else if (h %in% 5:10){
coeff$model_var <- gsub("height", "ht_nat_log", coeff$model_var)
} else if (h == 11){
coeff$model_var <- gsub("ring", "", coeff$model_var)
coeff$model_var <- gsub("height", "ht_nat_log", coeff$model_var)
} else if (h == 12){
coeff$model_var <- gsub("subcanopy", "", coeff$model_var)
coeff$model_var <- gsub("ring", "", coeff$model_var)
coeff$model_var <- gsub("height", "ht_nat_log", coeff$model_var)
full_mod_1966 <- var_aic[!duplicated(var_aic$Delta_AICc), ]
full_mod_1966 <- full_mod_1966[1:10, c(1,4)]
full_mod_1966[11,] <- var_aic_sub[,c(1,4)]
colnames(full_mod_1966) <- c("Modnames_1966", "dAIC_1966")
}
for (y in seq(along = coeff$model_var)){ ##4
same <- coeff$model_var[[y]]
if(grepl(same, summary_mod_vars_all[[h]])){
coeff_sub <- coeff[coeff$model_var == same, ]
}
#update the coefficient value
summary_models[,12][[h]] <- ifelse(coeff_sub$value<0, -1, 1)
summary_models[,13][[h]] <- ifelse(h == 12, NA, coeff_sub$value)
#update the table. If the sign conventions of the coefficient and the predicted response do not match, assign NA.
# if (h!=12){
#   summary_models[,10][[h]] <- ifelse(
#     (coeff_sub$value <0 & summary_models$response_predict[[h]] <0) |
#       (coeff_sub$value >0 & summary_models$response_predict[[h]] >0),
#     summary_models[,10][[h]], NA)
# }
if(h==12){
coeff <- coeff[-1,]
coeff_max <- coeff[coeff$value == max(coeff$value), ]
summary_models[,22][[h]] <- coeff_max$model_var
}
else if (i == 3){
#isolate the AIC values of the target (sub) and null models, then math
var_aic_sub <- var_aic[var_aic$Modnames == summary_mod_vars_sep[[h]], ]
var_aic_null <- var_aic[var_aic$Modnames == summary_mod_null_sep[[h]], ]
summary_models[,14][[h]] <- round(var_aic_null$Delta_AICc - var_aic_sub$Delta_AICc, 2)
var_aic_sub$Modnames <- as.character(var_aic_sub$Modnames)
#this loop says for the models run for this iteration of h, take the model output represented by the target model (1). Get the coefficients and put in df (2). Rename variables such that you only pull what you need (3) and extract the coefficient for the variable you want (4).
for (z in seq(along = lmm_all)){
if (z == rownames(var_aic_sub)){ ##1
coeff <- data.frame(coef(summary(lmm_all[[z]]))[ , "Estimate"]) ##2
coeff[,2] <- rownames(coeff)
colnames(coeff) <- c("value", "model_var")
if (h == 3){ ##3
coeff$model_var <- gsub("subcanopy", "", coeff$model_var)
} else if (h == 4){
coeff$model_var <- gsub("subcanopy", "", coeff$model_var)
coeff$model_var <- gsub("height", "ht_nat_log", coeff$model_var)
} else if (h %in% 5:10){
coeff$model_var <- gsub("height", "ht_nat_log", coeff$model_var)
} else if (h == 11){
coeff$model_var <- gsub("ring", "", coeff$model_var)
coeff$model_var <- gsub("height", "ht_nat_log", coeff$model_var)
} else if (h == 12){
coeff$model_var <- gsub("subcanopy", "", coeff$model_var)
coeff$model_var <- gsub("ring", "", coeff$model_var)
coeff$model_var <- gsub("height", "ht_nat_log", coeff$model_var)
full_mod_1977 <- var_aic[!duplicated(var_aic$Delta_AICc), ]
full_mod_1977 <- full_mod_1977[1:10, c(1,4)]
full_mod_1977[11,] <- var_aic_sub[,c(1,4)]
colnames(full_mod_1977) <- c("Modnames_1977", "dAIC_1977")
}
for (y in seq(along = coeff$model_var)){ ##4
same <- coeff$model_var[[y]]
if(grepl(same, summary_mod_vars_all[[h]])){
coeff_sub <- coeff[coeff$model_var == same, ]
}
#update the coefficient value
summary_models[,15][[h]] <- ifelse(coeff_sub$value<0, -1, 1)
summary_models[,16][[h]] <- ifelse(h == 12, NA, coeff_sub$value)
#update the table. If the sign conventions of the coefficient and the predicted response do not match, assign NA.
# if(h!=12){
#   summary_models[,12][[h]] <- ifelse(
#     (coeff_sub$value <0 & summary_models$response_predict[[h]] <0) |
#       (coeff_sub$value >0 & summary_models$response_predict[[h]] >0),
#     summary_models[,12][[h]], NA)
# }
if(h==12){
coeff <- coeff[-1,]
coeff_max <- coeff[coeff$value == max(coeff$value), ]
summary_models[,23][[h]] <- coeff_max$model_var
}
else if (i == 4){
#isolate the AIC values of the target (sub) and null models, then math
var_aic_sub <- var_aic[var_aic$Modnames == summary_mod_vars_sep[[h]], ]
var_aic_null <- var_aic[var_aic$Modnames == summary_mod_null_sep[[h]], ]
summary_models[,17][[h]] <- round(var_aic_null$Delta_AICc - var_aic_sub$Delta_AICc, 2)
var_aic_sub$Modnames <- as.character(var_aic_sub$Modnames)
#this loop says for the models run for this iteration of h, take the model output represented by the target model (1). Get the coefficients and put in df (2). Rename variables such that you only pull what you need (3) and extract the coefficient for the variable you want (4).
for (z in seq(along = lmm_all)){
if (z == rownames(var_aic_sub)){ ##1
coeff <- data.frame(coef(summary(lmm_all[[z]]))[ , "Estimate"]) ##2
coeff[,2] <- rownames(coeff)
colnames(coeff) <- c("value", "model_var")
if (h == 3){ ##3
coeff$model_var <- gsub("subcanopy", "", coeff$model_var)
} else if (h == 4){
coeff$model_var <- gsub("subcanopy", "", coeff$model_var)
coeff$model_var <- gsub("height", "ht_nat_log", coeff$model_var)
} else if (h %in% 5:10){
coeff$model_var <- gsub("height", "ht_nat_log", coeff$model_var)
} else if (h == 11){
coeff$model_var <- gsub("ring", "", coeff$model_var)
coeff$model_var <- gsub("height", "ht_nat_log", coeff$model_var)
} else if (h == 12){
coeff$model_var <- gsub("subcanopy", "", coeff$model_var)
coeff$model_var <- gsub("ring", "", coeff$model_var)
coeff$model_var <- gsub("height", "ht_nat_log", coeff$model_var)
full_mod_1999 <- var_aic[!duplicated(var_aic$Delta_AICc), ]
full_mod_1999 <- full_mod_1999[1:10, c(1,4)]
full_mod_1999[11,] <- var_aic_sub[,c(1,4)]
colnames(full_mod_1999) <- c("Modnames_1999", "dAIC_1999")
full_mod_all <- cbind(full_mod, full_mod_1966, full_mod_1977, full_mod_1999)
}
for (y in seq(along = coeff$model_var)){ ##4
same <- coeff$model_var[[y]]
if(grepl(same, summary_mod_vars_all[[h]])){
coeff_sub <- coeff[coeff$model_var == same, ]
}
#update the coefficient value
summary_models[,18][[h]] <- ifelse(coeff_sub$value<0, -1, 1)
summary_models[,19][[h]] <- ifelse(h == 12, NA, coeff_sub$value)
#update the table. If the sign conventions of the coefficient and the predicted response do not match, assign NA.
# if (h!=12){
#   summary_models[,14][[h]] <- ifelse(
#     (coeff_sub$value <0 & summary_models$response_predict[[h]] <0) |
#       (coeff_sub$value >0 & summary_models$response_predict[[h]] >0),
#     summary_models[,14][[h]], NA)
# }
if (h==12){
coeff <- coeff[-1,]
coeff_max <- coeff[coeff$value == max(coeff$value), ]
summary_models[,24][[h]] <- coeff_max$model_var
}
View(summary_models)
#csv has a 1 in the title to make sure any notes in current file are not overwritten
write.csv(summary_models, "manuscript/results_individual_years1.csv", row.names=FALSE)
