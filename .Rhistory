colnames(coeff) <- c(names(model_df[j]), "model_var")
coeff$value <- round(coeff$value, 3)
assign(paste0("coeff_", names(model_df[j])), coeff)
# best_mod_traits[,column_cof][[i]] <- ifelse(any(coeff$value < 0), "-", "+")
best_mod_traits[,"coef"][[i]] <- paste(coeff_vec, collapse = ", ")
#put r2 in table
r <- rsquared(fit1) #gives R^2 values for models. "Marginal" is the R^2 for just the fixed effects, "Conditional" is the R^2 for everything.
best_mod_traits$r2[[i]] <- round(r$Conditional, 2)
}
}
#INDIVIDUAL YEARS
} else if (j == i){
response <- "resist.value"
effects <- best_mod_full_year
#create all combinations of random / fixed effects
effects_comb <-
unlist( sapply( seq_len(length(effects)),
function(i) {
apply( combn(effects,i), 2, function(x) paste(x, collapse = "+"))
}))
var_comb <- expand.grid(response, effects_comb)
var_comb <- var_comb[grepl("1", var_comb$Var2), ] #only keep in fixed/random combos
formula_vec <- sprintf("%s ~ %s", var_comb$Var1, var_comb$Var2)
lmm_all <- lapply(formula_vec, function(x){
fit1 <- lmer(x, data = model_df[[j]], REML=FALSE,
control = lmerControl(optimizer ="Nelder_Mead"))
return(fit1)
})
names(lmm_all) <- formula_vec
var_aic <- aictab(lmm_all, second.ord=TRUE, sort=TRUE) #rank based on AICc
var_aic$Modnames <- as.character(var_aic$Modnames)
best_mod_traits$best_model[[i]] <- var_aic$Modnames[[1]]
for (z in seq(along = lmm_all)){
if (names(lmm_all[z]) == var_aic$Modnames[[1]]){
#run the best model alone with REML=TRUE
fit1 <- lmer(formula_vec[[z]], data = model_df[[j]], REML=TRUE,
control = lmerControl(optimizer ="Nelder_Mead"))
#get coefficients and put in table
coeff <- data.frame(coef(summary(fit1))[ , "Estimate"]) ##2
coeff[,2] <- rownames(coeff)
colnames(coeff) <- c(names(model_df[j]), "model_var")
coeff$value <- round(coeff$value, 3)
assign(paste0("coeff_", names(model_df[j])), coeff)
# best_mod_traits[,column_cof][[i]] <- ifelse(any(coeff$value < 0), "-", "+")
best_mod_traits[,"coef"][[i]] <- paste(coeff_vec, collapse = ", ")
#put r2 in table
r <- rsquared(fit1) #gives R^2 values for models. "Marginal" is the R^2 for just the fixed effects, "Conditional" is the R^2 for everything.
best_mod_traits$r2[[i]] <- round(r$Conditional, 2)
}
}
}
}
}
coeff[,2] <- rownames(coeff)
View(coeff)
#get coefficients and put in table
coeff <- data.frame(coef(summary(fit1))[ , "Estimate"]) ##2
coeff[,2] <- rownames(coeff)
View(coeff)
coeff[1,] <- round(coeff[1,] 3)
coeff[1,] <- round(coeff[1,], 3)
View(coeff)
coeff[,1] <- round(coeff[,1], 3)
View(coeff)
#this loop determines the best full model for each scenario, using the traits from cand_full in #6a, and populates the table created above
for (i in seq(along=c(1:4))){
for (j in seq(along=model_df)){
#ALL YEARS
if(j == 1 & i == 1){
response <- "resist.value"
effects <- best_mod_full
#create all combinations of random / fixed effects
effects_comb <-
unlist(sapply(seq_len(length(effects)), function(i) {
apply( combn(effects,i), 2, function(x) paste(x, collapse = "+"))
}))
# pair response with effect and sub out combinations that don't include random effects
#in general, if two variables are >70% correlated, you can toss one of them without significantly affecting the results
var_comb <- expand.grid(response, effects_comb)
var_comb <- var_comb[grepl("1", var_comb$Var2), ] #only keep in fixed/random combos
# formulas for all combinations. $Var1 is the response, and $Var2 is the effect
# for good stats, you should have no more total parameters than 1/10th the number of observations in your dataset
formula_vec <- sprintf("%s ~ %s", var_comb$Var1, var_comb$Var2)
lmm_all <- lapply(formula_vec, function(x){
fit1 <- lmer(x, data = model_df[[j]], REML=FALSE,
control = lmerControl(optimizer ="Nelder_Mead"))
return(fit1)
})
names(lmm_all) <- formula_vec
var_aic <- aictab(lmm_all, second.ord=TRUE, sort=TRUE) #rank based on AICc
var_aic$Modnames <- as.character(var_aic$Modnames)
best_mod_traits$best_model[[i]] <- var_aic$Modnames[[1]]
for (z in seq(along = lmm_all)){
if (names(lmm_all[z]) == var_aic$Modnames[[1]]){
#run the best model alone with REML=TRUE
fit1 <- lmer(formula_vec[[z]], data = model_df[[j]], REML=TRUE,
control = lmerControl(optimizer ="Nelder_Mead"))
#get coefficients and put in table
coeff <- data.frame(coef(summary(fit1))[ , "Estimate"]) ##2
coeff[,2] <- rownames(coeff)
coeff[,1] <- round(coeff[,1], 3)
colnames(coeff) <- c(names(model_df[j]), "model_var")
assign(paste0("coeff_", names(model_df[j])), coeff)
# best_mod_traits[,column_cof][[i]] <- ifelse(any(coeff$value < 0), "-", "+")
best_mod_traits[,"coef"][[i]] <- paste(coeff_vec, collapse = ", ")
#put r2 in table
r <- rsquared(fit1) #gives R^2 values for models. "Marginal" is the R^2 for just the fixed effects, "Conditional" is the R^2 for everything.
best_mod_traits$r2[[i]] <- round(r$Conditional, 2)
}
}
#INDIVIDUAL YEARS
} else if (j == i){
response <- "resist.value"
effects <- best_mod_full_year
#create all combinations of random / fixed effects
effects_comb <-
unlist( sapply( seq_len(length(effects)),
function(i) {
apply( combn(effects,i), 2, function(x) paste(x, collapse = "+"))
}))
var_comb <- expand.grid(response, effects_comb)
var_comb <- var_comb[grepl("1", var_comb$Var2), ] #only keep in fixed/random combos
formula_vec <- sprintf("%s ~ %s", var_comb$Var1, var_comb$Var2)
lmm_all <- lapply(formula_vec, function(x){
fit1 <- lmer(x, data = model_df[[j]], REML=FALSE,
control = lmerControl(optimizer ="Nelder_Mead"))
return(fit1)
})
names(lmm_all) <- formula_vec
var_aic <- aictab(lmm_all, second.ord=TRUE, sort=TRUE) #rank based on AICc
var_aic$Modnames <- as.character(var_aic$Modnames)
best_mod_traits$best_model[[i]] <- var_aic$Modnames[[1]]
for (z in seq(along = lmm_all)){
if (names(lmm_all[z]) == var_aic$Modnames[[1]]){
#run the best model alone with REML=TRUE
fit1 <- lmer(formula_vec[[z]], data = model_df[[j]], REML=TRUE,
control = lmerControl(optimizer ="Nelder_Mead"))
#get coefficients and put in table
coeff <- data.frame(coef(summary(fit1))[ , "Estimate"]) ##2
coeff[,2] <- rownames(coeff)
coeff[,1] <- round(coeff[,1], 3)
colnames(coeff) <- c(names(model_df[j]), "model_var")
assign(paste0("coeff_", names(model_df[j])), coeff)
# best_mod_traits[,column_cof][[i]] <- ifelse(any(coeff$value < 0), "-", "+")
best_mod_traits[,"coef"][[i]] <- paste(coeff_vec, collapse = ", ")
#put r2 in table
r <- rsquared(fit1) #gives R^2 values for models. "Marginal" is the R^2 for just the fixed effects, "Conditional" is the R^2 for everything.
best_mod_traits$r2[[i]] <- round(r$Conditional, 2)
}
}
}
}
}
View(coeff_x1966)
View(coeff_x1977)
View(coeff_x1999)
View(coeff_x1977)
View(coeff_x1966)
View(coeff_x1977)
View(coeff_x1999)
maybe <- merge(coeff_x1966, coeff_x1977, coeff_x1999, by="model_var", all=TRUE)
?merge
maybe <- base::merge(coeff_x1966, coeff_x1977, by="model_var", all=TRUE)
View(maybe)
maybe <- merge(maybe, coeff_x1999, by="model_var", all=TRUE)
View(maybe)
View(coeff_trees_all_sub)
#this loop determines the best full model for each scenario, using the traits from cand_full in #6a, and populates the table created above
coeff_list <- list()
for (i in seq(along=c(1:4))){
for (j in seq(along=model_df)){
#ALL YEARS
if(j == 1 & i == 1){
response <- "resist.value"
effects <- best_mod_full
#create all combinations of random / fixed effects
effects_comb <-
unlist(sapply(seq_len(length(effects)), function(i) {
apply( combn(effects,i), 2, function(x) paste(x, collapse = "+"))
}))
# pair response with effect and sub out combinations that don't include random effects
#in general, if two variables are >70% correlated, you can toss one of them without significantly affecting the results
var_comb <- expand.grid(response, effects_comb)
var_comb <- var_comb[grepl("1", var_comb$Var2), ] #only keep in fixed/random combos
# formulas for all combinations. $Var1 is the response, and $Var2 is the effect
# for good stats, you should have no more total parameters than 1/10th the number of observations in your dataset
formula_vec <- sprintf("%s ~ %s", var_comb$Var1, var_comb$Var2)
lmm_all <- lapply(formula_vec, function(x){
fit1 <- lmer(x, data = model_df[[j]], REML=FALSE,
control = lmerControl(optimizer ="Nelder_Mead"))
return(fit1)
})
names(lmm_all) <- formula_vec
var_aic <- aictab(lmm_all, second.ord=TRUE, sort=TRUE) #rank based on AICc
var_aic$Modnames <- as.character(var_aic$Modnames)
best_mod_traits$best_model[[i]] <- var_aic$Modnames[[1]]
for (z in seq(along = lmm_all)){
if (names(lmm_all[z]) == var_aic$Modnames[[1]]){
#run the best model alone with REML=TRUE
fit1 <- lmer(formula_vec[[z]], data = model_df[[j]], REML=TRUE,
control = lmerControl(optimizer ="Nelder_Mead"))
#get coefficients and put in table
coeff <- data.frame(coef(summary(fit1))[ , "Estimate"]) ##2
coeff[,2] <- rownames(coeff)
coeff[,1] <- round(coeff[,1], 3)
colnames(coeff) <- c(names(model_df[j]), "model_var")
coeff_list[[paste0("coeff_", names(model_df[j]))]] <- coeff
# best_mod_traits[,column_cof][[i]] <- ifelse(any(coeff$value < 0), "-", "+")
best_mod_traits[,"coef"][[i]] <- paste(coeff_vec, collapse = ", ")
#put r2 in table
r <- rsquared(fit1) #gives R^2 values for models. "Marginal" is the R^2 for just the fixed effects, "Conditional" is the R^2 for everything.
best_mod_traits$r2[[i]] <- round(r$Conditional, 2)
}
}
#INDIVIDUAL YEARS
} else if (j == i){
response <- "resist.value"
effects <- best_mod_full_year
#create all combinations of random / fixed effects
effects_comb <-
unlist( sapply( seq_len(length(effects)),
function(i) {
apply( combn(effects,i), 2, function(x) paste(x, collapse = "+"))
}))
var_comb <- expand.grid(response, effects_comb)
var_comb <- var_comb[grepl("1", var_comb$Var2), ] #only keep in fixed/random combos
formula_vec <- sprintf("%s ~ %s", var_comb$Var1, var_comb$Var2)
lmm_all <- lapply(formula_vec, function(x){
fit1 <- lmer(x, data = model_df[[j]], REML=FALSE,
control = lmerControl(optimizer ="Nelder_Mead"))
return(fit1)
})
names(lmm_all) <- formula_vec
var_aic <- aictab(lmm_all, second.ord=TRUE, sort=TRUE) #rank based on AICc
var_aic$Modnames <- as.character(var_aic$Modnames)
best_mod_traits$best_model[[i]] <- var_aic$Modnames[[1]]
for (z in seq(along = lmm_all)){
if (names(lmm_all[z]) == var_aic$Modnames[[1]]){
#run the best model alone with REML=TRUE
fit1 <- lmer(formula_vec[[z]], data = model_df[[j]], REML=TRUE,
control = lmerControl(optimizer ="Nelder_Mead"))
#get coefficients and put in table
coeff <- data.frame(coef(summary(fit1))[ , "Estimate"]) ##2
coeff[,2] <- rownames(coeff)
coeff[,1] <- round(coeff[,1], 3)
colnames(coeff) <- c(names(model_df[j]), "model_var")
coeff_list[[paste0("coeff_", names(model_df[j]))]] <- coeff
# best_mod_traits[,column_cof][[i]] <- ifelse(any(coeff$value < 0), "-", "+")
best_mod_traits[,"coef"][[i]] <- paste(coeff_vec, collapse = ", ")
#put r2 in table
r <- rsquared(fit1) #gives R^2 values for models. "Marginal" is the R^2 for just the fixed effects, "Conditional" is the R^2 for everything.
best_mod_traits$r2[[i]] <- round(r$Conditional, 2)
}
}
}
}
}
View(coeff_list)
maybe <- Reduce(function(dtf1, dtf2) merge(dtf1, dtf2, by = "model_var", all = TRUE),
coeff_list)
View(maybe)
setnames(coeff_table, old="trees_all_sub", new="all years")
coeff_table <- Reduce(function(dtf1, dtf2)
merge(dtf1, dtf2, by = "model_var", all = TRUE),
coeff_list)
setnames(coeff_table, old="trees_all_sub", new="all years")
View(coeff_table)
View(best_mod_traits)
View(best_mod_traits)
View(coeff_table)
#put r2 in table
r <- rsquared(fit1) #gives R^2 values for models. "Marginal" is the R^2 for just the fixed effects, "Conditional" is the R^2 for everything.
View(r)
r$model_var <- "r-squared"
r <- r[,6:7]
#put r2 in table
r <- rsquared(fit1) #gives R^2 values for models. "Marginal" is the R^2 for just the fixed effects, "Conditional" is the R^2 for everything.
r <- r[,6]
colnames(r) <- names(model_df[j])
r$model_var <- "r-squared"
#put r2 in table
r <- rsquared(fit1) #gives R^2 values for models. "Marginal" is the R^2 for just the fixed effects, "Conditional" is the R^2 for everything.
r <- data.frame(r[,6])
colnames(r) <- names(model_df[j])
r$model_var <- "r-squared"
View(r)
r[,1] <- round(r[,1], 2)
View(r)
coeff <- rbind(r,coeff)
View(coeff)
#this loop determines the best full model for each scenario, using the traits from cand_full in #6a, and populates the table created above
coeff_list <- list()
for (i in seq(along=c(1:4))){
for (j in seq(along=model_df)){
#ALL YEARS
if(j == 1 & i == 1){
response <- "resist.value"
effects <- best_mod_full
#create all combinations of random / fixed effects
effects_comb <-
unlist(sapply(seq_len(length(effects)), function(i) {
apply( combn(effects,i), 2, function(x) paste(x, collapse = "+"))
}))
# pair response with effect and sub out combinations that don't include random effects
#in general, if two variables are >70% correlated, you can toss one of them without significantly affecting the results
var_comb <- expand.grid(response, effects_comb)
var_comb <- var_comb[grepl("1", var_comb$Var2), ] #only keep in fixed/random combos
# formulas for all combinations. $Var1 is the response, and $Var2 is the effect
# for good stats, you should have no more total parameters than 1/10th the number of observations in your dataset
formula_vec <- sprintf("%s ~ %s", var_comb$Var1, var_comb$Var2)
lmm_all <- lapply(formula_vec, function(x){
fit1 <- lmer(x, data = model_df[[j]], REML=FALSE,
control = lmerControl(optimizer ="Nelder_Mead"))
return(fit1)
})
names(lmm_all) <- formula_vec
var_aic <- aictab(lmm_all, second.ord=TRUE, sort=TRUE) #rank based on AICc
var_aic$Modnames <- as.character(var_aic$Modnames)
best_mod_traits$best_model[[i]] <- var_aic$Modnames[[1]]
for (z in seq(along = lmm_all)){
if (names(lmm_all[z]) == var_aic$Modnames[[1]]){
#run the best model alone with REML=TRUE
fit1 <- lmer(formula_vec[[z]], data = model_df[[j]], REML=TRUE,
control = lmerControl(optimizer ="Nelder_Mead"))
#get coefficients and put in table
coeff <- data.frame(coef(summary(fit1))[ , "Estimate"]) ##2
coeff[,2] <- rownames(coeff)
coeff[,1] <- round(coeff[,1], 3)
colnames(coeff) <- c(names(model_df[j]), "model_var")
#put r2 in table
r <- rsquared(fit1) #gives R^2 values for models. "Marginal" is the R^2 for just the fixed effects, "Conditional" is the R^2 for everything.
r <- data.frame(r[,6])
colnames(r) <- names(model_df[j])
r$model_var <- "r-squared"
r[,1] <- round(r[,1], 3)
coeff <- rbind(r,coeff)
coeff_list[[paste0("coeff_", names(model_df[j]))]] <- coeff
}
}
#INDIVIDUAL YEARS
} else if (j == i){
response <- "resist.value"
effects <- best_mod_full_year
#create all combinations of random / fixed effects
effects_comb <-
unlist( sapply( seq_len(length(effects)),
function(i) {
apply( combn(effects,i), 2, function(x) paste(x, collapse = "+"))
}))
var_comb <- expand.grid(response, effects_comb)
var_comb <- var_comb[grepl("1", var_comb$Var2), ] #only keep in fixed/random combos
formula_vec <- sprintf("%s ~ %s", var_comb$Var1, var_comb$Var2)
lmm_all <- lapply(formula_vec, function(x){
fit1 <- lmer(x, data = model_df[[j]], REML=FALSE,
control = lmerControl(optimizer ="Nelder_Mead"))
return(fit1)
})
names(lmm_all) <- formula_vec
var_aic <- aictab(lmm_all, second.ord=TRUE, sort=TRUE) #rank based on AICc
var_aic$Modnames <- as.character(var_aic$Modnames)
best_mod_traits$best_model[[i]] <- var_aic$Modnames[[1]]
for (z in seq(along = lmm_all)){
if (names(lmm_all[z]) == var_aic$Modnames[[1]]){
#run the best model alone with REML=TRUE
fit1 <- lmer(formula_vec[[z]], data = model_df[[j]], REML=TRUE,
control = lmerControl(optimizer ="Nelder_Mead"))
#get coefficients and put in table
coeff <- data.frame(coef(summary(fit1))[ , "Estimate"]) ##2
coeff[,2] <- rownames(coeff)
coeff[,1] <- round(coeff[,1], 3)
colnames(coeff) <- c(names(model_df[j]), "model_var")
#put r2 in table
r <- rsquared(fit1) #gives R^2 values for models. "Marginal" is the R^2 for just the fixed effects, "Conditional" is the R^2 for everything.
r <- data.frame(r[,6])
colnames(r) <- names(model_df[j])
r$model_var <- "r-squared"
r[,1] <- round(r[,1], 3)
coeff <- rbind(r,coeff)
coeff_list[[paste0("coeff_", names(model_df[j]))]] <- coeff
}
}
}
}
}
coeff_table <- Reduce(function(dtf1, dtf2)
merge(dtf1, dtf2, by = "model_var", all = TRUE),
coeff_list)
setnames(coeff_table, old="trees_all_sub", new="all years")
View(coeff_table)
vars <- coeff_table$model_var
vars <- c(-"r-squared")
vars <- -c("r-squared")
vars <- vars[-c("r-squared")]
vars <- vars[-"r-squared"]
vars <- vars[!vars = "r-squared"]
vars <- vars[!vars %in% "r-squared"]
vars <- c("r^2", vars)
coeff_table <- coeff_table %>%
slice(match(vars, model_var))
View(coeff_table)
#this loop determines the best full model for each scenario, using the traits from cand_full in #6a, and populates the table created above
coeff_list <- list()
for (i in seq(along=c(1:4))){
for (j in seq(along=model_df)){
#ALL YEARS
if(j == 1 & i == 1){
response <- "resist.value"
effects <- best_mod_full
#create all combinations of random / fixed effects
effects_comb <-
unlist(sapply(seq_len(length(effects)), function(i) {
apply( combn(effects,i), 2, function(x) paste(x, collapse = "+"))
}))
# pair response with effect and sub out combinations that don't include random effects
#in general, if two variables are >70% correlated, you can toss one of them without significantly affecting the results
var_comb <- expand.grid(response, effects_comb)
var_comb <- var_comb[grepl("1", var_comb$Var2), ] #only keep in fixed/random combos
# formulas for all combinations. $Var1 is the response, and $Var2 is the effect
# for good stats, you should have no more total parameters than 1/10th the number of observations in your dataset
formula_vec <- sprintf("%s ~ %s", var_comb$Var1, var_comb$Var2)
lmm_all <- lapply(formula_vec, function(x){
fit1 <- lmer(x, data = model_df[[j]], REML=FALSE,
control = lmerControl(optimizer ="Nelder_Mead"))
return(fit1)
})
names(lmm_all) <- formula_vec
var_aic <- aictab(lmm_all, second.ord=TRUE, sort=TRUE) #rank based on AICc
var_aic$Modnames <- as.character(var_aic$Modnames)
best_mod_traits$best_model[[i]] <- var_aic$Modnames[[1]]
for (z in seq(along = lmm_all)){
if (names(lmm_all[z]) == var_aic$Modnames[[1]]){
#run the best model alone with REML=TRUE
fit1 <- lmer(formula_vec[[z]], data = model_df[[j]], REML=TRUE,
control = lmerControl(optimizer ="Nelder_Mead"))
#get coefficients and put in table
coeff <- data.frame(coef(summary(fit1))[ , "Estimate"]) ##2
coeff[,2] <- rownames(coeff)
coeff[,1] <- round(coeff[,1], 3)
colnames(coeff) <- c(names(model_df[j]), "model_var")
#put r2 in table
r <- rsquared(fit1) #gives R^2 values for models. "Marginal" is the R^2 for just the fixed effects, "Conditional" is the R^2 for everything.
r <- data.frame(r[,6])
colnames(r) <- names(model_df[j])
r$model_var <- "r^2"
r[,1] <- round(r[,1], 2)
coeff <- rbind(r,coeff)
coeff_list[[paste0("coeff_", names(model_df[j]))]] <- coeff
}
}
#INDIVIDUAL YEARS
} else if (j == i){
response <- "resist.value"
effects <- best_mod_full_year
#create all combinations of random / fixed effects
effects_comb <-
unlist( sapply( seq_len(length(effects)),
function(i) {
apply( combn(effects,i), 2, function(x) paste(x, collapse = "+"))
}))
var_comb <- expand.grid(response, effects_comb)
var_comb <- var_comb[grepl("1", var_comb$Var2), ] #only keep in fixed/random combos
formula_vec <- sprintf("%s ~ %s", var_comb$Var1, var_comb$Var2)
lmm_all <- lapply(formula_vec, function(x){
fit1 <- lmer(x, data = model_df[[j]], REML=FALSE,
control = lmerControl(optimizer ="Nelder_Mead"))
return(fit1)
})
names(lmm_all) <- formula_vec
var_aic <- aictab(lmm_all, second.ord=TRUE, sort=TRUE) #rank based on AICc
var_aic$Modnames <- as.character(var_aic$Modnames)
best_mod_traits$best_model[[i]] <- var_aic$Modnames[[1]]
for (z in seq(along = lmm_all)){
if (names(lmm_all[z]) == var_aic$Modnames[[1]]){
#run the best model alone with REML=TRUE
fit1 <- lmer(formula_vec[[z]], data = model_df[[j]], REML=TRUE,
control = lmerControl(optimizer ="Nelder_Mead"))
#get coefficients and put in table
coeff <- data.frame(coef(summary(fit1))[ , "Estimate"]) ##2
coeff[,2] <- rownames(coeff)
coeff[,1] <- round(coeff[,1], 3)
colnames(coeff) <- c(names(model_df[j]), "model_var")
#put r2 in table
r <- rsquared(fit1) #gives R^2 values for models. "Marginal" is the R^2 for just the fixed effects, "Conditional" is the R^2 for everything.
r <- data.frame(r[,6])
colnames(r) <- names(model_df[j])
r$model_var <- "r^2"
r[,1] <- round(r[,1], 2)
coeff <- rbind(r,coeff)
coeff_list[[paste0("coeff_", names(model_df[j]))]] <- coeff
}
}
}
}
}
##make table of coefficients and r2, then reorder table
coeff_table <- Reduce(function(dtf1, dtf2)
merge(dtf1, dtf2, by = "model_var", all = TRUE),
coeff_list)
setnames(coeff_table, old="trees_all_sub", new="all years")
vars <- coeff_table$model_var
vars <- vars[!vars %in% "r-squared"]
vars <- c("r^2", vars)
coeff_table <- coeff_table %>%
slice(match(vars, model_var))
View(coeff_table)
vars <- coeff_table$model_var
vars <- vars[!vars %in% "r^2"]
vars <- c("r^2", vars)
coeff_table <- coeff_table %>%
slice(match(vars, model_var))
View(coeff_table)
write.csv(coeff_table, "manuscript/tables_figures/tested_traits_best_coeffs.csv", row.names=FALSE)
