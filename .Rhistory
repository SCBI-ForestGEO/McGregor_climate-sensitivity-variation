elev <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/SCBI-ForestGEO-Data/spatial_data/elevation/full_stem_elevation_2013.csv")
View(elev)
trees_all$elev_m <- elev$dem_sigeo[match(trees_all$tag, elev$tag)]
View(trees_all)
trees_all$elev_m <- elev$dem_sigeo[match(trees_all$tree, elev$tag)]
View(trees_all)
library(lme4)
library(AICcmodavg)
library(car)
#define response and effects
response <- "resist.value"
effects <- c("position", "tlp", "rp", "elev_m", "(1 | year)", "(1 | sp / tree)")
#create all combinations of random / fixed effects
effects_comb <-
unlist( sapply( seq_len(length(effects)),
function(i) {
apply( combn(effects,i), 2, function(x) paste(x, collapse = "+"))
}))
# pair response with effect and sub out combinations that don't include random effects
var_comb <- expand.grid(response, effects_comb)
var_comb <- var_comb[grepl("1", var_comb$Var2), ] #only keep in fixed/random combos
var_comb <- var_comb[grepl("year", var_comb$Var2), ] #keep year in for drought sake
# formulas for all combinations. $Var1 is the response, and $Var2 is the effect
formula_vec <- sprintf("%s ~ %s", var_comb$Var1, var_comb$Var2)
formula_vec
# create list of model outputs
lmm_all <- lapply(formula_vec, function(x){
fit1 <- lmer(x, data = trees_all, REML=FALSE)
#fit1$coefficients <- coef( summary(fit1))
return(fit1)
})
names(lmm_all) <- formula_vec
var_aic <- aictab(lmm_all, second.ord=TRUE, sort=TRUE) #rank based on AICc
View(var_aic)
scbi.full2 <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/SCBI-ForestGEO-Data/tree_main_census/data/census-csv-files/scbi.full2.csv", stringsAsFactors=FALSE)
scbi.full2[5340, 3] <- 40874 #duplicated tag (above 10cm dbh)
scbi.full2 <- scbi.full2[scbi.full2$dbh>=100, ]#& !grepl("S", scbi.full2$codes), ]
trees <- scbi.full2[c(3,7,8)]
rownames(trees) <- trees[,1]
trees <- trees[, -1]
library(vegan)
d <- vegdist(trees, method="euclidean") #calculate distance between one tree and all the other trees using Pythagorean theorem
m <- data.frame(t(combn(rownames(trees),2)), as.numeric(d)) #put in df format
names(m) <- c("tree1", "tree2", "distance")
simple <- m[m$distance<=30, ] #only include distances of 30m or less
simple <- simple[order(simple$tree1, simple$distance), ] #sort by tree and distance
simple$tree1 <- as.character(simple$tree1)
simple$tree2 <- as.character(simple$tree2)
simple$tree1 <- as.numeric(simple$tree1)
simple$tree2 <- as.numeric(simple$tree2)
scbi.sub <- scbi.full2[scbi.full2$tag %in% unique(simple$tree1), ] #this number won't match "trees" because some trees from scbi.sub are >30m apart from another tree
scbi.sub <- scbi.sub[c(3,7,8,11)]
scbi.sub$dbh <- scbi.sub$dbh/10 #dbh needs to be in cm for basal area equation
scbi.sub$basal <- (pi*(scbi.sub$dbh/2)^2)*0.0001
dist <- seq(0,30, by=0.5)
dist <- gsub("^", "x", dist)
scbi.sub[, dist] <- NA
scbi.sub$x0 <- scbi.sub$basal
scbi.sub_list <- lapply(scbi.sub$tag, function(x){
scbi.sub[scbi.sub$tag == x, ]}) #separate each stem into separate dataframe
names(scbi.sub_list) <- scbi.sub$tag
dist_shift <- dist[-1] #get rid of x0 now that you've defined it
j=1
i=1
tree <- 60108
test <- simple[simple$tree1 == tree | simple$tree2 == tree, ] #filter by tree
#script
scbi.full2 <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/SCBI-ForestGEO-Data/tree_main_census/data/census-csv-files/scbi.full2.csv", stringsAsFactors=FALSE)
scbi.full2[5340, 3] <- 40874 #duplicated tag (above 10cm dbh)
scbi.full2 <- scbi.full2[scbi.full2$dbh>=100, ]#& !grepl("S", scbi.full2$codes), ]
scbi.sub <- scbi.full2[scbi.full2$tag %in% unique(simple$tree1), ] #this number won't match "trees" because some trees from scbi.sub are >30m apart from another tree
unique(simple$tree1)
scbi.full2$tag %in% unique(simple$tree1)
View(simple)
View(trees)
#script
scbi.full2 <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/SCBI-ForestGEO-Data/tree_main_census/data/census-csv-files/scbi.full2.csv", stringsAsFactors=FALSE)
scbi.full2[5340, 3] <- 40874 #duplicated tag (above 10cm dbh)
scbi.full2 <- scbi.full2[scbi.full2$dbh>=100, ]#& !grepl("S", scbi.full2$codes), ]
trees <- scbi.full2[c(3,7,8)]
View(trees)
rownames(trees) <- trees[,1]
?t
?combn
library(vegan)
d <- vegdist(trees, method="euclidean") #calculate distance between one tree and all the other trees using Pythagorean theorem
m <- data.frame(t(combn(trees$tag,2)), as.numeric(d)) #put in df format
View(m)
#m <- data.frame(t(combn(rownames(trees),2)), as.numeric(d))
names(m) <- c("tree1", "tree2", "distance")
simple <- m[m$distance<=30, ] #only include distances of 30m or less
View(scbi.full2)
trees <- scbi.full2[c(2,7,8)] #if no multistems, could do c(3,7,8)
rownames(trees) <- trees[,1]
trees <- trees[, -1]
View(trees)
library(vegan)
d <- vegdist(trees, method="euclidean") #calculate distance between one tree and all the other trees using Pythagorean theorem
m <- data.frame(t(combn(trees$tag,2)), as.numeric(d)) #put in df format
#m <- data.frame(t(combn(rownames(trees),2)), as.numeric(d))
names(m) <- c("tree1", "tree2", "distance")
simple <- m[m$distance<=30, ] #only include distances of 30m or less
simple <- simple[order(simple$tree1, simple$distance), ] #sort by tree and distance
simple$tree1 <- as.character(simple$tree1)
simple$tree2 <- as.character(simple$tree2)
simple$tree1 <- as.numeric(simple$tree1)
simple$tree2 <- as.numeric(simple$tree2)
d <- vegdist(trees, method="euclidean") #calculate distance between one tree and all the other trees using Pythagorean theorem
m <- data.frame(t(combn(rownames(trees))), as.numeric(d)) #put in df format
names(m) <- c("tree1", "tree2", "distance")
simple <- m[m$distance<=30, ] #only include distances of 30m or less
simple <- simple[order(simple$tree1, simple$distance), ] #sort by tree and distance
simple$tree1 <- as.character(simple$tree1)
simple$tree2 <- as.character(simple$tree2)
simple$tree1 <- as.numeric(simple$tree1)
simple$tree2 <- as.numeric(simple$tree2)
d <- vegdist(trees, method="euclidean") #calculate distance between one tree and all the other trees using Pythagorean theorem
m <- data.frame(t(combn(rownames(trees),2)), as.numeric(d)) #put in df format
names(m) <- c("tree1", "tree2", "distance")
simple <- m[m$distance<=30, ] #only include distances of 30m or less
simple <- simple[order(simple$tree1, simple$distance), ] #sort by tree and distance
simple$tree1 <- as.character(simple$tree1)
simple$tree2 <- as.character(simple$tree2)
simple$tree1 <- as.numeric(simple$tree1)
simple$tree2 <- as.numeric(simple$tree2)
scbi.sub <- scbi.full2[scbi.full2$tag %in% unique(simple$tree1), ] #this number won't match "trees" because some trees from scbi.full2 are >30m apart from another tree
scbi.sub <- scbi.full2[scbi.full2$stemID %in% unique(simple$tree1), ] #this number won't match "trees" because some trees from scbi.full2 are >30m apart from another tree
scbi.sub <- scbi.sub[c(3,7,8,11)]
scbi.sub$dbh <- scbi.sub$dbh/10 #dbh needs to be in cm for basal area equation
scbi.sub$basal <- (pi*(scbi.sub$dbh/2)^2)*0.0001
dist <- seq(0,30, by=0.5)
dist <- gsub("^", "x", dist)
scbi.sub[, dist] <- NA
scbi.sub$x0 <- scbi.sub$basal
scbi.sub_list <- lapply(scbi.sub$tag, function(x){
scbi.sub[scbi.sub$tag == x, ]}) #separate each stem into separate dataframe
names(scbi.sub_list) <- scbi.sub$tag
dist_shift <- dist[-1] #get rid of x0 now that you've defined it
tree <- 71110
tree <- 7110
View(scbi.sub)
scbi.sub <- scbi.full2[scbi.full2$stemID %in% unique(simple$tree1), ] #this number won't match "trees" because some trees from scbi.full2 are >30m apart from another tree
View(scbi.sub)
#script
library(data.table)
setnames(scbi.full2, old="StemTag", new="stemtag")
scbi.sub <- scbi.full2[scbi.full2$stemID %in% unique(simple$tree1), ] #this number won't match "trees" because some trees from scbi.full2 are >30m apart from another tree
scbi.sub <- scbi.sub[c(3,4,7,8,11)]
scbi.sub$dbh <- scbi.sub$dbh/10 #dbh needs to be in cm for basal area equation
scbi.sub$basal <- (pi*(scbi.sub$dbh/2)^2)*0.0001
dist <- seq(0,30, by=0.5)
dist <- gsub("^", "x", dist)
scbi.sub[, dist] <- NA
scbi.sub$x0 <- scbi.sub$basal
scbi.sub_list <- lapply(scbi.sub$tag, function(x){
scbi.sub[scbi.sub$tag == x, ]}) #separate each stem into separate dataframe
names(scbi.sub_list) <- scbi.sub$tag
dist_shift <- dist[-1] #get rid of x0 now that you've defined it
View(scbi.sub)
View(scbi.sub_list)
scbi.sub <- scbi.sub[c(2,3,4,7,8,11)]
scbi.sub$dbh <- scbi.sub$dbh/10 #dbh needs to be in cm for basal area equation
scbi.sub$basal <- (pi*(scbi.sub$dbh/2)^2)*0.0001
dist <- seq(0,30, by=0.5)
dist <- gsub("^", "x", dist)
scbi.sub[, dist] <- NA
scbi.sub$x0 <- scbi.sub$basal
scbi.sub_list <- lapply(scbi.sub$stemID, function(x){
scbi.sub[scbi.sub$stemID == x, ]}) #separate each stem into separate dataframe
names(scbi.sub_list) <- scbi.sub$stemID
dist_shift <- dist[-1] #get rid of x0 now that you've defined it
View(scbi.sub)
scbi.sub <- scbi.full2[scbi.full2$stemID %in% unique(simple$tree1), ] #this number won't match "trees" because some trees from scbi.full2 are >30m apart from another tree
scbi.sub <- scbi.sub[c(2,3,4,7,8,11)]
scbi.sub$dbh <- scbi.sub$dbh/10 #dbh needs to be in cm for basal area equation
scbi.sub$basal <- (pi*(scbi.sub$dbh/2)^2)*0.0001
dist <- seq(0,30, by=0.5)
dist <- gsub("^", "x", dist)
scbi.sub[, dist] <- NA
scbi.sub$x0 <- scbi.sub$basal
scbi.sub_list <- lapply(scbi.sub$stemID, function(x){
scbi.sub[scbi.sub$stemID == x, ]}) #separate each stem into separate dataframe
names(scbi.sub_list) <- scbi.sub$stemID
dist_shift <- dist[-1] #get rid of x0 now that you've defined it
View(scbi.sub_list)
test <- simple[simple$tree1 == tree | simple$tree2 == tree, ] #filter by tree
test <- test[order(test$distance), ] #order by distance
View(test)
sapply(1:nrow(test), function(x){
test$diff <- ifelse(test[x,1] == tree, test[x,2],
ifelse(test[x,2] == tree, test[x,1], test$diff))})
test$basal_diff <- scbi.sub$basal[match(test$diff, scbi.sub$stemID)]
View(test)
sapply(1:nrow(test), function(x){
test$diff <- ifelse(test[x,1] == tree, test[x,2],
ifelse(test[x,2] == tree, test[x,1], test$diff))})
test$basal_diff <- scbi.sub$basal[match(test$diff, scbi.sub$stemID)]
test$diff <- NULL
sapply(1:nrow(test), function(x){
test$diff <- ifelse(test[x,1] == tree, test[x,2],
ifelse(test[x,2] == tree, test[x,1], test$diff))})
sapply(1:nrow(test), function(x){
test$diff <- ifelse(test[x,1] == tree, test[x,2],
ifelse(test[x,2] == tree, test[x,1], test$diff))})
sapply(1:nrow(test), function(x){
test$diff <- ifelse(test[x,1] == tree, test[x,2], ifelse(test[x,2] == tree, test[x,1], test$diff))})
test$diff <- sapply(1:nrow(test), function(x){
ifelse(test[x,1] == tree, test[x,2],
ifelse(test[x,2] == tree, test[x,1], test$diff))})
View(test)
test$basal_diff <- scbi.sub$basal[match(test$diff, scbi.sub$stemID)]
View(test)
xmachina <- scbi.full2[scbi.full2$tag == 60108, ]
View(xmachina)
library(data.table)
scbi.full2 <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/SCBI-ForestGEO-Data/tree_main_census/data/census-csv-files/scbi.full2.csv", stringsAsFactors=FALSE)
setnames(scbi.full2, old="StemTag", new="stemtag")
scbi.full2[5340, 3] <- 40874 #duplicated tag (above 10cm dbh), fixed in 2018 data
scbi.full2[7112, 7] <- 110.0 #60108 stem 2 for some reason has coordinates that
scbi.full2[7112, 8] <- 95.5 #differ from stem 1. These lines of code fix that.
scbi.full2 <- scbi.full2[scbi.full2$dbh>=100, ]#& !grepl("S", scbi.full2$codes), ]
trees <- scbi.full2[c(2,7,8)] #IMPORTANT: working off stemID here
rownames(trees) <- trees[,1]
trees <- trees[, -1]
library(vegan)
d <- vegdist(trees, method="euclidean") #calculate distance between one tree and all the other trees using Pythagorean theorem
m <- data.frame(t(combn(rownames(trees),2)), as.numeric(d)) #put in df format
names(m) <- c("tree1", "tree2", "distance")
simple <- m[m$distance<=30, ] #only include distances of 30m or less
simple <- simple[order(simple$tree1, simple$distance), ] #sort by tree and distance
simple$tree1 <- as.character(simple$tree1)
simple$tree2 <- as.character(simple$tree2)
simple$tree1 <- as.numeric(simple$tree1)
simple$tree2 <- as.numeric(simple$tree2)
scbi.sub <- scbi.full2[scbi.full2$stemID %in% unique(simple$tree1), ] #this number won't match "trees" because some trees from scbi.full2 are >30m apart from another tree
scbi.sub <- scbi.sub[c(2,3,4,7,8,11)]
scbi.sub$dbh <- scbi.sub$dbh/10 #dbh needs to be in cm for basal area equation
scbi.sub$basal <- (pi*(scbi.sub$dbh/2)^2)*0.0001
dist <- seq(0,30, by=0.5)
dist <- gsub("^", "x", dist)
scbi.sub[, dist] <- NA
scbi.sub$x0 <- scbi.sub$basal
scbi.sub_list <- lapply(scbi.sub$stemID, function(x){
scbi.sub[scbi.sub$stemID == x, ]}) #separate each stem into separate dataframe
names(scbi.sub_list) <- scbi.sub$stemID
dist_shift <- dist[-1] #get rid of x0 now that you've defined it
tree <- 7110
test <- simple[simple$tree1 == tree | simple$tree2 == tree, ] #filter by tree
test <- test[order(test$distance), ] #order by distance
test$diff <- sapply(1:nrow(test), function(x){
ifelse(test[x,1] == tree, test[x,2],
ifelse(test[x,2] == tree, test[x,1], test$diff))})
test$basal_diff <- scbi.sub$basal[match(test$diff, scbi.sub$stemID)]
test_list <- lapply(unique(test$diff), function(x){
test[test$diff == x, ] }) #split test into separate df
names(test_list) <- unique(test$diff)
View(test)
z <- scbi.sub_list[[grep(paste0("^",tree,"$"), names(scbi.sub_list))]]
View(z)
z$x0 <- ifelse(test$distance == 0, test$basal_diff, z$x0)
z$x0 <- ifelse(test$distance == 0, test$basal_diff[[1]], z$x0)
View(test)
test$basal_diff[1]
z$x0 <- ifelse(test$distance == 0, test$basal_diff[1], z$x0)
z$x0 <- ifelse(test$distance[1] == 0, test$basal_diff[1], z$x0)
View(z)
dist <- gsub("^", "m_dist", dist)
dist <- seq(0,30, by=0.5)
dist <- gsub("^", "m_dist", dist)
dist <- seq(0,30, by=0.5)
dist <- gsub("^", "m_dist_", dist)
dist <- seq(0,30, by=0.5)
dist <- gsub("^", "dist.m_", dist)
inc_num <- gsub("dist.m_", "", inc)
dist_shift <- dist[-1] #get rid of x0 now that you've defined it
i=1
inc <- dist_shift[[i]]
inc_num <- gsub("dist.m_", "", inc)
inc_num <- as.numeric(inc_num)
inc_num_prev <- inc_num - 0.5
inc_prev <- gsub("^", "dist.m_", inc_num_prev)
View(scbi.sub)
tree=30145
test <- simple[simple$tree1 == tree | simple$tree2 == tree, ] #filter by tree
View(scbi.sub)
tree=84
test <- simple[simple$tree1 == tree | simple$tree2 == tree, ] #filter by tree
test <- test[order(test$distance), ] #order by distance
test$diff <- sapply(1:nrow(test), function(x){
ifelse(test[x,1] == tree, test[x,2],
ifelse(test[x,2] == tree, test[x,1], test$diff))})
#get basal area for tags that aren't the focal tree
test$basal_diff <- scbi.sub$basal[match(test$diff, scbi.sub$stemID)]
test_list <- lapply(unique(test$diff), function(x){
test[test$diff == x, ] }) #split test into separate df
names(test_list) <- unique(test$diff)
z <- scbi.sub_list[[grep(paste0("^",tree,"$"), names(scbi.sub_list))]]
View(test)
View(z)
z$x0 <- ifelse(test$distance[1] == 0, test$basal_diff[1], z$x0) #this line of code follows Tepleys' intial calculation as described above in line 7.
View(z)
library(data.table)
scbi.full2 <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/SCBI-ForestGEO-Data/tree_main_census/data/census-csv-files/scbi.full2.csv", stringsAsFactors=FALSE)
setnames(scbi.full2, old="StemTag", new="stemtag")
scbi.full2[5340, 3] <- 40874 #duplicated tag (above 10cm dbh), fixed in 2018 data
scbi.full2[7112, 7] <- 110.0 #60108 stem 2 for some reason has coordinates which
scbi.full2[7112, 8] <- 95.5 #differ from stem 1. These lines of code fix that.
scbi.full2 <- scbi.full2[scbi.full2$dbh>=100, ]#& !grepl("S", scbi.full2$codes), ]
trees <- scbi.full2[c(2,7,8)] #IMPORTANT: working off stemID here
rownames(trees) <- trees[,1]
trees <- trees[, -1]
library(vegan)
d <- vegdist(trees, method="euclidean") #calculate distance between one tree and all the other trees using Pythagorean theorem
m <- data.frame(t(combn(rownames(trees),2)), as.numeric(d)) #put in df format
names(m) <- c("tree1", "tree2", "distance")
simple <- m[m$distance<=30, ] #only include distances of 30m or less
simple <- simple[order(simple$tree1, simple$distance), ] #sort by tree and distance
# simple$tree1 <- as.character(simple$tree1)
# simple$tree2 <- as.character(simple$tree2)
simple$tree1 <- as.numeric(as.character(simple$tree1))
simple$tree2 <- as.numeric(as.character(simple$tree2))
scbi.sub <- scbi.full2[scbi.full2$stemID %in% unique(simple$tree1), ] #this number won't match "trees" because some trees from scbi.full2 are >30m apart from another tree
scbi.sub <- scbi.sub[c(2,3,4,7,8,11)]
scbi.sub$dbh <- scbi.sub$dbh/10 #dbh needs to be in cm for basal area equation
scbi.sub$basal <- (pi*(scbi.sub$dbh/2)^2)*0.0001
dist <- seq(0,30, by=0.5)
dist <- gsub("^", "dist.m_", dist)
scbi.sub[, dist] <- NA
scbi.sub$x0 <- scbi.sub$basal
scbi.sub_list <- lapply(scbi.sub$stemID, function(x){
scbi.sub[scbi.sub$stemID == x, ]}) #separate each stem into separate dataframe
names(scbi.sub_list) <- scbi.sub$stemID
dist_shift <- dist[-1] #get rid of x0 now that you've defined it
View(trees)
View(d)
d
library(MASS)
?dredge
install.packages("MuMln")
library(pupR)
install.packages("pupR")
.onAttach <- function(libname, pkgname) {
packageStartupMessage('Welcome to pupR! Pictures taken from pixabay.com')
# return
invisible(TRUE)
}
install.packages("devtools")
library(devtools)
install_github("melissanjohnson/pupR")
pupR()
library(pupR)
pupR()
replicate(n, pupR(), simplify=FALSE)
replicate(15, pupR(), simplify=FALSE)
install.packages("MuMIn")
#the following ranking and running can also be done in one go with the dredge function from the "MuMln" package. However, it doesn't allow me, for example, to subset out model runs that only include fixed effects, and filtering to only include model runs that contain year.
library(MUMIn)
#the following ranking and running can also be done in one go with the dredge function from the "MuMln" package. However, it doesn't allow me, for example, to subset out model runs that only include fixed effects, and filtering to only include model runs that contain year.
library(MuMIn)
?dredge
library(pointRes)
library(dplR)
library(data.table)
##4a. canopy ####
setwd("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/SCBI-ForestGEO-Data/tree_cores/chronologies/current_chronologies/complete/separated by canopy position/canopy_cores")
dirs_can <- dir("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/SCBI-ForestGEO-Data/tree_cores/chronologies/current_chronologies/complete/separated by canopy position/canopy_cores", pattern = "_canopy.rwl")
dirs_can <- dirs_can[dirs_can != "frni_canopy.rwl" & dirs_can != "frni_drop_canopy.rwl" & dirs_can != "caco_drop_canopy.rwl"]
sp_can <- gsub("_drop_canopy.rwl", "", dirs_can)
canopy <- list()
canopy_table <- NULL
for (i in seq(along=dirs_can)){
for (j in seq(along=sp_can)){
if (i==j){
file <- dirs_can[[i]]
rings <- read.rwl(file) #read in rwl file
area <- bai.in(rings) #convert to bai.in
testr <- res.comp(area, nb.yrs=5, res.thresh.neg = 30, series.thresh = 50) #get resilience metrics
canopy[[i]] <- testr
testr_table <- data.frame(testr$out)
testr_table <- testr_table[testr_table$nb.series > 4, ] #remove where there are < 4 series
testr_table$sp <- sp_can[[j]]
testr_table$position <- "canopy"
canopy_table <- rbind(canopy_table, testr_table)
}
values <- paste0(sp_can, "_can_res")
names(canopy) <- values
##4b. subcanopy ####
setwd("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/SCBI-ForestGEO-Data/tree_cores/chronologies/current_chronologies/complete/separated by canopy position/subcanopy_cores")
dirs_subcan <- dir("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/SCBI-ForestGEO-Data/tree_cores/chronologies/current_chronologies/complete/separated by canopy position/subcanopy_cores", pattern = "_subcanopy.rwl")
#dirs_subcan <- dirs_subcan[dirs_subcan != "frni_drop_subcanopy.rwl" & dirs_subcan != "caco_drop_subcanopy.rwl"]
sp_subcan <- gsub("_drop_subcanopy.rwl", "", dirs_subcan)
subcanopy <- list()
subcanopy_table <- NULL
for (i in seq(along=dirs_subcan)){
for (j in seq(along=sp_subcan)){
if (i==j){
file <- dirs_subcan[[i]]
rings <- read.rwl(file) #read in rwl file
area <- bai.in(rings) #convert to bai.in
test <- res.comp(area, nb.yrs=5, res.thresh.neg = 30, series.thresh = 50) #get resilience metrics
subcanopy[[i]] <- test
test_table <- data.frame(test$out)
test_table <- test_table[test_table$nb.series > 4, ] #remove where there are < 4 series
test_table$sp <- sp_subcan[[j]]
test_table$position <- "subcanopy"
subcanopy_table <- rbind(subcanopy_table, test_table)
}
values_sub <- paste0(sp_subcan, "_subcan_res")
names(subcanopy) <- values_sub
##4c. df for pointer years of all trees combined ####
full_ind <- rbind(canopy_table, subcanopy_table) #full table of indices for canopy and subcanopy cores
pointers <- full_ind[full_ind$nature == -1, ]
library(dplyr)
years_point <- count(pointers, vars=year) #counts the occurrences of each unique year
colnames(years_point) <- c("yr", "n.pointer")
years_point <- years_point[order(years_point$n.pointer, decreasing=TRUE), ]
setwd("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/McGregor_climate-sensitivity-variation")
#write.csv(pointers, "occurrence_of_pointer_yrs.csv", row.names=FALSE)
##4d. resistance metrics for all trees ####
neil_list <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/McGregor_climate-sensitivity-variation/core_list_for_neil.csv", stringsAsFactors = FALSE)
neil_list$tag <- paste0("X", neil_list$tag) #to match the colnames of can_resist below
pointer_years <- years_point$yr[c(1:2,5)] #from above in #4c
##canopy ####
#this loop says, for the different species in the list "canopy" (names(canopy)), create a dataframe of only the resistance index. Make a list of the colnames, which are the individual trees. Then, assign species identifiers for each one from Neil's core list, subset by the defined pointer years, and melt the data before rbinding.
tag_n <- names(canopy)
trees_canopy <- NULL
for (i in seq(along=1:length(tag_n))){
can_resist <- data.frame(canopy[[i]]$resist)
years <- rownames(can_resist)
colnames(can_resist) <- gsub("A", "", colnames(can_resist))
tree_series <- colnames(can_resist)
# for (j in seq(along=tree_series)){
#  trees <- tree_series[[j]]
ind <- can_resist
ind_neil <- neil_list[neil_list$tag %in% tree_series, ]
#  colnames(ind) <- trees
ind$year <- years
ind$sp <- unique(ind_neil$sp)
ind$position <- "canopy"
ind <- ind[ind$year %in% pointer_years, ]
change <- melt(ind)
setnames(change, old=c("variable", "value"), new=c("tree", "resist.value"))
change$tree <- gsub("X", "", change$tree)
change$tree <- gsub("^0", "", change$tree)
trees_canopy <- rbind(trees_canopy, change)
}
##subcanopy ####
#this loop says, for the different species in the list "subcanopy" (names(subcanopy)), create a dataframe of only the resistance index. Make a list of the colnames, which are the individual trees. Then, assign species identifiers for each one from Neil's core list, subset by the defined pointer years, and melt the data before rbinding.
tag_n <- names(subcanopy)
trees_subcanopy <- NULL
for (i in seq(along=1:length(tag_n))){
sub_resist <- data.frame(subcanopy[[i]]$resist)
years <- rownames(sub_resist)
colnames(sub_resist) <- gsub("A", "", colnames(sub_resist))
tree_series <- colnames(sub_resist)
# for (j in seq(along=tree_series)){
#  trees <- tree_series[[j]]
ind <- sub_resist
ind_neil <- neil_list[neil_list$tag %in% tree_series, ]
#  colnames(ind) <- trees
ind$year <- years
ind$sp <- unique(ind_neil$sp)
ind$position <- "subcanopy"
ind <- ind[ind$year %in% pointer_years, ]
change <- melt(ind)
setnames(change, old=c("variable", "value"), new=c("tree", "resist.value"))
change$tree <- gsub("X", "", change$tree)
change$tree <- gsub("^0", "", change$tree)
trees_subcanopy <- rbind(trees_subcanopy, change)
}
##rbind together ####
trees_all <- rbind(trees_canopy, trees_subcanopy)
trees_all$year <- as.numeric(trees_all$year)
#subset out NAs for resistance values (not necessary, bc lmm will automatically exclude them)
trees_all <- trees_all[!is.na(trees_all$resist.value), ]
##4e. determine proportion of resistance values per sp ####
prop <- data.frame("sp" = unique(trees_all$sp))
prop$value.over1 <- NA
prop$can.value.over1 <- NA
prop$sub.value.over1 <- NA
trees_all.sp <- unique(trees_all$sp)
for (i in seq(along=prop$sp)){
for (j in seq(along=unique(trees_all.sp))){
if (i==j){
temp <- trees_all[trees_all$sp == trees_all.sp[[j]] & trees_all$resist.value>=1, ]
temp <- temp[!is.na(temp$resist.value), ]
prop$value.over1[[i]] <- nrow(temp)
prop$can.value.over1[[i]] <- nrow(temp[temp$position == "canopy", ])
prop$sub.value.over1[[i]] <- nrow(temp[temp$position == "subcanopy", ])
}
##4f. add in turgor loss point values ####
#add in tlp values (from Krista github issue #6 https://github.com/SCBI-ForestGEO/McGregor_climate-sensitivity-variation/issues/6)
turgor <- data.frame("sp" = c("cagl", "caovl", "fagr", "fram", "juni", "litu", "pist", "qual", "qupr", "quru", "quve", "caco", "cato", "frni"), "tlp" = c(-2.1282533, -2.24839333, -2.57164, -2.1012133, -2.75936, -1.9212933, NA, -2.58412, -2.3601733, -2.6395867, -2.3879067, -2.1324133, -2.31424, NA))
trees_all$tlp <- turgor$tlp[match(trees_all$sp, turgor$sp)]
#tlp for pist is NA. Running the models below with this gives the min(AICc) for lmm.combined. Removing pist, however (because of the tlp NA), and running AICc and anova shows the best model to be lmm.random.
#trees_all <- trees_all[!trees_all$sp == "pist", ]
##4g. add in ring porosity qualifications ####
ring_porosity <- data.frame("sp" = c("cagl",  "caovl", "cato", "fagr", "fram", "juni",  "litu",  "pist",  "qual",  "qupr",  "quru",  "quve", "caco", "frni"), "rp" = c("ring", "ring", "ring", "diffuse", "ring", "semi-ring", "diffuse", NA, "ring", "ring", "ring", "ring", "ring", "ring"))
trees_all$rp <- ring_porosity$rp[match(trees_all$sp, ring_porosity$sp)]
##4h. add in elevation data ####
elev <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/SCBI-ForestGEO-Data/spatial_data/elevation/full_stem_elevation_2013.csv")
trees_all$elev_m <- elev$dem_sigeo[match(trees_all$tree, elev$tag)]
library(lme4)
library(AICcmodavg)
library(car)
#the following ranking and running can also be done in one go with the dredge function from the "MuMln" package. However, it doesn't allow me, for example, to subset out model runs that only include fixed effects, and filtering to only include model runs that contain year.
library(MuMIn)
dredge(beta="sd", fixed = "effects")
effects <- c("position", "tlp", "rp", "elev_m", "(1 | year)", "(1 | sp / tree)")
dredge(global.model=lmer, beta="sd", fixed = "effects")
dredge(global.model="lmer", beta="sd", fixed = "effects")
nobs(fm1)
