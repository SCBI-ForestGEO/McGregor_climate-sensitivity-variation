# check <- dbh[dbh$dbh_old == 0, ] #check if any tree was missed
trees_all$dbh_old <- dbh$dbh_old
trees_all$dbh_old <- ifelse(trees_all$dbh_old < 0, 0, trees_all$dbh_old)
trees_all$dbh_old <- ifelse(trees_all$dbh_old > 0, trees_all$dbh_old/10, trees_all$dbh_old)
trees_all$dbh_ln <- ifelse(trees_all$dbh_old == 0, NA, ln(trees_all$dbh_old))
##5f. add in tree heights ####
## taken from the canopy_heights script
trees_all$height_ln <- ifelse(trees_all$sp == "caco", (0.55+0.766*trees_all$dbh_ln),
ifelse(trees_all$sp == "cagl", (0.652+0.751*trees_all$dbh_ln),
ifelse(trees_all$sp == "caovl", (0.9+0.659*trees_all$dbh_ln),
ifelse(trees_all$sp == "cato", (0.879+0.668*trees_all$dbh_ln),
ifelse(trees_all$sp == "fagr", (0.513+0.712*trees_all$dbh_ln),
ifelse(trees_all$sp == "litu", (1.57+0.488*trees_all$dbh_ln),
ifelse(trees_all$sp == "quru", (1.13+0.54*trees_all$dbh_ln),
(0.849+0.659*trees_all$dbh_ln))))))))
##5g. remove all NAs ####
trees_all <- trees_all[complete.cases(trees_all), ]
##5h. remove resistance values >2 ####
trees_all <- trees_all[trees_all$resist.value <=2,]
##5i. make subsets for individual years, combine all to list ####
# x1964 <- trees_all[trees_all$year == 1964, ]
x1966 <- trees_all[trees_all$year == 1966, ]
x1977 <- trees_all[trees_all$year == 1977, ]
x1999 <- trees_all[trees_all$year == 1999, ]
model_df <- list(trees_all, x1966, x1977, x1999)
##############################################################################################
#6. mixed effects model for output of #5. ####
library(lme4)
library(AICcmodavg) #aictab function
library(car)
library(piecewiseSEM) #for R^2 values for all model outputs in a list
library(MuMIn) #for R^2 values of one model output
library(stringr)
##6a. Determine best model to use with AICc ####
#define response and effects
response <- gsub(" ~.*", "", summary_mod_vars_all[[h]])
effects <- unlist(strsplit(summary_mod_vars_all[[h]], "\\+|~ "))[-1]
# all fixed effects <- c("position", "tlp", "rp", "elev_m", "dbh_ln", "height_ln", "year")
#create all combinations of random / fixed effects
effects_comb <-
unlist( sapply( seq_len(length(effects)),
function(i) {
apply( combn(effects,i), 2, function(x) paste(x, collapse = "+"))
}))
# pair response with effect and sub out combinations that don't include random effects
#in general, if two variables are >70% correlated, you can toss one of them without significantly affecting the results
var_comb <- expand.grid(response, effects_comb)
var_comb <- var_comb[grepl("1", var_comb$Var2), ] #only keep in fixed/random combos
var_comb <- var_comb[grepl("year", var_comb$Var2), ] #keep year in for drought sake
# formulas for all combinations. $Var1 is the response, and $Var2 is the effect
# for good stats, you should have no more total parameters than 1/10th the number of observations in your dataset
formula_vec <- sprintf("%s ~ %s", var_comb$Var1, var_comb$Var2)
# create list of model outputs
lmm_all <- lapply(formula_vec, function(x){
fit1 <- lmer(x, data = model_df[[i]], REML=FALSE,
control = lmerControl(optimizer ="Nelder_Mead"))
return(fit1)
})
names(lmm_all) <- formula_vec
var_aic <- aictab(lmm_all, second.ord=TRUE, sort=TRUE) #rank based on AICc
r <- rsquared(lmm_all) #gives R^2 values for models. "Marginal" is the R^2 for just the fixed effects, "Conditional" is the R^2 for everything.
##6ai. test predictions for paper ####
## create table to store results
summary_models <- data.frame(
"prediction" = c("1.0", "1.1", "1.2a", "1.2b", "1.2c1, 1.3a1", "1.2c2", "1.3b1", "1.3a2", "1.3b2", "2.1", "2.2"),
"model_vars_all_years" =
c("resist.value ~ dbh_ln+year+(1|sp/tree)",
"resist.value ~ height_ln+year+(1|sp/tree)",
"resist.value ~ position+year+(1|sp/tree)",
"resist.value ~ position+height_ln+year+(1|sp/tree)",
"resist.value ~ elev_m+height_ln+year+(1|sp/tree)",
"resist.value ~ elev_m*height_ln+height_ln+year+(1|sp/tree)",
"resist.value ~ distance_ln+height_ln+year+(1|sp/tree)",
"resist.value ~ distance_ln*height_ln+height_ln+year+(1|sp/tree)",
"resist.value ~ tlp+height_ln+year+(1|sp/tree)",
"resist.value ~ rp+height_ln+year+(1|sp/tree)"),
"null_model_all_years" = NA,
"model_vars_sep_years" = NA,
"null_model_sep_years" = NA,
"response_predict" = c("-", "-", "canopy<subcanopy", "canopy<subcanopy", "+", "+", "-", "+", "-", "-", "ring>diffuse"),
"response_actual" = NA,
"dAIC_all_years" = NA,
"dAIC_1964-1966" = NA,
"dAIC_1977" = NA,
"dAIC_1999" = NA)
library(dplyr)
# change factor columns to character
summary_models %>% mutate_if(is.factor, as.character) -> summary_models
# fill in other columns
summary_models[c(1:3), 3] <- "resist.value ~ year+(1|sp/tree)"
summary_models[c(4:11), 3] <- "resist.value ~ height_ln+year+(1|sp/tree)"
summary_models$model_vars_sep_years <- gsub("year\\+|/tree", "", summary_models$model_vars_all_years)
summary_models$null_model_sep_years <- gsub("year\\+|/tree", "", summary_models$null_model_all_years)
#define vectors to be used in loop
summary_mod_vars_all <- summary_models$model_vars_all_years
summary_mod_vars_sep <- summary_models$model_vars_sep_years
summary_mod_null_all <- summary_models$null_model_all_years
summary_mod_null_sep <- summary_models$null_model_sep_years
##this loop goes through each mix of effects from each prediction (nrow(summary_models)), and runs those models for each of the datasets (all years and the three individual ones). For each iteration (44 total), it calculates dAIC (AIC of model with variable defined in model_vars columns minus the AIC of the null model).
for (i in seq_along(model_df)){
for (h in seq(along=summary_mod_vars_all)){
if (i==1){
#structure of creating the model strings come from 6a above.
response <- gsub(" ~.*", "", summary_mod_vars_all[[h]])
effects <- unlist(strsplit(summary_mod_vars_all[[h]], "\\+|~ "))[-1]
#create all combinations of random / fixed effects
effects_comb <-
unlist( sapply( seq_len(length(effects)),
function(i) {
apply( combn(effects,i), 2, function(x) paste(x, collapse = "+"))
}))
#make table
var_comb <- expand.grid(response, effects_comb)
var_comb <- var_comb[grepl("1", var_comb$Var2), ] #only keep in fixed/random combos
var_comb <- var_comb[grepl("year", var_comb$Var2), ] #keep year in for drought sake
} else {
#define response and effects
response <- gsub(" ~.*", "", summary_mod_vars_sep[[h]])
effects <- unlist(strsplit(summary_mod_vars_sep[[h]], "\\+|~ "))[-1]
# all fixed effects <- c("position", "tlp", "rp", "elev_m", "dbh_ln", "height_ln")
#create all combinations of random / fixed effects
effects_comb <-
unlist( sapply( seq_len(length(effects)),
function(i) {
apply( combn(effects,i), 2, function(x) paste(x, collapse = "+"))
}))
#=make table
var_comb <- expand.grid(response, effects_comb)
var_comb <- var_comb[grepl("1", var_comb$Var2), ] #only keep in fixed+random combos
}
#formulas for all combinations.
formula_vec <- sprintf("%s ~ %s", var_comb$Var1, var_comb$Var2)
# create list of model outputs
lmm_all <- lapply(formula_vec, function(x){
fit1 <- lmer(x, data = model_df[[i]], REML=FALSE,
control = lmerControl(optimizer ="Nelder_Mead"))
return(fit1)
})
names(lmm_all) <- formula_vec
var_aic <- aictab(lmm_all, second.ord=TRUE, sort=TRUE) #rank based on AICc
r <- rsquared(lmm_all) #gives R^2 values for models. "Marginal" is the R^2 for just the fixed effects, "Conditional" is the R^2 for everything.
#fill in table
if(i == 1){
var_aic_sub <- var_aic[var_aic$Modnames == summary_mod_vars_all[[h]], ]
var_aic_null <- var_aic[var_aic$Modnames == summary_mod_null_all[[h]], ]
summary_models[,8][[h]] <- var_aic_sub$Delta_AICc - var_aic_null$Delta_AICc
} else if (i == 2) {
var_aic_sub <- var_aic[var_aic$Modnames == summary_mod_vars_sep[[h]], ]
var_aic_null <- var_aic[var_aic$Modnames == summary_mod_null_sep[[h]], ]
summary_models[,9][[h]] <- var_aic_sub$Delta_AICc - var_aic_null$Delta_AICc
} else if (i == 3){
var_aic_sub <- var_aic[var_aic$Modnames == summary_mod_vars_sep[[h]], ]
var_aic_null <- var_aic[var_aic$Modnames == summary_mod_null_sep[[h]], ]
summary_models[,10][[h]] <- var_aic_sub$Delta_AICc - var_aic_null$Delta_AICc
} else if (i == 4){
var_aic_sub <- var_aic[var_aic$Modnames == summary_mod_vars_sep[[h]], ]
var_aic_null <- var_aic[var_aic$Modnames == summary_mod_null_sep[[h]], ]
summary_models[,11][[h]] <- var_aic_sub$Delta_AICc - var_aic_null$Delta_AICc
}
View(summary_models)
write.csv(summary_models, "manuscript/results.csv", row.names=FALSE)
i=1
summary_mod_vars_all
h=3
for (i in seq_along(model_df)){
for (h in seq(along=summary_mod_vars_all)){
if (i==1){
#structure of creating the model strings come from 6a above.
response <- gsub(" ~.*", "", summary_mod_vars_all[[h]])
effects <- unlist(strsplit(summary_mod_vars_all[[h]], "\\+|~ "))[-1]
#create all combinations of random / fixed effects
effects_comb <-
unlist( sapply( seq_len(length(effects)),
function(i) {
apply( combn(effects,i), 2, function(x) paste(x, collapse = "+"))
}))
#make table
var_comb <- expand.grid(response, effects_comb)
var_comb <- var_comb[grepl("1", var_comb$Var2), ] #only keep in fixed/random combos
var_comb <- var_comb[grepl("year", var_comb$Var2), ] #keep year in for drought sake
} else {
#define response and effects
response <- gsub(" ~.*", "", summary_mod_vars_sep[[h]])
effects <- unlist(strsplit(summary_mod_vars_sep[[h]], "\\+|~ "))[-1]
# all fixed effects <- c("position", "tlp", "rp", "elev_m", "dbh_ln", "height_ln")
#create all combinations of random / fixed effects
effects_comb <-
unlist( sapply( seq_len(length(effects)),
function(i) {
apply( combn(effects,i), 2, function(x) paste(x, collapse = "+"))
}))
#=make table
var_comb <- expand.grid(response, effects_comb)
var_comb <- var_comb[grepl("1", var_comb$Var2), ] #only keep in fixed+random combos
}
#formulas for all combinations.
formula_vec <- sprintf("%s ~ %s", var_comb$Var1, var_comb$Var2)
# create list of model outputs
lmm_all <- lapply(formula_vec, function(x){
fit1 <- lmer(x, data = model_df[[i]], REML=FALSE,
control = lmerControl(optimizer ="Nelder_Mead"))
return(fit1)
})
names(lmm_all) <- formula_vec
var_aic <- aictab(lmm_all, second.ord=TRUE, sort=TRUE) #rank based on AICc
r <- rsquared(lmm_all) #gives R^2 values for models. "Marginal" is the R^2 for just the fixed effects, "Conditional" is the R^2 for everything.
View(var_aic)
if (i==1){
#structure of creating the model strings come from 6a above.
response <- gsub(" ~.*", "", summary_mod_vars_all[[h]])
effects <- unlist(strsplit(summary_mod_vars_all[[h]], "\\+|~ "))[-1]
#create all combinations of random / fixed effects
effects_comb <-
unlist( sapply( seq_len(length(effects)),
function(i) {
apply( combn(effects,i), 2, function(x) paste(x, collapse = "+"))
}))
#make table
var_comb <- expand.grid(response, effects_comb)
var_comb <- var_comb[grepl("1", var_comb$Var2), ] #only keep in fixed/random combos
var_comb <- var_comb[grepl("year", var_comb$Var2), ] #keep year in for drought sake
} else {
#define response and effects
response <- gsub(" ~.*", "", summary_mod_vars_sep[[h]])
effects <- unlist(strsplit(summary_mod_vars_sep[[h]], "\\+|~ "))[-1]
# all fixed effects <- c("position", "tlp", "rp", "elev_m", "dbh_ln", "height_ln")
#create all combinations of random / fixed effects
effects_comb <-
unlist( sapply( seq_len(length(effects)),
function(i) {
apply( combn(effects,i), 2, function(x) paste(x, collapse = "+"))
}))
#=make table
var_comb <- expand.grid(response, effects_comb)
var_comb <- var_comb[grepl("1", var_comb$Var2), ] #only keep in fixed+random combos
}
#formulas for all combinations.
formula_vec <- sprintf("%s ~ %s", var_comb$Var1, var_comb$Var2)
# create list of model outputs
lmm_all <- lapply(formula_vec, function(x){
fit1 <- lmer(x, data = model_df[[i]], REML=FALSE,
control = lmerControl(optimizer ="Nelder_Mead"))
return(fit1)
})
names(lmm_all) <- formula_vec
var_aic <- aictab(lmm_all, second.ord=TRUE, sort=TRUE) #rank based on AICc
r <- rsquared(lmm_all) #gives R^2 values for models. "Marginal" is the R^2 for just the fixed effects, "Conditional" is the R^2 for everything.
View(var_aic)
##6aii. coefficients ####
best <- lmm_all[[2]]
coef(summary(best))[ , "Estimate"]
h=4
if (i==1){
#structure of creating the model strings come from 6a above.
response <- gsub(" ~.*", "", summary_mod_vars_all[[h]])
effects <- unlist(strsplit(summary_mod_vars_all[[h]], "\\+|~ "))[-1]
#create all combinations of random / fixed effects
effects_comb <-
unlist( sapply( seq_len(length(effects)),
function(i) {
apply( combn(effects,i), 2, function(x) paste(x, collapse = "+"))
}))
#make table
var_comb <- expand.grid(response, effects_comb)
var_comb <- var_comb[grepl("1", var_comb$Var2), ] #only keep in fixed/random combos
var_comb <- var_comb[grepl("year", var_comb$Var2), ] #keep year in for drought sake
} else {
#define response and effects
response <- gsub(" ~.*", "", summary_mod_vars_sep[[h]])
effects <- unlist(strsplit(summary_mod_vars_sep[[h]], "\\+|~ "))[-1]
# all fixed effects <- c("position", "tlp", "rp", "elev_m", "dbh_ln", "height_ln")
#create all combinations of random / fixed effects
effects_comb <-
unlist( sapply( seq_len(length(effects)),
function(i) {
apply( combn(effects,i), 2, function(x) paste(x, collapse = "+"))
}))
#=make table
var_comb <- expand.grid(response, effects_comb)
var_comb <- var_comb[grepl("1", var_comb$Var2), ] #only keep in fixed+random combos
}
#formulas for all combinations.
formula_vec <- sprintf("%s ~ %s", var_comb$Var1, var_comb$Var2)
# create list of model outputs
lmm_all <- lapply(formula_vec, function(x){
fit1 <- lmer(x, data = model_df[[i]], REML=FALSE,
control = lmerControl(optimizer ="Nelder_Mead"))
return(fit1)
})
names(lmm_all) <- formula_vec
var_aic <- aictab(lmm_all, second.ord=TRUE, sort=TRUE) #rank based on AICc
r <- rsquared(lmm_all) #gives R^2 values for models. "Marginal" is the R^2 for just the fixed effects, "Conditional" is the R^2 for everything.
View(var_aic)
##6aii. coefficients ####
best <- lmm_all[[4]]
coef(summary(best))[ , "Estimate"]
h=11
if (i==1){
#structure of creating the model strings come from 6a above.
response <- gsub(" ~.*", "", summary_mod_vars_all[[h]])
effects <- unlist(strsplit(summary_mod_vars_all[[h]], "\\+|~ "))[-1]
#create all combinations of random / fixed effects
effects_comb <-
unlist( sapply( seq_len(length(effects)),
function(i) {
apply( combn(effects,i), 2, function(x) paste(x, collapse = "+"))
}))
#make table
var_comb <- expand.grid(response, effects_comb)
var_comb <- var_comb[grepl("1", var_comb$Var2), ] #only keep in fixed/random combos
var_comb <- var_comb[grepl("year", var_comb$Var2), ] #keep year in for drought sake
} else {
#define response and effects
response <- gsub(" ~.*", "", summary_mod_vars_sep[[h]])
effects <- unlist(strsplit(summary_mod_vars_sep[[h]], "\\+|~ "))[-1]
# all fixed effects <- c("position", "tlp", "rp", "elev_m", "dbh_ln", "height_ln")
#create all combinations of random / fixed effects
effects_comb <-
unlist( sapply( seq_len(length(effects)),
function(i) {
apply( combn(effects,i), 2, function(x) paste(x, collapse = "+"))
}))
#=make table
var_comb <- expand.grid(response, effects_comb)
var_comb <- var_comb[grepl("1", var_comb$Var2), ] #only keep in fixed+random combos
}
#formulas for all combinations.
formula_vec <- sprintf("%s ~ %s", var_comb$Var1, var_comb$Var2)
# create list of model outputs
lmm_all <- lapply(formula_vec, function(x){
fit1 <- lmer(x, data = model_df[[i]], REML=FALSE,
control = lmerControl(optimizer ="Nelder_Mead"))
return(fit1)
})
names(lmm_all) <- formula_vec
var_aic <- aictab(lmm_all, second.ord=TRUE, sort=TRUE) #rank based on AICc
r <- rsquared(lmm_all) #gives R^2 values for models. "Marginal" is the R^2 for just the fixed effects, "Conditional" is the R^2 for everything.
View(var_aic)
##6aii. coefficients ####
best <- lmm_all[[4]]
coef(summary(best))[ , "Estimate"]
##6ai. test predictions for paper ####
## create table to store results
summary_models <- data.frame(
"prediction" = c("1.0", "1.1", "1.2a", "1.2b", "1.2c1, 1.3a1", "1.2c2", "1.3b1", "1.3a2", "1.3b2", "2.1", "2.2"),
"model_vars_all_years" =
c("resist.value ~ dbh_ln+year+(1|sp/tree)",
"resist.value ~ height_ln+year+(1|sp/tree)",
"resist.value ~ position+year+(1|sp/tree)",
"resist.value ~ position+height_ln+year+(1|sp/tree)",
"resist.value ~ elev_m+height_ln+year+(1|sp/tree)",
"resist.value ~ elev_m*height_ln+height_ln+year+(1|sp/tree)",
"resist.value ~ distance_ln+height_ln+year+(1|sp/tree)",
"resist.value ~ distance_ln*height_ln+height_ln+year+(1|sp/tree)",
"resist.value ~ tlp+height_ln+year+(1|sp/tree)",
"resist.value ~ rp+height_ln+year+(1|sp/tree)"),
"null_model_all_years" = NA,
"model_vars_sep_years" = NA,
"null_model_sep_years" = NA,
"response_predict" = c("-", "-", "canopy<subcanopy", "canopy<subcanopy", "+", "+", "-", "+", "-", "-", "ring>diffuse"),
"response_actual" = NA,
"dAIC_all_years" = NA,
"dAIC_1964-1966" = NA,
"dAIC_1977" = NA,
"dAIC_1999" = NA,
"notes" = NA)
library(dplyr)
# change factor columns to character
summary_models %>% mutate_if(is.factor, as.character) -> summary_models
# fill in other columns
summary_models[c(1:3), 3] <- "resist.value ~ year+(1|sp/tree)"
summary_models[c(4:11), 3] <- "resist.value ~ height_ln+year+(1|sp/tree)"
summary_models$model_vars_sep_years <- gsub("year\\+|/tree", "", summary_models$model_vars_all_years)
summary_models$null_model_sep_years <- gsub("year\\+|/tree", "", summary_models$null_model_all_years)
View(summary_models)
#define vectors to be used in loop
summary_mod_vars_all <- summary_models$model_vars_all_years
summary_mod_vars_sep <- summary_models$model_vars_sep_years
summary_mod_null_all <- summary_models$null_model_all_years
summary_mod_null_sep <- summary_models$null_model_sep_years
##this loop goes through each mix of effects from each prediction (nrow(summary_models)), and runs those models for each of the datasets (all years and the three individual ones). For each iteration (44 total), it calculates dAIC (AIC of model with variable defined in model_vars columns minus the AIC of the null model).
for (i in seq_along(model_df)){
for (h in seq(along=summary_mod_vars_all)){
if (i==1){
#structure of creating the model strings come from 6a above.
response <- gsub(" ~.*", "", summary_mod_vars_all[[h]])
effects <- unlist(strsplit(summary_mod_vars_all[[h]], "\\+|~ "))[-1]
#create all combinations of random / fixed effects
effects_comb <-
unlist( sapply( seq_len(length(effects)),
function(i) {
apply( combn(effects,i), 2, function(x) paste(x, collapse = "+"))
}))
#make table
var_comb <- expand.grid(response, effects_comb)
var_comb <- var_comb[grepl("1", var_comb$Var2), ] #only keep in fixed/random combos
var_comb <- var_comb[grepl("year", var_comb$Var2), ] #keep year in for drought sake
} else {
#define response and effects
response <- gsub(" ~.*", "", summary_mod_vars_sep[[h]])
effects <- unlist(strsplit(summary_mod_vars_sep[[h]], "\\+|~ "))[-1]
# all fixed effects <- c("position", "tlp", "rp", "elev_m", "dbh_ln", "height_ln")
#create all combinations of random / fixed effects
effects_comb <-
unlist( sapply( seq_len(length(effects)),
function(i) {
apply( combn(effects,i), 2, function(x) paste(x, collapse = "+"))
}))
#=make table
var_comb <- expand.grid(response, effects_comb)
var_comb <- var_comb[grepl("1", var_comb$Var2), ] #only keep in fixed+random combos
}
#formulas for all combinations.
formula_vec <- sprintf("%s ~ %s", var_comb$Var1, var_comb$Var2)
# create list of model outputs
lmm_all <- lapply(formula_vec, function(x){
fit1 <- lmer(x, data = model_df[[i]], REML=FALSE,
control = lmerControl(optimizer ="Nelder_Mead"))
return(fit1)
})
names(lmm_all) <- formula_vec
var_aic <- aictab(lmm_all, second.ord=TRUE, sort=TRUE) #rank based on AICc
r <- rsquared(lmm_all) #gives R^2 values for models. "Marginal" is the R^2 for just the fixed effects, "Conditional" is the R^2 for everything.
#fill in table
if(i == 1){
var_aic_sub <- var_aic[var_aic$Modnames == summary_mod_vars_all[[h]], ]
var_aic_null <- var_aic[var_aic$Modnames == summary_mod_null_all[[h]], ]
summary_models[,8][[h]] <- var_aic_null$Delta_AICc - var_aic_sub$Delta_AICc
} else if (i == 2) {
var_aic_sub <- var_aic[var_aic$Modnames == summary_mod_vars_sep[[h]], ]
var_aic_null <- var_aic[var_aic$Modnames == summary_mod_null_sep[[h]], ]
summary_models[,9][[h]] <- var_aic_null$Delta_AICc - var_aic_sub$Delta_AICc
} else if (i == 3){
var_aic_sub <- var_aic[var_aic$Modnames == summary_mod_vars_sep[[h]], ]
var_aic_null <- var_aic[var_aic$Modnames == summary_mod_null_sep[[h]], ]
summary_models[,10][[h]] <- var_aic_null$Delta_AICc - var_aic_sub$Delta_AICc
} else if (i == 4){
var_aic_sub <- var_aic[var_aic$Modnames == summary_mod_vars_sep[[h]], ]
var_aic_null <- var_aic[var_aic$Modnames == summary_mod_null_sep[[h]], ]
summary_models[,11][[h]] <- var_aic_null$Delta_AICc - var_aic_sub$Delta_AICc
}
View(summary_models)
#csv has a 1 in the title to make sure any notes in current file are not overwritten
write.csv(summary_models, "manuscript/results1.csv", row.names=FALSE)
?round
h
summary_models[,8][[h]] <- round(var_aic_null$Delta_AICc - var_aic_sub$Delta_AICc, digits=2)
View(summary_models)
summary_models[,9][[h]] <- round(var_aic_null$Delta_AICc - var_aic_sub$Delta_AICc, 2)
View(summary_models)
##this loop goes through each mix of effects from each prediction (nrow(summary_models)), and runs those models for each of the datasets (all years and the three individual ones). For each iteration (44 total), it calculates dAIC (AIC of model with variable defined in model_vars columns minus the AIC of the null model).
for (i in seq_along(model_df)){
for (h in seq(along=summary_mod_vars_all)){
if (i==1){
#structure of creating the model strings come from 6a above.
response <- gsub(" ~.*", "", summary_mod_vars_all[[h]])
effects <- unlist(strsplit(summary_mod_vars_all[[h]], "\\+|~ "))[-1]
#create all combinations of random / fixed effects
effects_comb <-
unlist( sapply( seq_len(length(effects)),
function(i) {
apply( combn(effects,i), 2, function(x) paste(x, collapse = "+"))
}))
#make table
var_comb <- expand.grid(response, effects_comb)
var_comb <- var_comb[grepl("1", var_comb$Var2), ] #only keep in fixed/random combos
var_comb <- var_comb[grepl("year", var_comb$Var2), ] #keep year in for drought sake
} else {
#define response and effects
response <- gsub(" ~.*", "", summary_mod_vars_sep[[h]])
effects <- unlist(strsplit(summary_mod_vars_sep[[h]], "\\+|~ "))[-1]
# all fixed effects <- c("position", "tlp", "rp", "elev_m", "dbh_ln", "height_ln")
#create all combinations of random / fixed effects
effects_comb <-
unlist( sapply( seq_len(length(effects)),
function(i) {
apply( combn(effects,i), 2, function(x) paste(x, collapse = "+"))
}))
#=make table
var_comb <- expand.grid(response, effects_comb)
var_comb <- var_comb[grepl("1", var_comb$Var2), ] #only keep in fixed+random combos
}
#formulas for all combinations.
formula_vec <- sprintf("%s ~ %s", var_comb$Var1, var_comb$Var2)
# create list of model outputs
lmm_all <- lapply(formula_vec, function(x){
fit1 <- lmer(x, data = model_df[[i]], REML=FALSE,
control = lmerControl(optimizer ="Nelder_Mead"))
return(fit1)
})
names(lmm_all) <- formula_vec
var_aic <- aictab(lmm_all, second.ord=TRUE, sort=TRUE) #rank based on AICc
r <- rsquared(lmm_all) #gives R^2 values for models. "Marginal" is the R^2 for just the fixed effects, "Conditional" is the R^2 for everything.
#fill in table
if(i == 1){
var_aic_sub <- var_aic[var_aic$Modnames == summary_mod_vars_all[[h]], ]
var_aic_null <- var_aic[var_aic$Modnames == summary_mod_null_all[[h]], ]
summary_models[,8][[h]] <- round(var_aic_null$Delta_AICc - var_aic_sub$Delta_AICc, 2)
} else if (i == 2) {
var_aic_sub <- var_aic[var_aic$Modnames == summary_mod_vars_sep[[h]], ]
var_aic_null <- var_aic[var_aic$Modnames == summary_mod_null_sep[[h]], ]
summary_models[,9][[h]] <- round(var_aic_null$Delta_AICc - var_aic_sub$Delta_AICc, 2)
} else if (i == 3){
var_aic_sub <- var_aic[var_aic$Modnames == summary_mod_vars_sep[[h]], ]
var_aic_null <- var_aic[var_aic$Modnames == summary_mod_null_sep[[h]], ]
summary_models[,10][[h]] <- round(var_aic_null$Delta_AICc - var_aic_sub$Delta_AICc, 2)
} else if (i == 4){
var_aic_sub <- var_aic[var_aic$Modnames == summary_mod_vars_sep[[h]], ]
var_aic_null <- var_aic[var_aic$Modnames == summary_mod_null_sep[[h]], ]
summary_models[,11][[h]] <- round(var_aic_null$Delta_AICc - var_aic_sub$Delta_AICc, 2)
}
View(summary_models)
