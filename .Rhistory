sap$dbh_nobark.cm <- sap$dbh_nobark.mm/10
sap$total_wood_area.cm2 <- pi*(sap$dbh_nobark.cm/2)^2
sap$sap_ratio <- sap$sap_area.cm2/sap$total_wood_area.cm2
#these equations are for getting the sapwood_area for the dbh df, which are then converted to sap_ratio for that df.
source_gist("524eade46135f6348140")
#DBH = mm, sap_area = cm^2
ggplot(data = sap, aes(x = log(DBH), y = log(sap_area.cm2))) +
stat_smooth_func(geom="text",method="lm",hjust=0.16, vjust=0.8,parse=TRUE) +
geom_smooth(method="lm", se=FALSE, color="black") +
geom_point(color = "#0c4c8a") +
theme_minimal() +
facet_wrap(vars(sp))
ggplot(data = sap, aes(x = log(DBH), y = log(sap_area.cm2))) +
stat_smooth_func(geom="text",method="lm",hjust=0.16, vjust=-1,parse=TRUE) +
geom_smooth(method="lm", se=FALSE, color="black") +
geom_point(color = "#0c4c8a") +
theme_minimal()
#original equations. I'm not sure what happened, but I think after changing some units, I forgot to update these. Nevertheless, I'm leaving them as is in case I messed up.
# #the bottom equation is the total regression equation
# dbh$sapwood_area.ln <- NA
# dbh$sapwood_area.ln <- ifelse(dbh$sp == "caco", 6.17-0.419*log(dbh$dbh_old.mm),
#                        ifelse(dbh$sp == "cagl", 5.32-0.26*log(dbh$dbh_old.mm),
#                        ifelse(dbh$sp == "cato", 6.51-0.444*log(dbh$dbh_old.mm),
#                        ifelse(dbh$sp == "fram", 2.19+0.326*log(dbh$dbh_old.mm),
#                        ifelse(dbh$sp == "juni", 5.53-0.404*log(dbh$dbh_old.mm),
#                        ifelse(dbh$sp == "litu", 4.31-0.0718*log(dbh$dbh_old.mm),
#                        ifelse(dbh$sp == "qual", 7.09-0.692*log(dbh$dbh_old.mm),
#                        ifelse(dbh$sp == "qupr", 4.99-0.305*log(dbh$dbh_old.mm),
#                        ifelse(dbh$sp == "quru", 4.27-0.282*log(dbh$dbh_old.mm),
#                        ifelse(dbh$sp == "quve", 5.1-0.402*log(dbh$dbh_old.mm),
#                                    6.6-0.543*log(dbh$dbh_old.mm)))))))))))
#the bottom equation is the total regression equation
dbh$sapwood_area.ln <- NA
dbh$sapwood_area.ln <- ifelse(dbh$sp == "caco", -3.41+1.6*log(dbh$dbh_old.mm),
ifelse(dbh$sp == "cagl", -4.34+1.77*log(dbh$dbh_old.mm),
ifelse(dbh$sp == "cato", -3.14+1.59*log(dbh$dbh_old.mm),
ifelse(dbh$sp == "fram", -7.75+2.4*log(dbh$dbh_old.mm),
ifelse(dbh$sp == "juni", -4.23+1.64*log(dbh$dbh_old.mm),
ifelse(dbh$sp == "litu", -5.5+1.98*log(dbh$dbh_old.mm),
ifelse(dbh$sp == "qual", -2.66+1.35*log(dbh$dbh_old.mm),
ifelse(dbh$sp == "qupr", -4.89+1.76*log(dbh$dbh_old.mm),
ifelse(dbh$sp == "quru", -5.35+1.74*log(dbh$dbh_old.mm),
ifelse(dbh$sp == "quve", -4.57+1.63*log(dbh$dbh_old.mm),
-3.13+1.5*log(dbh$dbh_old.mm)))))))))))
dbh$sapwood_area.cm2 <- exp(dbh$sapwood_area.ln)
#calculate ratio for each tree using regression equations
##prepare: get radius.w/o.bark (/2) and convert to cm (/10).
dbh$radius_nobark.cm <- (dbh$diam_nobark_old/2)/10
##total wood area = pi*(radius.nobark)^2 (cm^2)
dbh$total_wood_area.cm2 <- pi*(dbh$radius_nobark.cm)^2
dbh$sap_ratio <- dbh$sapwood_area.cm2/dbh$total_wood_area.cm2
trees_all$sap_ratio <- dbh$sap_ratio[match(trees_all$tree, dbh$tree) & match(trees_all$year, dbh$year)]
##5g. add in tree heights ####
## taken from the canopy_heights script
#the full equation is using all points for which we have data to create the equation, despite that for several species we don't have enough data to get a sp-specific equation
trees_all$height.ln.m <- ifelse(trees_all$sp == "caco", (0.348+0.808*trees_all$dbh.ln.cm),
ifelse(trees_all$sp == "cagl", (0.681+0.704*trees_all$dbh.ln.cm),
ifelse(trees_all$sp == "caovl", (0.621+0.722*trees_all$dbh.ln.cm),
ifelse(trees_all$sp == "cato", (0.776+0.701*trees_all$dbh.ln.cm),
ifelse(trees_all$sp == "fagr", (0.708+0.662*trees_all$dbh.ln.cm),
ifelse(trees_all$sp == "fram", (0.715+0.619*trees_all$dbh.ln.cm),
ifelse(trees_all$sp == "juni", (1.22+0.49*trees_all$dbh.ln.cm),
ifelse(trees_all$sp == "litu", (1.32+0.524*trees_all$dbh.ln.cm),
ifelse(trees_all$sp == "qual", (1.14+0.548*trees_all$dbh.ln.cm),
ifelse(trees_all$sp == "qupr", (0.44+0.751*trees_all$dbh.ln.cm),
ifelse(trees_all$sp == "quru", (1.17+0.533*trees_all$dbh.ln.cm),
ifelse(trees_all$sp == "quve", (0.864+0.585*trees_all$dbh.ln.cm),
(0.791+0.645*trees_all$dbh.ln.cm)))))))))))))
#0.849+0.659*trees_all$dbh_ln.cm -> original equation that was yielding predicted heights for some trees of about 54m.
trees_all$height.m <- exp(trees_all$height.ln.m) #m, because these equations come from a plotting of log(DBH in cm) against log(height in m).
#see mean of height changes
ht_change <- trees_all %>%
group_by(tree) %>%
summarize(max(height.m) - min(height.m))
ht_change <- ht_change[ht_change$`max(height.m) - min(height.m)` > 0, ]
mean(ht_change$`max(height.m) - min(height.m)`)
#cap values at max for different species.
# heights_full <- read.csv(text=getURL("https://raw.githubusercontent.com/SCBI-ForestGEO/SCBI-ForestGEO-Data/master/tree_dimensions/tree_heights/SCBI_tree_heights.csv"), stringsAsFactors = FALSE)
#
# max_ht <- aggregate(height.m ~ sp, data=heights_full, FUN=max)
##5h. add in all crown positions ####
positions <- read.csv(text=getURL("https://raw.githubusercontent.com/SCBI-ForestGEO/SCBI-ForestGEO-Data/master/tree_dimensions/tree_crowns/cored_dendroband_crown_position_data/dendro_cored_full.csv"))
trees_all$position_all <- positions$crown.position[match(trees_all$tree, positions$tag)]
trees_all$position_all <- gsub("D", "dominant", trees_all$position_all)
trees_all$position_all <- gsub("C", "co-dominant", trees_all$position_all)
trees_all$position_all <- gsub("I", "intermediate", trees_all$position_all)
trees_all$position_all <- gsub("S", "suppressed", trees_all$position_all)
#this has been proven to be roughly equivalent to position_all, so we're sticking with position_all
# trees_all$illum <- positions$illum[match(trees_all$tree, positions$tag)]
# trees_all$illum <- as.character(trees_all$illum)
#this csv has avg/min/max dbh for each canopy position by sp
# positionsp <- read.csv("data/core_chronologies_by_crownposition.csv")
##5i. add in topographic wetness index ####
### this code comes from topo_wetness_index in ForestGEO-Data
ext <- extent(747370.6, 747785.8, 4308505.5, 4309154.8)
xy <- abs(apply(as.matrix(bbox(ext)), 1, diff))
n <- 5
r <- raster(ext, ncol=xy[1]*n, nrow=xy[2]*n)
proj4string(r) <- CRS("+proj=utm +zone=17 +datum=NAD83 +units=m +no_defs +ellps=GRS80 +towgs84=0,0,0")
#2 Get elevation raster from online
q <- get_elev_raster(r, z=14)
#3 Crop online raster to the dimensions of the empty raster, set resolution to 5m
r <- raster(ext, res = 5)
q <- resample(q, r)
res(q)
proj4string(q) <- CRS("+proj=utm +zone=17 +datum=NAD83 +units=m +no_defs +ellps=GRS80 +towgs84=0,0,0") #q lost its crs in the resample function
plot(q)
#4 Get hydrological features of landscape (upslope area and topographical wetness index)
layers <- build_layers(q)
sp::plot(layers, main=c("Elevation AMSL (m)", "Upslope area (log(m^2/m))", "TWI ((log(m^2/m))"))
#5 get TWI values for trees
twi_trees <- read.csv("D:/Dropbox (Smithsonian)/Github_Ian/McGregor_climate-sensitivity-variation/data/core_list_for_neil.csv")
twi_trees <- twi_trees[, c(1,23:24)]
twi_trees1 <- twi_trees[, c(2:3)]
twi <- extract(layers[[3]], twi_trees1, method="simple")
twi_trees$TWI <- twi
#6 add to trees_all
trees_all$TWI <- twi_trees$TWI[match(trees_all$tree, twi_trees$tag)]
##5i1. write trees_all to csv for use in manuscript code ####
write.csv(trees_all, "manuscript/tables_figures/trees_all.csv", row.names=FALSE)
##5j. remove one bad tree & resistance values >2 ####
##fram 140939 has been mislabeled. It is recorded as having a small dbh when that is the second stem. In terms of canopy position, though, it fell between time of coring and when positions were recorded, thus we do not know its position.
trees_all <- trees_all[!trees_all$tree == 140939, ]
trees_all <- trees_all[trees_all$resist.value <=2,]
##5k. subset for either leaf hydraulic traits or biophysical ####
trees_all_traits <- trees_all[complete.cases(trees_all), ]
write.csv(trees_all_traits, "manuscript/tables_figures/trees_all_traits.csv", row.names=FALSE)
##take out columns that are unnecessary for model runs
trees_all_sub <- trees_all[, !colnames(trees_all) %in% c("p50.MPa", "p80.MPa", "dbh_old.mm",  "dbh_old.cm", "sap_ratio", "height.m")]
##get rid of missing data
trees_all_sub <- trees_all_sub[complete.cases(trees_all_sub), ]
##5ki. NOTE ####
##originally I was separating out trees_all into 2 datasets (trees_all_bio and trees_all_full) because I thought that there was alternative missing data depending on if you were looking at biophysical traits compared to leaf traits. It turns out this was mainly due to p50 and p80, which we have since determined will not be in the model runs at all. Thus, I'm only doing one subset here.
#
# trees_all_bio <- trees_all[c("year", "sp", "tree", "position", "resist.value", "elev.m", "distance.ln.m", "dbh.ln.cm", "height.ln.m", "position_all", "TWI")]
# trees_all_bio <- trees_all_bio[complete.cases(trees_all_bio), ]
# write.csv(trees_all_bio, "manuscript/tables_figures/trees_all_bio.csv", row.names=FALSE)
#
# #take out p50 and p80, then keep all leaf traits and additionally height plus position
# trees_all_full <- trees_all[!colnames(trees_all) %in% c("p50.MPa", "p80.MPa")]
# trees_all_full <- trees_all_full[, c(1:10,17:20)]
# trees_all_full<- trees_all_full[complete.cases(trees_all_full), ]
# write.csv(trees_all_full, "manuscript/tables_figures/trees_all_full.csv", row.names=FALSE)
##5l. make subsets for individual years, combine all to list ####
x1966 <- trees_all_sub[trees_all_sub$year == 1966, ]
x1977 <- trees_all_sub[trees_all_sub$year == 1977, ]
x1999 <- trees_all_sub[trees_all_sub$year == 1999, ]
model_df <- list(trees_all_sub, x1966, x1977, x1999)
names(model_df) <- c("trees_all_sub", "x1966", "x1977", "x1999")
library(lme4)
library(AICcmodavg) #aictab function
library(car)
library(piecewiseSEM) #for R^2 values for all model outputs in a list
library(MuMIn) #for R^2 values of one model output
library(stringr)
View(trees_all_traits)
?`dynatopmodel-package`
?build_layers
##5i. add in topographic wetness index ####
### this code comes from topo_wetness_index in ForestGEO-Data
ext <- extent(747370.6, 747785.8, 4308505.5, 4309154.8)
xy <- abs(apply(as.matrix(bbox(ext)), 1, diff))
n <- 5
r <- raster(ext, ncol=xy[1]*n, nrow=xy[2]*n)
proj4string(r) <- CRS("+proj=utm +zone=17 +datum=NAD83 +units=m +no_defs +ellps=GRS80 +towgs84=0,0,0")
#2 Get elevation raster from online
q <- get_elev_raster(r, z=14)
#3 Crop online raster to the dimensions of the empty raster, set resolution to 5m
r <- raster(ext, res = 5)
q <- resample(q, r)
res(q)
proj4string(q) <- CRS("+proj=utm +zone=17 +datum=NAD83 +units=m +no_defs +ellps=GRS80 +towgs84=0,0,0") #q lost its crs in the resample function
plot(q)
#4 Get hydrological features of landscape (upslope area and topographical wetness index)
layers <- build_layers(q)
sp::plot(layers, main=c("Elevation AMSL (m)", "Upslope area (log(m^2/m))", "TWI ((log(m^2/m))"))
#5 get TWI values for trees
twi_trees <- read.csv("D:/Dropbox (Smithsonian)/Github_Ian/McGregor_climate-sensitivity-variation/data/core_list_for_neil.csv")
twi_trees <- twi_trees[, c(1,23:24)]
twi_trees1 <- twi_trees[, c(2:3)]
twi <- extract(layers[[3]], twi_trees1, method="simple")
twi_trees$TWI <- twi
#6 add to trees_all
trees_all$TWI <- twi_trees$TWI[match(trees_all$tree, twi_trees$tag)]
trees_all$TWI_ln <- log(TWI)
##5i1. write trees_all to csv for use in manuscript code ####
write.csv(trees_all, "manuscript/tables_figures/trees_all.csv", row.names=FALSE)
##5j. remove one bad tree & resistance values >2 ####
##fram 140939 has been mislabeled. It is recorded as having a small dbh when that is the second stem. In terms of canopy position, though, it fell between time of coring and when positions were recorded, thus we do not know its position.
trees_all <- trees_all[!trees_all$tree == 140939, ]
trees_all <- trees_all[trees_all$resist.value <=2,]
##5k. subset for either leaf hydraulic traits or biophysical ####
trees_all_traits <- trees_all[complete.cases(trees_all), ]
write.csv(trees_all_traits, "manuscript/tables_figures/trees_all_traits.csv", row.names=FALSE)
##take out columns that are unnecessary for model runs
trees_all_sub <- trees_all[, !colnames(trees_all) %in% c("p50.MPa", "p80.MPa", "dbh_old.mm",  "dbh_old.cm", "sap_ratio", "height.m")]
##get rid of missing data
trees_all_sub <- trees_all_sub[complete.cases(trees_all_sub), ]
##5ki. NOTE ####
##originally I was separating out trees_all into 2 datasets (trees_all_bio and trees_all_full) because I thought that there was alternative missing data depending on if you were looking at biophysical traits compared to leaf traits. It turns out this was mainly due to p50 and p80, which we have since determined will not be in the model runs at all. Thus, I'm only doing one subset here.
#
# trees_all_bio <- trees_all[c("year", "sp", "tree", "position", "resist.value", "elev.m", "distance.ln.m", "dbh.ln.cm", "height.ln.m", "position_all", "TWI")]
# trees_all_bio <- trees_all_bio[complete.cases(trees_all_bio), ]
# write.csv(trees_all_bio, "manuscript/tables_figures/trees_all_bio.csv", row.names=FALSE)
#
# #take out p50 and p80, then keep all leaf traits and additionally height plus position
# trees_all_full <- trees_all[!colnames(trees_all) %in% c("p50.MPa", "p80.MPa")]
# trees_all_full <- trees_all_full[, c(1:10,17:20)]
# trees_all_full<- trees_all_full[complete.cases(trees_all_full), ]
# write.csv(trees_all_full, "manuscript/tables_figures/trees_all_full.csv", row.names=FALSE)
##5l. make subsets for individual years, combine all to list ####
x1966 <- trees_all_sub[trees_all_sub$year == 1966, ]
x1977 <- trees_all_sub[trees_all_sub$year == 1977, ]
x1999 <- trees_all_sub[trees_all_sub$year == 1999, ]
model_df <- list(trees_all_sub, x1966, x1977, x1999)
names(model_df) <- c("trees_all_sub", "x1966", "x1977", "x1999")
library(lme4)
library(AICcmodavg) #aictab function
library(car)
library(piecewiseSEM) #for R^2 values for all model outputs in a list
library(MuMIn) #for R^2 values of one model output
library(stringr)
View(trees_all_sub)
View(trees_all)
trees_all$TWI.ln <- log(trees_all$TWI)
##5i1. write trees_all to csv for use in manuscript code ####
write.csv(trees_all, "manuscript/tables_figures/trees_all.csv", row.names=FALSE)
##5j. remove one bad tree & resistance values >2 ####
##fram 140939 has been mislabeled. It is recorded as having a small dbh when that is the second stem. In terms of canopy position, though, it fell between time of coring and when positions were recorded, thus we do not know its position.
trees_all <- trees_all[!trees_all$tree == 140939, ]
trees_all <- trees_all[trees_all$resist.value <=2,]
##5k. subset for either leaf hydraulic traits or biophysical ####
trees_all_traits <- trees_all[complete.cases(trees_all), ]
write.csv(trees_all_traits, "manuscript/tables_figures/trees_all_traits.csv", row.names=FALSE)
##take out columns that are unnecessary for model runs
trees_all_sub <- trees_all[, !colnames(trees_all) %in% c("p50.MPa", "p80.MPa", "dbh_old.mm",  "dbh_old.cm", "sap_ratio", "height.m")]
##get rid of missing data
trees_all_sub <- trees_all_sub[complete.cases(trees_all_sub), ]
##5ki. NOTE ####
##originally I was separating out trees_all into 2 datasets (trees_all_bio and trees_all_full) because I thought that there was alternative missing data depending on if you were looking at biophysical traits compared to leaf traits. It turns out this was mainly due to p50 and p80, which we have since determined will not be in the model runs at all. Thus, I'm only doing one subset here.
#
# trees_all_bio <- trees_all[c("year", "sp", "tree", "position", "resist.value", "elev.m", "distance.ln.m", "dbh.ln.cm", "height.ln.m", "position_all", "TWI")]
# trees_all_bio <- trees_all_bio[complete.cases(trees_all_bio), ]
# write.csv(trees_all_bio, "manuscript/tables_figures/trees_all_bio.csv", row.names=FALSE)
#
# #take out p50 and p80, then keep all leaf traits and additionally height plus position
# trees_all_full <- trees_all[!colnames(trees_all) %in% c("p50.MPa", "p80.MPa")]
# trees_all_full <- trees_all_full[, c(1:10,17:20)]
# trees_all_full<- trees_all_full[complete.cases(trees_all_full), ]
# write.csv(trees_all_full, "manuscript/tables_figures/trees_all_full.csv", row.names=FALSE)
##5l. make subsets for individual years, combine all to list ####
x1966 <- trees_all_sub[trees_all_sub$year == 1966, ]
x1977 <- trees_all_sub[trees_all_sub$year == 1977, ]
x1999 <- trees_all_sub[trees_all_sub$year == 1999, ]
model_df <- list(trees_all_sub, x1966, x1977, x1999)
names(model_df) <- c("trees_all_sub", "x1966", "x1977", "x1999")
sum_mod_traits <- data.frame(
"prediction" = c(1.1, 2.1, 2.2, 3.3, 3.4, 4.1, 4.2, 4.3, 4.4, 4.5),
"variable" = c("year", "dbh.ln.cm", "height.ln.m", "position_all",  "TWI.ln", "rp", "PLA_dry_percent", "LMA_g_per_m2", "mean_TLP_Mpa", "WD_g_per_cm3"),
"variable_description" = c("drought.year", "ln[DBH]", "ln[height]", "crown.position", "topographic.wetness.index", "ring.porosity", "percent.leaf.area", "leaf.mass.area", "mean.turgor.loss.point", "wood.density"),
"null_model" =
c("resist.value ~ (1|sp/tree)",
"resist.value ~ year+(1|sp/tree)",
"resist.value ~ year+(1|sp/tree)",
"resist.value ~ height.ln.m+year+(1|sp/tree)",
"resist.value ~ height.ln.m+year+(1|sp/tree)",
"resist.value ~ height.ln.m+year+(1|sp/tree)",
"resist.value ~ height.ln.m+year+(1|sp/tree)",
"resist.value ~ height.ln.m+year+(1|sp/tree)",
"resist.value ~ height.ln.m+year+(1|sp/tree)",
"resist.value ~ height.ln.m+year+(1|sp/tree)"),
"tested_model" = NA)
sum_mod_traits[, c("null_model_year", "tested_model_year", "dAIC_all", "coef_all", "coef_var_all", "dAIC_1964.1966", "coef_1964.1966", "coef_var_1964.1966", "dAIC_1977", "coef_1977", "coef_var_1977", "dAIC_1999", "coef_1999", "coef_var_1999")] <- NA
# change factor columns to character
sum_mod_traits <- sum_mod_traits %>% mutate_if(is.factor, as.character)
##loop to create table of individually-tested traits
##For each variable, it compares the variable's effects in the null model and the tested model. The loop defines these models, then has two parts. If the full data (all years) model is being run [j,h,k,l == 1], it calculates the dAIC for null minus tested and the coefficient of the variable, either a "+" or a "-". If the individual year models are being run, it does the same thing but using different models from before [e.g. models_yr], to specifically exclude the "year" and "1/tree" effects.
coeff_all <- NULL
for (i in seq_along(1:10)){
null_mod <- sum_mod_traits$null_model[[i]] #all years
var <- sum_mod_traits$variable[[i]]
#if the variable is in the null model, then take it out, otherwise add it in
sum_mod_traits$tested_model[[i]] <-
ifelse(grepl(var, null_mod),
gsub(paste0(var, "[[:punct:]]"), "", sum_mod_traits$null_model[[i]]),
paste0(null_mod, "+", var))
sum_mod_traits$null_model_year[[i]] <-
gsub("year\\+|/tree", "", sum_mod_traits$null_model[[i]])
sum_mod_traits$tested_model_year[[i]] <-
gsub("year\\+|/tree", "", sum_mod_traits$tested_model[[i]])
#obviously, the tested model of the "year" effect doesn't work over the individual years
if (i == 1){
sum_mod_traits$tested_model_year[[i]] <- sum_mod_traits$null_model_year[[i]]
}
test_mod <- sum_mod_traits$tested_model[[i]] #all years
test_mod_yr <- sum_mod_traits$tested_model_year[[i]] #individual years
null_mod_yr <- sum_mod_traits$null_model_year[[i]] #individual years
models <- c(null_mod, test_mod) #all years
models_yr <- c(null_mod_yr, test_mod_yr) #ndividual years
for (j in seq(along=model_df)){
for (h in seq(along=sum_mod_traits[,c(8,11,14,17)])){ #dAIC
column <- colnames(sum_mod_traits[,c(8,11,14,17)][h])
for (k in seq(along=sum_mod_traits[,c(9,12,15,18)])){ #coefficients direction
column_cof <- colnames(sum_mod_traits[,c(9,12,15,18)][h])
for (l in seq(along=sum_mod_traits[,c(10,13,16,19)])){ #coefficient values
column_cof_val <- colnames(sum_mod_traits[,c(10,13,16,19)][l])
#ALL YEARS
if(j == 1 & h == 1 & k == 1 & l == 1){
lmm_all <- lapply(models, function(x){
fit1 <- lmer(x, data = model_df[[j]], REML=FALSE,
control = lmerControl(optimizer ="Nelder_Mead"))
return(fit1)
})
names(lmm_all) <- models
var_aic <- aictab(lmm_all, second.ord=TRUE, sort=FALSE) #rank based on AICc
#put AIC value in table (#null - test)
sum_mod_traits[,column][[i]] <- var_aic$AICc[[1]] - var_aic$AICc[[2]]
sum_mod_traits[,column][[i]] <- round(sum_mod_traits[,column][[i]], 3)
for (z in seq(along = lmm_all)){
if (grepl(var, test_mod)){
if (names(lmm_all[z]) == test_mod){
coeff <- data.frame(coef(summary(lmm_all[[z]]))[ , "Estimate"]) ##2
coeff[,2] <- rownames(coeff)
colnames(coeff) <- c("value", "model_var")
coeff$value <- round(coeff$value, 3)
coeff$combo <- paste0(coeff$model_var, " (", coeff$value, ")")
coeff <- coeff[grepl(sum_mod_traits$variable[[i]], coeff$combo), ]
coeff_vec <- coeff$combo
#this rbind is to get a full df showing all coefficient values from the entire for-loop
coeff_all <- rbind(coeff_all, coeff)
#put coefficients in table
sum_mod_traits[,column_cof][[i]] <- ifelse(any(coeff$value < 0), "-", "+")
sum_mod_traits[,column_cof_val][[i]] <- paste(coeff_vec, collapse = ", ")
}
}
}
#INDIVIDUAL YEARS
} else if (j == h & h == k & k == l){
if(i == 1){
sum_mod_traits[,column][[i]] <- NA
sum_mod_traits[,column_cof][[i]] <- NA
sum_mod_traits[,column_cof_val][[i]] <- NA
}
lmm_all <- lapply(models_yr, function(x){
fit1 <- lmer(x, data = model_df[[j]], REML=FALSE,
control = lmerControl(optimizer ="Nelder_Mead"))
return(fit1)
})
names(lmm_all) <- models_yr
var_aic <- aictab(lmm_all, second.ord=TRUE, sort=FALSE) #rank based on AICc
#put AIC value in table (null - tested)
sum_mod_traits[,column][[i]] <- var_aic$AICc[[1]] - var_aic$AICc[[2]]
sum_mod_traits[,column][[i]] <- round(sum_mod_traits[,column][[i]], 3)
for (z in seq(along = lmm_all)){
if (grepl(var, test_mod_yr)){
if (names(lmm_all[z]) == test_mod_yr){
coeff <- data.frame(coef(summary(lmm_all[[z]]))[ , "Estimate"]) ##2
coeff[,2] <- rownames(coeff)
colnames(coeff) <- c("value", "model_var")
coeff$value <- round(coeff$value, 3)
coeff$combo <- paste0(coeff$model_var, " (", coeff$value, ")")
coeff <- coeff[grepl(sum_mod_traits$variable[[i]], coeff$combo), ]
coeff_vec <- coeff$combo
#this rbind is to get a full df showing all coefficient values from the entire for-loop
coeff_all <- rbind(coeff_all, coeff)
#put coefficients in table
sum_mod_traits[,column_cof][[i]] <- ifelse(any(coeff$value < 0), "-", "+")
sum_mod_traits[,column_cof_val][[i]] <- paste(coeff_vec, collapse = ", ")
}
}
}
}
}
}
}
}
}
cand_full <- NULL
for (i in seq(along=sum_mod_traits[,c(8,11,14,17)])){
column <- colnames(sum_mod_traits[,c(8,11,14,17)])[[i]]
cand <- sum_mod_traits[sum_mod_traits[,column] > 2 &
!sum_mod_traits$variable %in% c("dbh.ln.cm"), c(1:3)]
cand$top_model <- c("all", "1966", "1977", "1999")[[i]]
cand_full <- rbind(cand_full, cand)
cand_full <- cand_full[order(cand_full$prediction), ]
}
View(cand_full)
best_mod_traits <- data.frame("best_model" = NA,
"coef" = NA,
"r2" = NA,
"scenario" = c("all droughts", "1964-1966", "1977", "1999")
)
best_mod_full <- c(unique(cand_full$variable), "(1|sp/tree)")
best_mod_full_year <- gsub("/tree", "", best_mod_full)
best_mod_full_year <- best_mod_full_year[!best_mod_full_year %in% c("year")]
#this loop determines the best full model for each scenario, using the traits from cand_full in #6a, and populates the table created above
coeff_list <- list()
for (i in seq(along=c(1:4))){
for (j in seq(along=model_df)){
#ALL YEARS
if(j == 1 & i == 1){
response <- "resist.value"
effects <- best_mod_full
#create all combinations of random / fixed effects
effects_comb <-
unlist(sapply(seq_len(length(effects)), function(i) {
apply( combn(effects,i), 2, function(x) paste(x, collapse = "+"))
}))
# pair response with effect and sub out combinations that don't include random effects
#in general, if two variables are >70% correlated, you can toss one of them without significantly affecting the results
var_comb <- expand.grid(response, effects_comb)
var_comb <- var_comb[grepl("1", var_comb$Var2), ] #only keep in fixed/random combos
# formulas for all combinations. $Var1 is the response, and $Var2 is the effect
# for good stats, you should have no more total parameters than 1/10th the number of observations in your dataset
formula_vec <- sprintf("%s ~ %s", var_comb$Var1, var_comb$Var2)
lmm_all <- lapply(formula_vec, function(x){
fit1 <- lmer(x, data = model_df[[j]], REML=FALSE,
control = lmerControl(optimizer ="Nelder_Mead"))
return(fit1)
})
names(lmm_all) <- formula_vec
var_aic <- aictab(lmm_all, second.ord=TRUE, sort=TRUE) #rank based on AICc
var_aic$Modnames <- as.character(var_aic$Modnames)
best_mod_traits$best_model[[i]] <- var_aic$Modnames[[1]]
for (z in seq(along = lmm_all)){
if (names(lmm_all[z]) == var_aic$Modnames[[1]]){
#run the best model alone with REML=TRUE
fit1 <- lmer(formula_vec[[z]], data = model_df[[j]], REML=TRUE,
control = lmerControl(optimizer ="Nelder_Mead"))
#get coefficients and put in table
coeff <- data.frame(coef(summary(fit1))[ , "Estimate"]) ##2
coeff[,2] <- rownames(coeff)
coeff[,1] <- round(coeff[,1], 3)
colnames(coeff) <- c(names(model_df[j]), "model_var")
#put r2 in table
r <- rsquared(fit1) #gives R^2 values for models. "Marginal" is the R^2 for just the fixed effects, "Conditional" is the R^2 for everything.
r <- data.frame(r[,6])
colnames(r) <- names(model_df[j])
r$model_var <- "r^2"
r[,1] <- round(r[,1], 2)
coeff <- rbind(r,coeff)
coeff_list[[paste0("coeff_", names(model_df[j]))]] <- coeff
}
}
#INDIVIDUAL YEARS
} else if (j == i){
response <- "resist.value"
effects <- best_mod_full_year
#create all combinations of random / fixed effects
effects_comb <-
unlist( sapply( seq_len(length(effects)),
function(i) {
apply( combn(effects,i), 2, function(x) paste(x, collapse = "+"))
}))
var_comb <- expand.grid(response, effects_comb)
var_comb <- var_comb[grepl("1", var_comb$Var2), ] #only keep in fixed/random combos
formula_vec <- sprintf("%s ~ %s", var_comb$Var1, var_comb$Var2)
lmm_all <- lapply(formula_vec, function(x){
fit1 <- lmer(x, data = model_df[[j]], REML=FALSE,
control = lmerControl(optimizer ="Nelder_Mead"))
return(fit1)
})
names(lmm_all) <- formula_vec
var_aic <- aictab(lmm_all, second.ord=TRUE, sort=TRUE) #rank based on AICc
var_aic$Modnames <- as.character(var_aic$Modnames)
best_mod_traits$best_model[[i]] <- var_aic$Modnames[[1]]
for (z in seq(along = lmm_all)){
if (names(lmm_all[z]) == var_aic$Modnames[[1]]){
#run the best model alone with REML=TRUE
fit1 <- lmer(formula_vec[[z]], data = model_df[[j]], REML=TRUE,
control = lmerControl(optimizer ="Nelder_Mead"))
#get coefficients and put in table
coeff <- data.frame(coef(summary(fit1))[ , "Estimate"]) ##2
coeff[,2] <- rownames(coeff)
coeff[,1] <- round(coeff[,1], 3)
colnames(coeff) <- c(names(model_df[j]), "model_var")
#put r2 in table
r <- rsquared(fit1) #gives R^2 values for models. "Marginal" is the R^2 for just the fixed effects, "Conditional" is the R^2 for everything.
r <- data.frame(r[,6])
colnames(r) <- names(model_df[j])
r$model_var <- "r^2"
r[,1] <- round(r[,1], 2)
coeff <- rbind(r,coeff)
coeff_list[[paste0("coeff_", names(model_df[j]))]] <- coeff
}
}
}
}
}
View(best_mod_traits)
View(cand_full)
##make table of coefficients and r2, then reorder table
coeff_table <- Reduce(function(dtf1, dtf2)
merge(dtf1, dtf2, by = "model_var", all = TRUE),
coeff_list)
setnames(coeff_table, old="trees_all_sub", new="all years")
vars <- coeff_table$model_var
vars <- vars[!vars %in% "r^2"]
vars <- c("r^2", vars)
coeff_table <- coeff_table %>%
slice(match(vars, model_var))
View(coeff_table)
cand_full <- NULL
for (i in seq(along=sum_mod_traits[,c(8,11,14,17)])){
column <- colnames(sum_mod_traits[,c(8,11,14,17)])[[i]]
cand <- sum_mod_traits[sum_mod_traits[,column] > 2 &
!sum_mod_traits$variable %in% c("dbh.ln.cm"), c(1:3)]
cand$top_model <- c("all", "1966", "1977", "1999")[[i]]
cand_full <- rbind(cand_full, cand)
cand_full <- cand_full[order(cand_full$prediction), ]
}
write.csv(cand_full, "manuscript/tables_figures/candidate_traits.csv", row.names=FALSE)
