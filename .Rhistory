recensus2018 <- read.csv("T:/SIGEO/2-RECENSUS 2018/DATA/CTFS_Backups/recensus2018.csv", stringsAsFactors=FALSE)
View(recensus2018)
alive <- recensus2018[!grep("D", recensus2018$Codes), ]
alive <- recensus2018[!grepl("D", recensus2018$Codes), ]
View(alive)
alive$Codes
check <- alive[alive$Mnemonic %in% c("qumu", "qufa", "qumi"), ]
View(check)
check_all <- recensus2018[recensus2018$Mnemonic %in% c("qumu", "qufa", "qumi"), ]
View(check_all)
check_all <- check_all[, c(2:6,8)]
View(check_all)
write.csv(check_all, "check_sp.csv", row.names=FALSE)
#1. Determine species occurrences in plot ####
hq <- read.csv("I:/Krista Lab/Leaf collection/plant csv/SCBISERCcombolist_20190225.csv")
scbi <- hq[!is.na(hq$SCBI), ]
scbi <- scbi[order(scbi$code6), ]
serc <- hq[!is.na(hq$SERC), ]
serc <- serc[order(serc$code6), ]
##1a. SCBI census and filter by canopy position ####
#our 2018 data shows more sp than Brian's
recensus2018 <- read.csv("T:/SIGEO/2-RECENSUS 2018/DATA/CTFS_Backups/recensus2018.csv", stringsAsFactors = FALSE)
othersp <- c("NULL", "unk")
#filter out NULL and unk in species column, plus any arbitrary species ("sp")
recensus2018_sub <- subset(recensus2018, !(recensus2018$Mnemonic %in% othersp) & !(grepl("sp", recensus2018$Mnemonic)))
#filter again by all alive species
recensus2018_alive <- subset(recensus2018, !(grepl("D", recensus2018$Codes)))
length(unique(recensus2018_sub$Mnemonic))
length(unique(scbi$code6))
#2013 data
scbi.stem2 <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/SCBI-ForestGEO-Data/tree_main_census/data/census-csv-files/scbi.stem2.csv")
#convert brian spcode to what we're used to
scbi$code6 <- gsub("^(..)..", "\\1", scbi$code6)
scbi$code6 <- gsub("crs1", "crsp", scbi$code6)
scbi$code6 <- gsub("cao1", "caovl", scbi$code6)
scbi$code6 <- gsub("qura", "quru", scbi$code6)
library(stringr)
test <- scbi[ ,c(3:9)]
colnames(test)[2] <- "sp"
#sp that have 0 alive individuals in 2018 and 2013 (scbi$code6 doesn't have dead records)
extrasp <- setdiff(unique(recensus2018_alive$Mnemonic), scbi$code6)
sp <- c(test$sp)
test$n.subcan_alive.2013 <- ""
test$n.subcan_alive.2018 <- ""
#in this case, removing the <350 qualifier does not change the species list drastically for comparing with "sp".
scbi.stem2 <- subset(scbi.stem2, scbi.stem2$DFstatus == "alive" & scbi.stem2$dbh <= 350)
#number of alive individuals for 2013 data, based on alive stems and dbh under 35cm (subcanopy)
for (i in seq(along=sp)){
species <- sp[[i]]
check <- subset(scbi.stem2, scbi.stem2$sp %in% species)
test$n.subcan_alive.2013 <- ifelse(test$sp %in% species, length(unique(check$tag)), test$n.subcan_alive.2013)
}
#number of alive individuals for 2018 data, based on alive stems and dbh under 35cm (subcanopy)
for (i in seq(along=sp)){
species <- sp[[i]]
check <- subset(recensus2018_alive, recensus2018_alive$Mnemonic %in% species & recensus2018_alive$DBH<=35)
test$n.subcan_alive.2018 <- ifelse(test$sp %in% species, length(unique(check$Tag)), test$n.subcan_alive.2018)
}
test$n.subcan_alive.2013 <- as.numeric(test$n.subcan_alive.2013)
test$n.subcan_alive.2018 <- as.numeric(test$n.subcan_alive.2018)
#####################################################################################
#3. species with >=5 individuals in plot ####
#abundant species checklist
sp_collect <- test[test$n.subcan_alive.2018 >=5, ]
sp_collect <- sp_collect[,c(1:3,5,7,9)]
sp_collect$n.collected <- ""
#abundant species locations
sp_find <- NULL
for (j in seq(along=sp_collect$sp)){
species <- sp_collect$sp[[j]]
plants <- recensus2018_alive[recensus2018_alive$Mnemonic %in% species & recensus2018_alive$DBH <=35, ]
plants <- plants[!duplicated(plants$Tag), ]
plants <- ifelse(plants$Mnemonic %in% c("quru", "cagl", "saal", "tiam", "prse", "acru", "ulam"), plants[unique(sample(nrow(plants), 15)), ], plants[unique(sample(nrow(plants), 5)), ])
sp_find <- rbind(sp_find, plants)
}
warnings()
View(sp_collect)
species == "acru"
species <- acru
species <- "acru"
#abundant species locations
sp_find <- NULL
plants <- recensus2018_alive[recensus2018_alive$Mnemonic %in% species & recensus2018_alive$DBH <=35, ]
plants <- plants[!duplicated(plants$Tag), ]
plants <- ifelse(plants$Mnemonic %in% c("quru", "cagl", "saal", "tiam", "prse", "acru", "ulam"), plants[unique(sample(nrow(plants), 15)), ], plants[unique(sample(nrow(plants), 5)), ])
plants <- recensus2018_alive[recensus2018_alive$Mnemonic %in% species & recensus2018_alive$DBH <=35, ]
plants <- plants[!duplicated(plants$Tag), ]
View(plants)
plants$Mnemonic %in% c("quru", "cagl", "saal", "tiam", "prse", "acru", "ulam")
plants[unique(sample(nrow(plants), 15))
plants[unique(sample(nrow(plants), 15)), ]
plants <- ifelse(species %in% c("quru", "cagl", "saal", "tiam", "prse", "acru", "ulam"), plants[unique(sample(nrow(plants), 15)), ], plants[unique(sample(nrow(plants), 5)), ])
View(plants)
plants <- recensus2018_alive[recensus2018_alive$Mnemonic %in% species & recensus2018_alive$DBH <=35, ]
plants <- plants[!duplicated(plants$Tag), ]
plants <- ifelse(species %in% c("quru", "cagl", "saal", "tiam", "prse", "acru", "ulam"), data.frame(plants[unique(sample(nrow(plants), 15)), ]), data.frame(plants[unique(sample(nrow(plants), 5)), ]))
plants <- recensus2018_alive[recensus2018_alive$Mnemonic %in% species & recensus2018_alive$DBH <=35, ]
plants <- plants[!duplicated(plants$Tag), ]
plants <- ifelse(species %in% c("quru", "cagl", "saal", "tiam", "prse", "acru", "ulam"), unique(sample(nrow(plants), 15)), plants[unique(sample(nrow(plants), 5)), ])
species %in% c("quru", "cagl", "saal", "tiam", "prse", "acru", "ulam")
plants <- recensus2018_alive[recensus2018_alive$Mnemonic %in% species & recensus2018_alive$DBH <=35, ]
plants <- plants[!duplicated(plants$Tag), ]
species %in% c("quru", "cagl", "saal", "tiam", "prse", "acru", "ulam")
subset(plants, unique(sample(nrow(plants), 15)))
?subset
unique(sample(nrow(plants), 15))
subset(plants, rownames(plants) %in% unique(sample(nrow(plants), 15)))
subset(plants, row.names(plants) %in% unique(sample(nrow(plants), 15)))
plants[unique(sample(nrow(plants), 15)), ]
plants <- recensus2018_alive[recensus2018_alive$Mnemonic %in% species & recensus2018_alive$DBH <=35, ]
plants <- plants[!duplicated(plants$Tag), ]
plants <- ifelse(species %in% c("quru", "cagl", "saal", "tiam", "prse", "acru", "ulam"), as.data.frame(plants[unique(sample(nrow(plants), 15)), ]), as.data.frame(plants[unique(sample(nrow(plants), 5)), ]))
View(plants)
plants[[1]]
plants <- recensus2018_alive[recensus2018_alive$Mnemonic %in% species & recensus2018_alive$DBH <=35, ]
plants <- plants[!duplicated(plants$Tag), ]
plants <- ifelse(species %in% c("quru", "cagl", "saal", "tiam", "prse", "acru", "ulam"), (plants[unique(sample(nrow(plants), 15)), ]), plants[unique(sample(nrow(plants), 5)), ])
plants <- recensus2018_alive[recensus2018_alive$Mnemonic %in% species & recensus2018_alive$DBH <=35, ]
plants <- plants[!duplicated(plants$Tag), ]
#abundant species locations
wide <- sp_collect[sp_collect$Widespread == TRUE, ]
View(sp_collect)
#abundant species locations
wide <- sp_collect[sp_collect$Widespread == "TRUE", ]
View(wide)
#abundant species locations
sp_collect$Widespread <- as.character(sp_collect$Widespread)
wide <- sp_collect[sp_collect$Widespread == "TRUE", ]
#abundant species locations
sp_collect$Widespread <- gsub("TRUE", "yes", sp_collect$Widespread)
View(sp_collect)
wide <- sp_collect[sp_collect$Widespread == "yes", ]
View(sp_collect)
sp_collect$Widespread == "yes", ]
[sp_collect$Widespread == "yes", ]
sp_collect[sp_collect$Widespread == "yes", ]
wide <- sp_collect[!is.na(sp_collect$Widespread), ]
View(wide)
wide_sp <- wide$sp
plants <- recensus2018_alive[recensus2018_alive$Mnemonic %in% species & recensus2018_alive$DBH <=35, ]
plants <- plants[!duplicated(plants$Tag), ]
any(!(species %in% wide_sp))
if(any(!(species %in% wide_sp))){
plants <- plants[unique(sample(nrow(plants), 5)), ]
else{
plants <- plants[unique(sample(nrow(plants), 15)), ]
}
plants <- recensus2018_alive[recensus2018_alive$Mnemonic %in% species & recensus2018_alive$DBH <=35, ]
plants <- plants[!duplicated(plants$Tag), ]
if(any(!(species %in% wide_sp))){
plants <- plants[unique(sample(nrow(plants), 5)), ]}
else{
plants <- plants[unique(sample(nrow(plants), 15)), ]
}
plants <- recensus2018_alive[recensus2018_alive$Mnemonic %in% species & recensus2018_alive$DBH <=35, ]
plants <- plants[!duplicated(plants$Tag), ]
if(any(!(species %in% wide_sp))){
plants <- plants[unique(sample(nrow(plants), 5)), ]
} else {
plants <- plants[unique(sample(nrow(plants), 15)), ]
}
sp_find <- NULL
for (j in seq(along=sp_collect$sp)){
species <- sp_collect$sp[[j]]
plants <- recensus2018_alive[recensus2018_alive$Mnemonic %in% species & recensus2018_alive$DBH <=35, ]
plants <- plants[!duplicated(plants$Tag), ]
if(any(!(species %in% wide_sp))){
plants <- plants[unique(sample(nrow(plants), 5)), ]
} else {
plants <- plants[unique(sample(nrow(plants), 15)), ]
}
sp_find <- rbind(sp_find, plants)
}
sp_find <- sp_find[,c(1:5,7)]
colnames(sp_find) <- c("tag", "stemtag", "quadrat", "sp", "dbh", "codes")
sp_find <- sp_find[order(sp_find$quadrat), ]
sp_find$codes <- gsub("NULL", "", sp_find$codes)
sp_find$env <- ""
sp_find$age <- ""
sp_find$sex <- ""
View(sp_find)
sp_find <- NULL
for (j in seq(along=sp_collect$sp)){
species <- sp_collect$sp[[j]]
plants <- recensus2018_alive[recensus2018_alive$Mnemonic %in% species & recensus2018_alive$DBH <=35, ]
plants <- plants[!duplicated(plants$Tag), ]
if(any(!(species %in% wide_sp))){
plants <- plants[unique(sample(nrow(plants), 5)), ]
} else {
plants <- plants[unique(sample(nrow(plants), 15)), ]
}
sp_find <- rbind(sp_find, plants)
}
View(sp_find)
sp_find <- sp_find[,c(2:6,8)]
colnames(sp_find) <- c("tag", "stemtag", "quadrat", "sp", "dbh", "codes")
sp_find <- sp_find[order(sp_find$quadrat), ]
sp_find$codes <- gsub("NULL", "", sp_find$codes)
sp_find$env <- ""
sp_find$age <- ""
sp_find$sex <- ""
View(sp_find)
ulam <- sp_find[sp_find$sp == "ulam", ]
View(ulam)
setwd("C:/Users/mcgregori/Dropbox (Smithsonian)/Chemical ecology SERC and SCBI/plant_lists/species_SCBI")
write.csv(sp_find, "species_high_location_SCBI.csv", row.names=FALSE)
library(pointRes)
library(dplR)
library(data.table)
##4a. canopy ####
setwd("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/SCBI-ForestGEO-Data/tree_cores/chronologies/current_chronologies/complete/separated by canopy position/canopy_cores")
dirs_can <- dir("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/SCBI-ForestGEO-Data/tree_cores/chronologies/current_chronologies/complete/separated by canopy position/canopy_cores", pattern = "_canopy.rwl")
dirs_can <- dirs_can[dirs_can != "frni_canopy.rwl" & dirs_can != "frni_drop_canopy.rwl" & dirs_can != "caco_drop_canopy.rwl"]
sp_can <- gsub("_drop_canopy.rwl", "", dirs_can)
canopy <- list()
widths_can <- list()
canopy_table <- NULL
for (i in seq(along=dirs_can)){
for (j in seq(along=sp_can)){
if (i==j){
file <- dirs_can[[i]]
rings <- read.rwl(file) #read in rwl file
area <- bai.in(rings) #convert to bai.in
testr <- res.comp(area, nb.yrs=5, res.thresh.neg = 30, series.thresh = 50) #get resilience metrics
canopy[[i]] <- testr
widths_can[[i]] <- rings
testr_table <- data.frame(testr$out)
testr_table <- testr_table[testr_table$nb.series > 4, ] #remove where there are < 4 series
testr_table$sp <- sp_can[[j]]
testr_table$position <- "canopy"
canopy_table <- rbind(canopy_table, testr_table)
}
values <- paste0(sp_can, "_can_res")
names(canopy) <- values
values <- paste0(sp_can, "_canopy")
names(widths_can) <- values
##4b. subcanopy ####
setwd("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/SCBI-ForestGEO-Data/tree_cores/chronologies/current_chronologies/complete/separated by canopy position/subcanopy_cores")
dirs_subcan <- dir("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/SCBI-ForestGEO-Data/tree_cores/chronologies/current_chronologies/complete/separated by canopy position/subcanopy_cores", pattern = "_subcanopy.rwl")
#dirs_subcan <- dirs_subcan[dirs_subcan != "frni_drop_subcanopy.rwl" & dirs_subcan != "caco_drop_subcanopy.rwl"]
sp_subcan <- gsub("_drop_subcanopy.rwl", "", dirs_subcan)
subcanopy <- list()
widths_sub <- list()
subcanopy_table <- NULL
for (i in seq(along=dirs_subcan)){
for (j in seq(along=sp_subcan)){
if (i==j){
file <- dirs_subcan[[i]]
rings <- read.rwl(file) #read in rwl file
area <- bai.in(rings) #convert to bai.in
test <- res.comp(area, nb.yrs=5, res.thresh.neg = 30, series.thresh = 50) #get resilience metrics
subcanopy[[i]] <- test
widths_sub[[i]] <- rings
test_table <- data.frame(test$out)
test_table <- test_table[test_table$nb.series > 4, ] #remove where there are < 4 series
test_table$sp <- sp_subcan[[j]]
test_table$position <- "subcanopy"
subcanopy_table <- rbind(subcanopy_table, test_table)
}
values_sub <- paste0(sp_subcan, "_subcan_res")
names(subcanopy) <- values_sub
values <- paste0(sp_subcan, "_subcanopy")
names(widths_sub) <- values
widths <- c(widths_can, widths_sub) #combine into one, then delete. For use in #5d
widths_can <- NULL
widths_subcan <- NULL
##4c. df for pointer years of all trees combined ####
full_ind <- rbind(canopy_table, subcanopy_table) #full table of indices for canopy and subcanopy cores
pointers <- full_ind[full_ind$nature == -1, ]
library(dplyr)
years_point <- count(pointers, vars=year) #counts the occurrences of each unique year
colnames(years_point) <- c("yr", "n.pointer")
years_point <- years_point[order(years_point$n.pointer, decreasing=TRUE), ]
setwd("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/McGregor_climate-sensitivity-variation")
#write.csv(pointers, "occurrence_of_pointer_yrs.csv", row.names=FALSE)
##4d. resistance metrics for all trees ####
neil_list <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/McGregor_climate-sensitivity-variation/core_list_for_neil.csv", stringsAsFactors = FALSE)
neil_list$tag <- paste0("X", neil_list$tag) #to match the colnames of can_resist below
pointer_years <- head(years_point$yr) #from above in #4c
pointer_years <- pointer_years[!pointer_years %in% c(1911, 1947, 1991)]
###canopy ####
#this loop says, for the different species in the list "canopy" (names(canopy)), create a dataframe of only the resistance index. Make a list of the colnames, which are the individual trees. Then, assign species identifiers for each one from Neil's core list, subset by the defined pointer years, and melt the data before rbinding.
tag_n <- names(canopy)
trees_canopy <- NULL
for (i in seq(along=1:length(tag_n))){
can_resist <- data.frame(canopy[[i]]$resist)
years <- rownames(can_resist)
colnames(can_resist) <- gsub("A", "", colnames(can_resist))
tree_series <- colnames(can_resist)
# for (j in seq(along=tree_series)){
#  trees <- tree_series[[j]]
ind <- can_resist
ind_neil <- neil_list[neil_list$tag %in% tree_series, ]
#  colnames(ind) <- trees
ind$year <- years
ind$sp <- unique(ind_neil$sp)
ind$position <- "canopy"
ind <- ind[ind$year %in% pointer_years, ]
change <- melt(ind)
setnames(change, old=c("variable", "value"), new=c("tree", "resist.value"))
change$tree <- gsub("X", "", change$tree)
change$tree <- gsub("^0", "", change$tree)
trees_canopy <- rbind(trees_canopy, change)
}
###subcanopy ####
#this loop says, for the different species in the list "subcanopy" (names(subcanopy)), create a dataframe of only the resistance index. Make a list of the colnames, which are the individual trees. Then, assign species identifiers for each one from Neil's core list, subset by the defined pointer years, and melt the data before rbinding.
tag_n <- names(subcanopy)
trees_subcanopy <- NULL
for (i in seq(along=1:length(tag_n))){
sub_resist <- data.frame(subcanopy[[i]]$resist)
years <- rownames(sub_resist)
colnames(sub_resist) <- gsub("A", "", colnames(sub_resist))
tree_series <- colnames(sub_resist)
# for (j in seq(along=tree_series)){
#  trees <- tree_series[[j]]
ind <- sub_resist
ind_neil <- neil_list[neil_list$tag %in% tree_series, ]
#  colnames(ind) <- trees
ind$year <- years
ind$sp <- unique(ind_neil$sp)
ind$position <- "subcanopy"
ind <- ind[ind$year %in% pointer_years, ]
change <- melt(ind)
setnames(change, old=c("variable", "value"), new=c("tree", "resist.value"))
change$tree <- gsub("X", "", change$tree)
change$tree <- gsub("^0", "", change$tree)
trees_subcanopy <- rbind(trees_subcanopy, change)
}
###rbind together ####
trees_all <- rbind(trees_canopy, trees_subcanopy)
trees_all$year <- as.numeric(trees_all$year)
#subset out NAs for resistance values (not necessary, bc lmm will automatically exclude them)
trees_all <- trees_all[!is.na(trees_all$resist.value), ]
##4e. determine proportion of resistance values per sp ####
prop <- data.frame("sp" = unique(trees_all$sp))
prop$value.over1 <- NA
prop$can.value.over1 <- NA
prop$sub.value.over1 <- NA
trees_all.sp <- unique(trees_all$sp)
for (i in seq(along=prop$sp)){
for (j in seq(along=unique(trees_all.sp))){
if (i==j){
temp <- trees_all[trees_all$sp == trees_all.sp[[j]] & trees_all$resist.value>=1, ]
temp <- temp[!is.na(temp$resist.value), ]
prop$value.over1[[i]] <- nrow(temp)
prop$can.value.over1[[i]] <- nrow(temp[temp$position == "canopy", ])
prop$sub.value.over1[[i]] <- nrow(temp[temp$position == "subcanopy", ])
}
##########################################################################################
#5. add in climate and growth variables ####
library(SciViews)
##5a. add in turgor loss point values ####
#add in tlp values (from Krista github issue #6 https://github.com/SCBI-ForestGEO/McGregor_climate-sensitivity-variation/issues/6)
turgor <- data.frame("sp" = c("cagl", "caovl", "fagr", "fram", "juni", "litu", "pist", "qual", "qupr", "quru", "quve", "caco", "cato", "frni"), "tlp" = c(-2.1282533, -2.24839333, -2.57164, -2.1012133, -2.75936, -1.9212933, NA, -2.58412, -2.3601733, -2.6395867, -2.3879067, -2.1324133, -2.31424, NA))
trees_all$tlp <- turgor$tlp[match(trees_all$sp, turgor$sp)]
#tlp for pist is NA. Running the models below with this gives the min(AICc) for lmm.combined. Removing pist, however (because of the tlp NA), and running AICc and anova shows the best model to be lmm.random.
#trees_all <- trees_all[!trees_all$sp == "pist", ]
##5b. add in ring porosity qualifications ####
ring_porosity <- data.frame("sp" = c("cagl",  "caovl", "cato", "fagr", "fram", "juni",  "litu",  "pist",  "qual",  "qupr",  "quru",  "quve", "caco", "frni"), "rp" = c("ring", "ring", "ring", "diffuse", "ring", "semi-ring", "diffuse", NA, "ring", "ring", "ring", "ring", "ring", "ring"))
trees_all$rp <- ring_porosity$rp[match(trees_all$sp, ring_porosity$sp)]
##5c. add in elevation data ####
elev <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/SCBI-ForestGEO-Data/spatial_data/elevation/full_stem_elevation_2013.csv")
trees_all$elev_m <- elev$dem_sigeo[match(trees_all$tree, elev$tag)]
##5d. add in dbh in each year 1999 ####
dbh <- trees_all[, c(1:4)]
dbh$dbh2013 <- elev$dbh[match(dbh$tree, elev$tag)]
#create df with bark thickness log values and intercept values from Krista's paper (supplemental info)
#https://besjournals.onlinelibrary.wiley.com/doi/epdf/10.1111/1365-2435.12470
#fagr does not have bark thickness measured because it is negligible
bark <- data.frame(
"sp" = c("acru", "fagr", "litu", "nysy", "caco", "cagl", "caovl", "cato", "fram", "juni", "qual", "qupr", "quru", "quve", "ulru"),
"bark_thick" = c(-2.564, 0, -0.659, -0.611, -1.917, -0.495, -2.504, -0.945, 0.318, -0.293, -1.231, -0.647, -0.789, 1.5, 1.133),
"intercept" = c(0.599, 0, 0.425, 0.413, 0.503, 0.316, 0.703, 0.396, 0.295, 0.385, 0.526, 0.423, 0.341, 0.053, -0.057))
dbh$bark_thick <- bark$bark_thick[match(dbh$sp, bark$sp)]
dbh$intercept <- bark$intercept[match(dbh$sp, bark$sp)]
#the main equation is based on ring widths. We have determined the equation to be
# rw(pointer_year) <- 0.5*dbh2013 - bark_thick*(dbh2013^intercept) - sum(rw(pointer_year):rw(end)). The first part of the equation is here. Summing the pointer years happens with the "q" df below in the loop.
dbh$rw_prelim <- (0.5*dbh$dbh2013) - (dbh$bark_thick*(dbh$dbh2013^dbh$intercept))
dbh$dbh_old <- "0" #in prep for below
dbh$dbh_old <- as.numeric(dbh$dbh_old)
for (i in seq(along=widths)){
df <- widths[[i]] #the list "widths" comes from #4a-4b
colnames(df) <- gsub("A", "", colnames(df)) #remove "A"
colnames(df) <- gsub("^0", "", colnames(df)) #remove leading 0
cols <- colnames(df) #define cols for below
colnames(df) <- gsub("^", "x", colnames(df)) #add "x" to make calling colnames below feasible
for (j in seq(along=cols)){
for (k in seq(along=colnames(df))){
ring_ind <- cols[[j]]
ring_col <- colnames(df)[[k]]
if(j==k){
#the output of this loop is 3 separate columns for each year's old dbh, hence why it is set to q as a dataframe before being combined below
q <- data.frame(sapply(pointer_years, function(x){
rw <- df[rownames(df)>=x, ]
ifelse(dbh$year == x & dbh$tree == ring_ind,
dbh$rw_prelim - sum(rw[, ring_col], na.rm=TRUE), 0)
}))
q$dbh_old <- q[,1] +q[,2] + q[,3] #add columns together
dbh$dbh_old <- dbh$dbh_old + q$dbh_old #combine with dbh
}
# check <- dbh[dbh$dbh_old == 0, ] #check if any tree was missed
trees_all$dbh_old <- dbh$dbh_old
trees_all$dbh_old <- ifelse(trees_all$dbh_old < 0, 0, trees_all$dbh_old)
trees_all$dbh_ln <- ifelse(trees_all$dbh_old == 0, NA, ln(trees_all$dbh_old))
##5e. remove all NAs ####
trees_all <- trees_all[complete.cases(trees_all), ]
##5f. remove resistance values >2 ####
trees_all <- trees_all[trees_all$resist.value <=2,]
View(trees_all)
precip <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/climate_sensitivity_cores/data/climate/Formated_CRU_SCBI_1901_2016.csv")
View(precip)
precip <- precip[precip$pre]
precip <- precip[, precip$pre]
precip <- precip[precip$pre, ]
View(precip)
#add in precipitation values
precip <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/climate_sensitivity_cores/data/climate/Formated_CRU_SCBI_1901_2016.csv")
precip <- precip[, c("pet", "pre", "PETminusPRE")]
#add in precipitation values
precip <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/climate_sensitivity_cores/data/climate/Formated_CRU_SCBI_1901_2016.csv")
precip <- precip[, c("year", "month", "pet", "pre", "PETminusPRE")]
precip_simple <- colSums((matrix(precip, nrow=12)))
range(precip$year)
precip_simple <- data.frame("year" = 1901:2016, "pet" = "", "pre" = "", "PETminusPRE" = "")
View(precip_simple)
precip_simple$pet <- colSums((matrix(precip$pet, nrow=12)))
View(precip_simple)
precip_simple$pre <- colSums((matrix(precip$pre, nrow=12)))
precip_simple$PETminusPRE <- colSums((matrix(precip$PETminusPRE, nrow=12)))
View(precip_simple)
trees_all$pre <- precip_simple$pre[match(trees_all$year, precip_simple$year)]
View(trees_all)
trees_all$PETminusPRE <- precip_simple$PETminusPRE[match(trees_all$year, precip_simple$year)]
##5e. remove all NAs ####
trees_all <- trees_all[complete.cases(trees_all), ]
##5f. remove resistance values >2 ####
trees_all <- trees_all[trees_all$resist.value <=2,]
library(lme4)
library(AICcmodavg) #aictab function
library(car)
library(piecewiseSEM) #for R^2 values for all model outputs in a list
library(MuMIn) #for R^2 values of one model output
response <- "resist.value"
effects <- c("position", "tlp", "rp", "elev_m", "dbh_ln", "pre", "PETminusPRE", "year", "(1 | sp / tree)")
#create all combinations of random / fixed effects
effects_comb <-
unlist( sapply( seq_len(length(effects)),
function(i) {
apply( combn(effects,i), 2, function(x) paste(x, collapse = "+"))
}))
# pair response with effect and sub out combinations that don't include random effects
#in general, if two variables are >70% correlated, you can toss one of them without significantly affecting the results
var_comb <- expand.grid(response, effects_comb)
var_comb <- var_comb[grepl("1", var_comb$Var2), ] #only keep in fixed/random combos
var_comb <- var_comb[grepl("year", var_comb$Var2), ] #keep year in for drought sake
# formulas for all combinations. $Var1 is the response, and $Var2 is the effect
# for good stats, you should have no more total parameters than 1/10th the number of observations in your dataset
formula_vec <- sprintf("%s ~ %s", var_comb$Var1, var_comb$Var2)
lmm_all <- lapply(formula_vec, function(x){
fit1 <- lmer(x, data = trees_all, REML=FALSE)
#fit1$coefficients <- coef( summary(fit1))
return(fit1)
})
names(lmm_all) <- formula_vec
var_aic <- aictab(lmm_all, second.ord=TRUE, sort=TRUE) #rank based on AICc
r <- rsquared(lmm_all) #gives R^2 values for models. "Marginal" is the R^2 for just the fixed effects, "Conditional" is the R^2 for everything.
formula_vec
View(var_aic)
View(r)
