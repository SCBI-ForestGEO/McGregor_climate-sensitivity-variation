change$tree <- gsub("X", "", change$tree)
change$tree <- gsub("^0", "", change$tree)
trees_subcanopy <- rbind(trees_subcanopy, change)
}
##rbind together ####
trees_all <- rbind(trees_canopy, trees_subcanopy)
trees_all$year <- as.numeric(trees_all$year)
#subset out NAs for resistance values (not necessary, bc lmm will automatically exclude them)
trees_all <- trees_all[!is.na(trees_all$resist.value), ]
##4e. determine proportion of resistance values per sp ####
prop <- data.frame("sp" = unique(trees_all$sp))
prop$value.over1 <- NA
prop$can.value.over1 <- NA
prop$sub.value.over1 <- NA
trees_all.sp <- unique(trees_all$sp)
for (i in seq(along=prop$sp)){
for (j in seq(along=unique(trees_all.sp))){
if (i==j){
temp <- trees_all[trees_all$sp == trees_all.sp[[j]] & trees_all$resist.value>=1, ]
temp <- temp[!is.na(temp$resist.value), ]
prop$value.over1[[i]] <- nrow(temp)
prop$can.value.over1[[i]] <- nrow(temp[temp$position == "canopy", ])
prop$sub.value.over1[[i]] <- nrow(temp[temp$position == "subcanopy", ])
}
##4f. add in turgor loss point values ####
#add in tlp values (from Krista github issue #6 https://github.com/SCBI-ForestGEO/McGregor_climate-sensitivity-variation/issues/6)
turgor <- data.frame("sp" = c("cagl", "caovl", "fagr", "fram", "juni", "litu", "pist", "qual", "qupr", "quru", "quve", "caco", "cato", "frni"), "tlp" = c(-2.1282533, -2.24839333, -2.57164, -2.1012133, -2.75936, -1.9212933, NA, -2.58412, -2.3601733, -2.6395867, -2.3879067, -2.1324133, -2.31424, NA))
trees_all$tlp <- turgor$tlp[match(trees_all$sp, turgor$sp)]
#tlp for pist is NA. Running the models below with this gives the min(AICc) for lmm.combined. Removing pist, however (because of the tlp NA), and running AICc and anova shows the best model to be lmm.random.
#trees_all <- trees_all[!trees_all$sp == "pist", ]
##4g. add in ring porosity qualifications ####
ring_porosity <- data.frame("sp" = c("cagl",  "caovl", "cato", "fagr", "fram", "juni",  "litu",  "pist",  "qual",  "qupr",  "quru",  "quve", "caco", "frni"), "rp" = c("ring", "ring", "ring", "diffuse", "ring", "semi-ring", "diffuse", NA, "ring", "ring", "ring", "ring", "ring", "ring"))
trees_all$rp <- ring_porosity$rp[match(trees_all$sp, ring_porosity$sp)]
##4h. add in elevation data ####
elev <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/SCBI-ForestGEO-Data/spatial_data/elevation/full_stem_elevation_2013.csv")
trees_all$elev_m <- elev$dem_sigeo[match(trees_all$tree, elev$tag)]
View(widths_can)
View(widths_sub)
canopy <- list()
widths_can <- list()
canopy_table <- NULL
for (i in seq(along=dirs_can)){
for (j in seq(along=sp_can)){
if (i==j){
file <- dirs_can[[i]]
rings <- read.rwl(file) #read in rwl file
area <- bai.in(rings) #convert to bai.in
testr <- res.comp(area, nb.yrs=5, res.thresh.neg = 30, series.thresh = 50) #get resilience metrics
canopy[[i]] <- testr
widths_can[[i]] <- rings #used in 4i.
testr_table <- data.frame(testr$out)
testr_table <- testr_table[testr_table$nb.series > 4, ] #remove where there are < 4 series
testr_table$sp <- sp_can[[j]]
testr_table$position <- "canopy"
canopy_table <- rbind(canopy_table, testr_table)
}
values <- paste0(sp_can, "_can_res")
names(canopy) <- values
values <- paste0(sp_can, "_canopy")
names(widths_can) <- values
##4a. canopy ####
setwd("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/SCBI-ForestGEO-Data/tree_cores/chronologies/current_chronologies/complete/separated by canopy position/canopy_cores")
canopy <- list()
widths_can <- list()
canopy_table <- NULL
for (i in seq(along=dirs_can)){
for (j in seq(along=sp_can)){
if (i==j){
file <- dirs_can[[i]]
rings <- read.rwl(file) #read in rwl file
area <- bai.in(rings) #convert to bai.in
testr <- res.comp(area, nb.yrs=5, res.thresh.neg = 30, series.thresh = 50) #get resilience metrics
canopy[[i]] <- testr
widths_can[[i]] <- rings #used in 4i.
testr_table <- data.frame(testr$out)
testr_table <- testr_table[testr_table$nb.series > 4, ] #remove where there are < 4 series
testr_table$sp <- sp_can[[j]]
testr_table$position <- "canopy"
canopy_table <- rbind(canopy_table, testr_table)
}
values <- paste0(sp_can, "_can_res")
names(canopy) <- values
values <- paste0(sp_can, "_canopy")
names(widths_can) <- values
##4b. subcanopy ####
setwd("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/SCBI-ForestGEO-Data/tree_cores/chronologies/current_chronologies/complete/separated by canopy position/subcanopy_cores")
subcanopy <- list()
widths_sub <- list()
subcanopy_table <- NULL
for (i in seq(along=dirs_subcan)){
for (j in seq(along=sp_subcan)){
if (i==j){
file <- dirs_subcan[[i]]
rings <- read.rwl(file) #read in rwl file
area <- bai.in(rings) #convert to bai.in
test <- res.comp(area, nb.yrs=5, res.thresh.neg = 30, series.thresh = 50) #get resilience metrics
subcanopy[[i]] <- test
widths_sub[[i]] <- rings #used in 4i.
test_table <- data.frame(test$out)
test_table <- test_table[test_table$nb.series > 4, ] #remove where there are < 4 series
test_table$sp <- sp_subcan[[j]]
test_table$position <- "subcanopy"
subcanopy_table <- rbind(subcanopy_table, test_table)
}
values_sub <- paste0(sp_subcan, "_subcan_res")
names(subcanopy) <- values_sub
values <- paste0(sp_can, "_subcanopy")
names(widths_sub) <- values
View(widths_sub)
View(rings)
widths_sub[[i]] <- rings
View(widths_sub)
rm(widths_sub)
widths_sub <- list()
widths_sub[[i]] <- rings #used in 4i.
View(widths_sub)
rings
class(widths_sub)
widths_sub <- list()
subcanopy <- list()
subcanopy_table <- NULL
for (i in seq(along=dirs_subcan)){
for (j in seq(along=sp_subcan)){
if (i==j){
file <- dirs_subcan[[i]]
rings <- read.rwl(file) #read in rwl file
area <- bai.in(rings) #convert to bai.in
test <- res.comp(area, nb.yrs=5, res.thresh.neg = 30, series.thresh = 50) #get resilience metrics
subcanopy[[i]] <- test
widths_sub[[i]] <- rings #used in 4i.
test_table <- data.frame(test$out)
test_table <- test_table[test_table$nb.series > 4, ] #remove where there are < 4 series
test_table$sp <- sp_subcan[[j]]
test_table$position <- "subcanopy"
subcanopy_table <- rbind(subcanopy_table, test_table)
}
View(widths_sub)
values <- paste0(sp_can, "_subcanopy")
values <- paste0(sp_subcan, "_subcanopy")
names(widths_sub) <- values
View(widths_sub)
library(pointRes)
library(dplR)
library(data.table)
##4a. canopy ####
setwd("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/SCBI-ForestGEO-Data/tree_cores/chronologies/current_chronologies/complete/separated by canopy position/canopy_cores")
dirs_can <- dir("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/SCBI-ForestGEO-Data/tree_cores/chronologies/current_chronologies/complete/separated by canopy position/canopy_cores", pattern = "_canopy.rwl")
dirs_can <- dirs_can[dirs_can != "frni_canopy.rwl" & dirs_can != "frni_drop_canopy.rwl" & dirs_can != "caco_drop_canopy.rwl"]
sp_can <- gsub("_drop_canopy.rwl", "", dirs_can)
canopy <- list()
widths_can <- list()
canopy_table <- NULL
for (i in seq(along=dirs_can)){
for (j in seq(along=sp_can)){
if (i==j){
file <- dirs_can[[i]]
rings <- read.rwl(file) #read in rwl file
area <- bai.in(rings) #convert to bai.in
testr <- res.comp(area, nb.yrs=5, res.thresh.neg = 30, series.thresh = 50) #get resilience metrics
canopy[[i]] <- testr
widths_can[[i]] <- rings #used in 4i.
testr_table <- data.frame(testr$out)
testr_table <- testr_table[testr_table$nb.series > 4, ] #remove where there are < 4 series
testr_table$sp <- sp_can[[j]]
testr_table$position <- "canopy"
canopy_table <- rbind(canopy_table, testr_table)
}
values <- paste0(sp_can, "_can_res")
names(canopy) <- values
values <- paste0(sp_can, "_canopy")
names(widths_can) <- values
##4b. subcanopy ####
setwd("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/SCBI-ForestGEO-Data/tree_cores/chronologies/current_chronologies/complete/separated by canopy position/subcanopy_cores")
dirs_subcan <- dir("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/SCBI-ForestGEO-Data/tree_cores/chronologies/current_chronologies/complete/separated by canopy position/subcanopy_cores", pattern = "_subcanopy.rwl")
#dirs_subcan <- dirs_subcan[dirs_subcan != "frni_drop_subcanopy.rwl" & dirs_subcan != "caco_drop_subcanopy.rwl"]
sp_subcan <- gsub("_drop_subcanopy.rwl", "", dirs_subcan)
subcanopy <- list()
widths_sub <- list()
subcanopy_table <- NULL
for (i in seq(along=dirs_subcan)){
for (j in seq(along=sp_subcan)){
if (i==j){
file <- dirs_subcan[[i]]
rings <- read.rwl(file) #read in rwl file
area <- bai.in(rings) #convert to bai.in
test <- res.comp(area, nb.yrs=5, res.thresh.neg = 30, series.thresh = 50) #get resilience metrics
subcanopy[[i]] <- test
widths_sub[[i]] <- rings #used in 4i.
test_table <- data.frame(test$out)
test_table <- test_table[test_table$nb.series > 4, ] #remove where there are < 4 series
test_table$sp <- sp_subcan[[j]]
test_table$position <- "subcanopy"
subcanopy_table <- rbind(subcanopy_table, test_table)
}
values_sub <- paste0(sp_subcan, "_subcan_res")
names(subcanopy) <- values_sub
values <- paste0(sp_subcan, "_subcanopy")
names(widths_sub) <- values
##4c. df for pointer years of all trees combined ####
full_ind <- rbind(canopy_table, subcanopy_table) #full table of indices for canopy and subcanopy cores
pointers <- full_ind[full_ind$nature == -1, ]
library(dplyr)
years_point <- count(pointers, vars=year) #counts the occurrences of each unique year
colnames(years_point) <- c("yr", "n.pointer")
years_point <- years_point[order(years_point$n.pointer, decreasing=TRUE), ]
setwd("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/McGregor_climate-sensitivity-variation")
#write.csv(pointers, "occurrence_of_pointer_yrs.csv", row.names=FALSE)
##4d. resistance metrics for all trees ####
neil_list <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/McGregor_climate-sensitivity-variation/core_list_for_neil.csv", stringsAsFactors = FALSE)
neil_list$tag <- paste0("X", neil_list$tag) #to match the colnames of can_resist below
pointer_years <- head(years_point$yr) #from above in #4c
pointer_years <- pointer_years[!pointer_years %in% c(1911, 1947, 1991)]
##canopy ####
#this loop says, for the different species in the list "canopy" (names(canopy)), create a dataframe of only the resistance index. Make a list of the colnames, which are the individual trees. Then, assign species identifiers for each one from Neil's core list, subset by the defined pointer years, and melt the data before rbinding.
tag_n <- names(canopy)
trees_canopy <- NULL
for (i in seq(along=1:length(tag_n))){
can_resist <- data.frame(canopy[[i]]$resist)
years <- rownames(can_resist)
colnames(can_resist) <- gsub("A", "", colnames(can_resist))
tree_series <- colnames(can_resist)
# for (j in seq(along=tree_series)){
#  trees <- tree_series[[j]]
ind <- can_resist
ind_neil <- neil_list[neil_list$tag %in% tree_series, ]
#  colnames(ind) <- trees
ind$year <- years
ind$sp <- unique(ind_neil$sp)
ind$position <- "canopy"
ind <- ind[ind$year %in% pointer_years, ]
change <- melt(ind)
setnames(change, old=c("variable", "value"), new=c("tree", "resist.value"))
change$tree <- gsub("X", "", change$tree)
change$tree <- gsub("^0", "", change$tree)
trees_canopy <- rbind(trees_canopy, change)
}
##subcanopy ####
#this loop says, for the different species in the list "subcanopy" (names(subcanopy)), create a dataframe of only the resistance index. Make a list of the colnames, which are the individual trees. Then, assign species identifiers for each one from Neil's core list, subset by the defined pointer years, and melt the data before rbinding.
tag_n <- names(subcanopy)
trees_subcanopy <- NULL
for (i in seq(along=1:length(tag_n))){
sub_resist <- data.frame(subcanopy[[i]]$resist)
years <- rownames(sub_resist)
colnames(sub_resist) <- gsub("A", "", colnames(sub_resist))
tree_series <- colnames(sub_resist)
# for (j in seq(along=tree_series)){
#  trees <- tree_series[[j]]
ind <- sub_resist
ind_neil <- neil_list[neil_list$tag %in% tree_series, ]
#  colnames(ind) <- trees
ind$year <- years
ind$sp <- unique(ind_neil$sp)
ind$position <- "subcanopy"
ind <- ind[ind$year %in% pointer_years, ]
change <- melt(ind)
setnames(change, old=c("variable", "value"), new=c("tree", "resist.value"))
change$tree <- gsub("X", "", change$tree)
change$tree <- gsub("^0", "", change$tree)
trees_subcanopy <- rbind(trees_subcanopy, change)
}
##rbind together ####
trees_all <- rbind(trees_canopy, trees_subcanopy)
trees_all$year <- as.numeric(trees_all$year)
#subset out NAs for resistance values (not necessary, bc lmm will automatically exclude them)
trees_all <- trees_all[!is.na(trees_all$resist.value), ]
##4e. determine proportion of resistance values per sp ####
prop <- data.frame("sp" = unique(trees_all$sp))
prop$value.over1 <- NA
prop$can.value.over1 <- NA
prop$sub.value.over1 <- NA
trees_all.sp <- unique(trees_all$sp)
for (i in seq(along=prop$sp)){
for (j in seq(along=unique(trees_all.sp))){
if (i==j){
temp <- trees_all[trees_all$sp == trees_all.sp[[j]] & trees_all$resist.value>=1, ]
temp <- temp[!is.na(temp$resist.value), ]
prop$value.over1[[i]] <- nrow(temp)
prop$can.value.over1[[i]] <- nrow(temp[temp$position == "canopy", ])
prop$sub.value.over1[[i]] <- nrow(temp[temp$position == "subcanopy", ])
}
##4f. add in turgor loss point values ####
#add in tlp values (from Krista github issue #6 https://github.com/SCBI-ForestGEO/McGregor_climate-sensitivity-variation/issues/6)
turgor <- data.frame("sp" = c("cagl", "caovl", "fagr", "fram", "juni", "litu", "pist", "qual", "qupr", "quru", "quve", "caco", "cato", "frni"), "tlp" = c(-2.1282533, -2.24839333, -2.57164, -2.1012133, -2.75936, -1.9212933, NA, -2.58412, -2.3601733, -2.6395867, -2.3879067, -2.1324133, -2.31424, NA))
trees_all$tlp <- turgor$tlp[match(trees_all$sp, turgor$sp)]
#tlp for pist is NA. Running the models below with this gives the min(AICc) for lmm.combined. Removing pist, however (because of the tlp NA), and running AICc and anova shows the best model to be lmm.random.
#trees_all <- trees_all[!trees_all$sp == "pist", ]
##4g. add in ring porosity qualifications ####
ring_porosity <- data.frame("sp" = c("cagl",  "caovl", "cato", "fagr", "fram", "juni",  "litu",  "pist",  "qual",  "qupr",  "quru",  "quve", "caco", "frni"), "rp" = c("ring", "ring", "ring", "diffuse", "ring", "semi-ring", "diffuse", NA, "ring", "ring", "ring", "ring", "ring", "ring"))
trees_all$rp <- ring_porosity$rp[match(trees_all$sp, ring_porosity$sp)]
##4h. add in elevation data ####
elev <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/SCBI-ForestGEO-Data/spatial_data/elevation/full_stem_elevation_2013.csv")
trees_all$elev_m <- elev$dem_sigeo[match(trees_all$tree, elev$tag)]
widths <- c(widths_can, widths_subcan) #combine into one, then delete
widths <- c(widths_can, widths_sub) #combine into one, then delete
dbh <- trees_all[, c(1:4)]
dbh$id <- paste0(dbh$sp, "_", dbh$position)
dbh$dbh2013 <- elev$dbh[match(dbh$tree, elev$tag)]
dbh$dbh_old <- "0"
dbh$dbh_old <- as.numeric(dbh$dbh_old)
for (i in seq(along=widths)){
df <- widths[[i]]
colnames(df) <- gsub("A", "", colnames(df))
cols <- colnames(df)
colnames(df) <- gsub("^", "x", colnames(df))
for (j in seq(along=cols)){
for (k in seq(along=colnames(df))){
ring_ind <- cols[[j]]
ring_col <- colnames(df)[[k]]
if(j==k){
q <- data.frame(sapply(pointer_years, function(x){
rw <- df[rownames(df)>=x, ]
ifelse(dbh$year == x & dbh$tree == ring_ind,
sum(rw[, ring_col], na.rm=TRUE), 0)
}))
q$dbh_old <- q[,1] +q[,2] + q[,3]
dbh$dbh_old <- dbh$dbh_old + q$dbh_old
}
View(dbh)
check <- dbh[dbh$dbh_old == 0, ]
View(check)
View(widths$caco_subcanopy)
View(widths)
i=12
df <- widths[[i]]
View(df)
colnames(df) <- gsub("A", "", colnames(df)) #remove "A"
colnames(df) <- gsub("^0", "", colnames(df)) #remove leading 0
View(df)
dbh <- NULL
dbh <- trees_all[, c(1:4)]
dbh$id <- paste0(dbh$sp, "_", dbh$position)
dbh$dbh2013 <- elev$dbh[match(dbh$tree, elev$tag)]
dbh$dbh_old <- "0"
dbh$dbh_old <- as.numeric(dbh$dbh_old)
for (i in seq(along=widths)){
df <- widths[[i]]
colnames(df) <- gsub("A", "", colnames(df)) #remove "A"
colnames(df) <- gsub("^0", "", colnames(df)) #remove leading 0
cols <- colnames(df)
colnames(df) <- gsub("^", "x", colnames(df))
for (j in seq(along=cols)){
for (k in seq(along=colnames(df))){
ring_ind <- cols[[j]]
ring_col <- colnames(df)[[k]]
if(j==k){
q <- data.frame(sapply(pointer_years, function(x){
rw <- df[rownames(df)>=x, ]
ifelse(dbh$year == x & dbh$tree == ring_ind,
sum(rw[, ring_col], na.rm=TRUE), 0)
}))
q$dbh_old <- q[,1] +q[,2] + q[,3]
dbh$dbh_old <- dbh$dbh_old + q$dbh_old
}
check <- dbh[dbh$dbh_old == 0, ]
sapply(pointer_years, function(x){
rw <- df[rownames(df)>=x, ]
ifelse(dbh$year == x & dbh$tree == ring_ind,
sum(rw[, ring_col], na.rm=TRUE), 0)
sapply(pointer_years, function(x){
rw <- df[rownames(df)>=x, ]
ifelse(dbh$year == x & dbh$tree == ring_ind,
sum(rw[, ring_col], na.rm=TRUE), 0)
})
)
#the output of this loop is 3 separate columns for each year's old dbh, hence why it is set to q as a dataframe before being combined below
q <- data.frame(sapply(pointer_years, function(x){
rw <- df[rownames(df)>=x, ]
ifelse(dbh$year == x & dbh$tree == ring_ind,
sum(rw[, ring_col], na.rm=TRUE), 0)
}))
View(q)
q$dbh_old <- q[,1] +q[,2] + q[,3] #add columns together
View(q)
i=1
df <- widths[[i]]
colnames(df) <- gsub("A", "", colnames(df)) #remove "A"
colnames(df) <- gsub("^0", "", colnames(df)) #remove leading 0
cols <- colnames(df) #define cols for below
colnames(df) <- gsub("^", "x", colnames(df)) #add "x" to make calling colnames below feasible
j=1
k=1
ring_ind <- cols[[j]]
ring_col <- colnames(df)[[k]]
#the output of this loop is 3 separate columns for each year's old dbh, hence why it is set to q as a dataframe before being combined below
q <- data.frame(sapply(pointer_years, function(x){
rw <- df[rownames(df)>=x, ]
ifelse(dbh$year == x & dbh$tree == ring_ind,
sum(rw[, ring_col], na.rm=TRUE), 0)
}))
q$dbh_old <- q[,1] +q[,2] + q[,3] #add columns together
View(q)
View(dbh)
View(q)
View(dbh)
df <- widths[3]
df <- widths[[3]]
rw <- df[rownames(df)>=1966, ]
sum(rw$`60111`)
bark <- data.frame("sp" = c("acru", "fagr", "litu", "nysy", "caco", "cagl", "caovl", "cato", "fram", "juni", "qual", "qupr", "quru", "quve", "ulru"), "bark_thick" = c(-2.564, 0, -0.659, -0.611, -1.917, -0.495, -2.504, -0.945, 0.318, -0.293, -1.231, -0.647, -0.789, 1.5, 1.133))
View(bark)
bark <- data.frame(
"sp" = c("acru", "fagr", "litu", "nysy", "caco", "cagl", "caovl", "cato", "fram", "juni", "qual", "qupr", "quru", "quve", "ulru"),
"bark_thick" = c(-2.564, 0, -0.659, -0.611, -1.917, -0.495, -2.504, -0.945, 0.318, -0.293, -1.231, -0.647, -0.789, 1.5, 1.133),
"intercept" = c(0.599, 0, 0.425, 0.413, 0.503, 0.316, 0.703, 0.396, 0.295, 0.385, 0.526, 0.423, 0.341, 0.053, -0.057))
View(bark)
rm(dbh)
##5d. add in dbh in each year 1999 ####
dbh <- trees_all[, c(1:4)]
dbh$dbh2013 <- elev$dbh[match(dbh$tree, elev$tag)]
#create df with bark thickness log values and intercept values from Krista's paper https://besjournals.onlinelibrary.wiley.com/doi/epdf/10.1111/1365-2435.12470
bark <- data.frame(
"sp" = c("acru", "fagr", "litu", "nysy", "caco", "cagl", "caovl", "cato", "fram", "juni", "qual", "qupr", "quru", "quve", "ulru"),
"bark_thick" = c(-2.564, 0, -0.659, -0.611, -1.917, -0.495, -2.504, -0.945, 0.318, -0.293, -1.231, -0.647, -0.789, 1.5, 1.133),
"intercept" = c(0.599, 0, 0.425, 0.413, 0.503, 0.316, 0.703, 0.396, 0.295, 0.385, 0.526, 0.423, 0.341, 0.053, -0.057))
dbh$bark_thick <- bark$bark_thick[match(dbh$sp, bark$sp)]
dbh$intercept <- bark$intercept[match(dbh$sp, bark$sp)]
View(dbh)
dbh$rw_prelim <- (0.5*dbh$dbh2013) - (dbh$bark_thick*(dbh$dbh2013^dbh$intercept))
View(dbh)
dbh$dbh_old <- "0" #in prep for below
dbh$dbh_old <- as.numeric(dbh$dbh_old)
i=1
j=1
k=1
df <- widths[[i]] #the list "widths" comes from #4a-4b
colnames(df) <- gsub("A", "", colnames(df)) #remove "A"
colnames(df) <- gsub("^0", "", colnames(df)) #remove leading 0
cols <- colnames(df) #define cols for below
colnames(df) <- gsub("^", "x", colnames(df)) #add "x" to make calling colnames below feasible
ring_ind <- cols[[j]]
ring_col <- colnames(df)[[k]]
#the output of this loop is 3 separate columns for each year's old dbh, hence why it is set to q as a dataframe before being combined below
q <- data.frame(sapply(pointer_years, function(x){
rw <- df[rownames(df)>=x, ]
ifelse(dbh$year == x & dbh$tree == ring_ind,
dbh$rw_prelim - sum(rw[, ring_col], na.rm=TRUE), 0)
}))
View(q)
q$dbh_old <- q[,1] +q[,2] + q[,3] #add columns together
dbh$dbh_old <- dbh$dbh_old + q$dbh_old #combine with dbh
View(dbh)
for (i in seq(along=widths)){
df <- widths[[i]] #the list "widths" comes from #4a-4b
colnames(df) <- gsub("A", "", colnames(df)) #remove "A"
colnames(df) <- gsub("^0", "", colnames(df)) #remove leading 0
cols <- colnames(df) #define cols for below
colnames(df) <- gsub("^", "x", colnames(df)) #add "x" to make calling colnames below feasible
for (j in seq(along=cols)){
for (k in seq(along=colnames(df))){
ring_ind <- cols[[j]]
ring_col <- colnames(df)[[k]]
if(j==k){
#the output of this loop is 3 separate columns for each year's old dbh, hence why it is set to q as a dataframe before being combined below
q <- data.frame(sapply(pointer_years, function(x){
rw <- df[rownames(df)>=x, ]
ifelse(dbh$year == x & dbh$tree == ring_ind,
dbh$rw_prelim - sum(rw[, ring_col], na.rm=TRUE), 0)
}))
q$dbh_old <- q[,1] +q[,2] + q[,3] #add columns together
dbh$dbh_old <- dbh$dbh_old + q$dbh_old #combine with dbh
}
View(dbh)
trees_all$dbh_old <- dbh$dbh_old
View(trees_all)
#define response and effects
response <- "resist.value"
effects <- c("position", "tlp", "rp", "elev_m", "(1 | year)", "(1 | sp / tree)")
#create all combinations of random / fixed effects
effects_comb <-
unlist( sapply( seq_len(length(effects)),
function(i) {
apply( combn(effects,i), 2, function(x) paste(x, collapse = "+"))
}))
# pair response with effect and sub out combinations that don't include random effects
var_comb <- expand.grid(response, effects_comb)
var_comb <- var_comb[grepl("1", var_comb$Var2), ] #only keep in fixed/random combos
var_comb <- var_comb[grepl("year", var_comb$Var2), ] #keep year in for drought sake
# formulas for all combinations. $Var1 is the response, and $Var2 is the effect
formula_vec <- sprintf("%s ~ %s", var_comb$Var1, var_comb$Var2)
formula_vec
effects <- c("position", "tlp", "rp", "elev_m", "dbh_old", "(1 | year)", "(1 | sp / tree)")
#create all combinations of random / fixed effects
effects_comb <-
unlist( sapply( seq_len(length(effects)),
function(i) {
apply( combn(effects,i), 2, function(x) paste(x, collapse = "+"))
}))
# pair response with effect and sub out combinations that don't include random effects
var_comb <- expand.grid(response, effects_comb)
var_comb <- var_comb[grepl("1", var_comb$Var2), ] #only keep in fixed/random combos
var_comb <- var_comb[grepl("year", var_comb$Var2), ] #keep year in for drought sake
# formulas for all combinations. $Var1 is the response, and $Var2 is the effect
formula_vec <- sprintf("%s ~ %s", var_comb$Var1, var_comb$Var2)
formula_vec
# create list of model outputs
lmm_all <- lapply(formula_vec, function(x){
fit1 <- lmer(x, data = trees_all, REML=FALSE)
#fit1$coefficients <- coef( summary(fit1))
return(fit1)
})
library(lme4)
library(AICcmodavg)
library(car)
# create list of model outputs
lmm_all <- lapply(formula_vec, function(x){
fit1 <- lmer(x, data = trees_all, REML=FALSE)
#fit1$coefficients <- coef( summary(fit1))
return(fit1)
})
names(lmm_all) <- formula_vec
var_aic <- aictab(lmm_all, second.ord=TRUE, sort=TRUE) #rank based on AICc
View(var_aic)
