ind[, 1:(ncol(ind) -3)] <- round(ind[, 1:(ncol(ind) -3)], 2)
change <- melt(ind)
setnames(change, old=c("variable", "value"), new=c("tree", "resist.value"))
change$tree <- gsub("X", "", change$tree)
change$tree <- gsub("^0", "", change$tree)
trees_canopy <- rbind(trees_canopy, change)
}
###subcanopy ####
#this loop says, for the different species in the list "subcanopy" (names(subcanopy)), create a dataframe of only the resistance index. Make a list of the colnames, which are the individual trees. Then, assign species identifiers for each one from Neil's core list, subset by the defined pointer years, and melt the data before rbinding.
tag_n <- names(subcanopy)
trees_subcanopy <- NULL
for (i in seq(along=1:length(tag_n))){
sub_resist <- data.frame(subcanopy[[i]]$resist)
years <- rownames(sub_resist)
colnames(sub_resist) <- gsub("A", "", colnames(sub_resist))
tree_series <- colnames(sub_resist)
ind <- sub_resist
ind_neil <- neil_list[neil_list$tag %in% tree_series, ]
ind$year <- years
ind$sp <- unique(ind_neil$sp)
ind$position <- "subcanopy"
ind <- ind[ind$year %in% pointer_years, ]
## these three lines of code are for taking the mean of 1964-1966,
## since it was a multi-year drought. We're calling it 1966 for simplicity.
ind["1966", 1:(ncol(ind) -3)] <- colMeans(ind[c(1:3), 1:(ncol(ind) -3)])
ind <- ind[-c(1,2), ]
ind[, 1:(ncol(ind) -3)] <- round(ind[, 1:(ncol(ind) -3)], 2)
change <- melt(ind)
setnames(change, old=c("variable", "value"), new=c("tree", "resist.value"))
change$tree <- gsub("X", "", change$tree)
change$tree <- gsub("^0", "", change$tree)
trees_subcanopy <- rbind(trees_subcanopy, change)
}
###rbind together ####
trees_all <- rbind(trees_canopy, trees_subcanopy)
trees_all$year <- as.numeric(trees_all$year)
#subset out NAs for resistance values (not necessary, bc lmm will automatically exclude them)
trees_all <- trees_all[!is.na(trees_all$resist.value), ]
trees_all$year <- as.character(trees_all$year)
library(ggplot2)
library(devtools) #for sourcing functions for regression equations
library(rgdal) #to read in shapefiles
library(broom) #for the tidy function
library(sf) #for mapping
library(ggthemes) #for removing graticules when making pdf
library(rgeos) #for distance calculation
library(RCurl) #for reading in URLs
library(readxl)
library(raster) #for TWI
library(elevatr) #for TWI
library(dynatopmodel) #for TWI
##5a. add in ring porosity qualifications ####
ring_porosity <- data.frame("sp" = c("cagl",  "caovl", "cato", "fagr", "fram", "juni",  "litu",  "pist",  "qual",  "qupr",  "quru",  "quve", "caco", "frni"), "rp" = c("ring", "ring", "ring", "diffuse", "ring", "semi-ring", "diffuse", NA, "ring", "ring", "ring", "ring", "ring", "ring"))
trees_all$rp <- ring_porosity$rp[match(trees_all$sp, ring_porosity$sp)]
#gives count of each rp value
rp_test <- trees_all[!duplicated(trees_all$tree), ]
rp_test$tree <- as.numeric(rp_test$tree)
ggplot(data = rp_test) +
aes(x = rp) +
geom_bar(fill = "#0c4c8a") +
theme_minimal() +
facet_wrap(vars(position))
##5b. add in leaf traits ####
#this comes from the hydraulic traits repo, "SCBI_all_traits_table_species_level.csv"
##leaf traits gained from this include PLA_dry_percent, LMA_g_per_m2, Chl_m2_per_g, and WD [wood density]
leaf_traits <- read.csv(text=getURL("https://raw.githubusercontent.com/EcoClimLab/HydraulicTraits/master/data/SCBI/processed_trait_data/SCBI_all_traits_table_species_level.csv?token=AJNRBELAM347ZL7W3JUGZ3S5IHYKE"), stringsAsFactors = FALSE)
leaf_traits <- leaf_traits[, c(1,8,12,26,28)]
for (i in seq(along=2:ncol(leaf_traits))){
trait <- colnames(leaf_traits[2:ncol(leaf_traits)])
trees_all[, trait[[i]]] <- leaf_traits[, trait[[i]]][match(trees_all$sp, leaf_traits$sp)]
}
##5bi. add in SLA data (here for reference) ####
### I initially was going to include SLA but Krista mentioned that SLA is the inverse of LMA, so for the purposes of this modelling, they're equal. We're focused more on having SCBI-specific data when possible, so we're using LMA.
# traits_sla <- read_excel("data/traits/photosynthesis_traits.xlsx", sheet = "Data")
# traits_sla$species <- paste(traits_sla$Genus, traits_sla$Species)
# SLA <- traits_sla
# SLA$Genus.spp <- paste0(gsub("^(..).*", "\\1", SLA$Genus.spp),
#                         gsub("^.* (..).*", "\\1", SLA$Genus.spp))
# SLA$Genus.spp <- tolower(SLA$Genus.spp)
# SLA <- SLA[SLA$Genus %in% c("Carya", "Fraxinus", "Fagus", "Juglans", "Liriodendron", "Pinus", "Quercus"), ]
# SLA <- SLA[SLA$Genus.spp %in% neil_sp & !is.na(SLA$SLA), ]
# SLA <- SLA[order(SLA$Genus.spp), ]
# SLA <- SLA[c(10,20,28)]
# unique(SLA$Genus.spp)
#
# mean_SLA <-
#   group_by(SLA, Genus.spp) %>%
#   summarize(SLA_mean = mean(SLA))
#
# trees_all$SLA_mean <- mean_SLA$SLA_mean[match(trees_all$sp, mean_SLA$Genus.spp)]
##5bii. add in p50 and p88 ####
#after review, we have decided to not focus on p50 and p80
# #get P50 from traits table
# hydra <- read.csv(text=getURL("https://raw.githubusercontent.com/EcoClimLab/HydraulicTraits/master/results/SCBI_best_fits.csv?token=AJNRBEP62SALMQHAV45TP2S5HCCPK"))
#
# #Anderegg 2018 found that p50 and p80 came out significant in modelling
# trees_all$p50.MPa <- hydra$psi_0.5_kl50[match(trees_all$sp, hydra$data.type)]
# trees_all$p80.MPa <- hydra$psi_0.5_kl80[match(trees_all$sp, hydra$data.type)]
#after review, we have decided to not focus on pmin or HSM
# trees_all$Pmin.MPa <- 1.1122*trees_all$mean_TLP_Mpa + 0.3849
# trees_all$hsm.MPa <- trees_all$Pmin.MPa - trees_all$p50.MPa
# meh <- trees_all[!duplicated(trees_all$sp), ]
# meh <- meh[, c("sp", "mean_TLP_Mpa", "Pmin.MPa")]
# meh$psi_Kmax_0.5 <- hydra$psi_Kmax_0.5[match(meh$sp, hydra$data.type)]
#
##5c. add in elevation data ####
elev <- read.csv(text=getURL("https://raw.githubusercontent.com/SCBI-ForestGEO/SCBI-ForestGEO-Data/master/spatial_data/elevation/full_stem_elevation_2013.csv"))
trees_all$elev.m <- elev$dem_sigeo[match(trees_all$tree, elev$tag)]
##5d. add in distance to water ####
## mapping code here is taken from survey_maps.R in Dendrobands Rscripts folder.
## I have not found a way to make this not involve personal directories without moving all the data to my folder, which I'm hesitant about doing due to data redundancy.
scbi_plot <- readOGR("D:/Dropbox (Smithsonian)/Github_Ian/SCBI-ForestGEO-Data/spatial_data/shapefiles/20m_grid.shp")
deer <- readOGR("D:/Dropbox (Smithsonian)/Github_Ian/SCBI-ForestGEO-Data/spatial_data/shapefiles/deer_exclosure_2011.shp")
roads <- readOGR("D:/Dropbox (Smithsonian)/Github_Ian/SCBI-ForestGEO-Data/spatial_data/shapefiles/SCBI_roads_edits.shp")
streams <- readOGR("D:/Dropbox (Smithsonian)/Github_Ian/SCBI-ForestGEO-Data/spatial_data/shapefiles/SCBI_streams_edits.shp")
NS_divide <- readOGR("D:/Dropbox (Smithsonian)/Github_Ian/Dendrobands/resources/maps/shapefiles/NS_divide1.shp")
#convert all shp to dataframe so that it can be used by ggplot
#if tidy isn't working, can also do: xxx_df <- as(xxx, "data.frame")
scbi_plot_df <- tidy(scbi_plot)
deer_df <- tidy(deer)
roads_df <- tidy(roads)
streams_df <- tidy(streams)
NS_divide_df <- tidy(NS_divide)
## now we get into code specific for this analysis
neil_map <- neil_list
neil_map$tag <- gsub("X", "", neil_map$tag)
neil_map$tag <- as.numeric(neil_map$tag)
neil_map <- neil_map[, c(1:6,23:24)]
map <- ggplot() +
geom_path(data = scbi_plot_df, aes(x = long, y = lat, group = group))+
geom_path(data=roads_df, aes(x=long, y=lat, group=group),
color="#996600", linetype=2)+
geom_path(data=streams_df, aes(x=long, y=lat, group=group), color="blue")+
geom_path(data=deer_df, aes(x=long, y=lat, group=group), size=1.1)+
geom_point(data=neil_map, aes(x=NAD83_X, y=NAD83_Y), shape=19)+
geom_text(data=neil_map, aes(x=NAD83_X, y=NAD83_Y, label=tag),
size=3, hjust=1.25, nudge_y=-1, nudge_x=1, check_overlap=TRUE)+
theme(plot.title=element_text(vjust=0.1))+
coord_sf(crs = "crs = +proj=merc", xlim=c(747350,747800), ylim=c(4308500, 4309125))
## calculating the distance requires some conversion. First, the points of the cored trees from neil_map must be in their own dataframe before they can be converted to a SpatialPoints object.
neil_map_sub <- neil_map[, c(7:8)]
neil_points <- SpatialPoints(neil_map_sub, proj4string = CRS(as.character("+proj=merc")))
## here, the minimum distance to water is calculated before binding with neil_map.
## A warning says that neil_points and streams are projected differently, but the output has been verified to be accurate.
distance_water <- data.frame(apply(gDistance(neil_points, streams, byid=TRUE), 2, min))
colnames(distance_water) <- "distance_water"
distance <- cbind(neil_map, distance_water)
## next, do a log transformation on the distances before adding as a column to trees_all (similar to the dbh calculations below)
distance$distance.ln.m <- log(distance$distance_water)
trees_all$distance.ln.m <- distance$distance.ln.m[match(trees_all$tree, distance$tag)]
## this is to double check the accuracy of the map.
distance_short <- distance[distance$distance_water <= 30, ]
map <- ggplot() +
geom_path(data = scbi_plot_df, aes(x = long, y = lat, group = group))+
geom_path(data=roads_df, aes(x=long, y=lat, group=group),
color="#996600", linetype=2)+
geom_path(data=streams_df, aes(x=long, y=lat, group=group), color="blue")+
geom_path(data=deer_df, aes(x=long, y=lat, group=group), size=1.1)+
geom_point(data=distance_short, aes(x=NAD83_X, y=NAD83_Y), shape=19)+
geom_text(data=distance_short, aes(x=NAD83_X, y=NAD83_Y, label=tag),
size=3, hjust=1.25, nudge_y=-1, nudge_x=1, check_overlap=TRUE)+
theme(plot.title=element_text(vjust=0.1))+
coord_sf(crs = "crs = +proj=merc", xlim=c(747350,747800), ylim=c(4308500, 4309125))
##5e. add in dbh for each year ####
###original method ####
# dbh <- trees_all[, c(1:4)]
# dbh$dbh2013 <- elev$dbh[match(dbh$tree, elev$tag)]
#
# #create df with bark thickness log values and intercept values from Krista's paper (supplemental info)
# #https://besjournals.onlinelibrary.wiley.com/doi/epdf/10.1111/1365-2435.12470
# #fagr does not have bark thickness measured because it is negligible
# bark <- data.frame(
#   "sp" = c("acru", "fagr", "litu", "nysy", "caco", "cagl", "caovl", "cato", "fram", "juni", "qual", "qupr", "quru", "quve", "ulru"),
#   "bark_thick_ln" = c(-2.564, 0, -0.659, -0.611, -1.917, -0.495, -2.504, -0.945, 0.318, -0.293, -1.231, -0.647, -0.789, 1.5, 1.133),
#   "intercept" = c(0.599, 0, 0.425, 0.413, 0.503, 0.316, 0.703, 0.396, 0.295, 0.385, 0.526, 0.423, 0.341, 0.053, -0.057))
#
# bark$bark_thick <- ifelse(bark$bark_thick_ln != 0, exp(bark$bark_thick_ln), bark$bark_thick_ln)
#
# bark$bark_thick <- exp(bark$bark_thick_ln)
#
# dbh$bark_thick <- bark$bark_thick[match(dbh$sp, bark$sp)]
# dbh$intercept <- bark$intercept[match(dbh$sp, bark$sp)]
#
# #the main equation is based on ring widths. We have determined the equation to be
# # rw(pointer_year) <- 0.5*dbh2013 - bark_thick*(dbh2013^intercept) - sum(rw(pointer_year):rw(end)). The first part of the equation is here. Summing the pointer years happens with the "q" df below in the loop.
# dbh$rw_prelim <- (0.5*dbh$dbh2013) - (dbh$bark_thick*(dbh$dbh2013^dbh$intercept))
#
#
# dbh$dbh_old.mm <- "0" #in prep for below
# dbh$dbh_old.mm <- as.numeric(dbh$dbh_old.mm)
#
# for (i in seq(along=widths)){
#   df <- widths[[i]] #the list "widths" comes from #4a-4b
#   colnames(df) <- gsub("A", "", colnames(df)) #remove "A"
#   colnames(df) <- gsub("^0", "", colnames(df)) #remove leading 0
#
#   cols <- colnames(df) #define cols for below
#   colnames(df) <- gsub("^", "x", colnames(df)) #add "x" to make calling colnames below feasible
#
#   for (j in seq(along=cols)){
#     for (k in seq(along=colnames(df))){
#       ring_ind <- cols[[j]]
#       ring_col <- colnames(df)[[k]]
#
#       if(j==k){
#         #the output of this loop is 3 separate columns for each year's old dbh, hence why it is set to q as a dataframe before being combined below. Pointer_years_simple comes from #4d.
#         q <- data.frame(sapply(pointer_years_simple, function(x){
#           rw <- df[rownames(df)>=x, ]
#           ifelse(dbh$year == x & dbh$tree == ring_ind,
#                  dbh$rw_prelim - sum(rw[, ring_col], na.rm=TRUE), 0)
#         }))
#
#         q$dbh_old.mm <- q[,1] +q[,2] + q[,3] #add columns together
#         # q$dbh_old.mm <- q[,1] +q[,2] + q[,3] + q[,4]
#         dbh$dbh_old.mm <- dbh$dbh_old.mm + q$dbh_old.mm #combine with dbh
#       }
#     }
#   }
# }
#
# # check <- dbh[dbh$dbh_old.mm == 0, ] #check if any tree was missed
#
# trees_all$dbh_old.mm <- dbh$dbh_old.mm
# trees_all$dbh_old.mm <- ifelse(trees_all$dbh_old.mm < 0, 0, trees_all$dbh_old.mm)
# trees_all$dbh_old.mm <- ifelse(trees_all$dbh_old.mm > 0, trees_all$dbh_old.mm/10, trees_all$dbh_old.mm)
# trees_all$dbh_ln <- ifelse(trees_all$dbh_old.mm == 0, NA, log(trees_all$dbh_old.mm))
###new method ####
bark <- read.csv("data/traits/SCBI_bark_depth.csv")
bark <- bark[bark$species %in% sp_can | bark$species %in% sp_subcan, ]
#1. Calculate diameter_nobark for 2008 = DBH.mm.2008-2*bark.depth.mm
bark$diam_nobark_2008.mm <- bark$DBH.mm.2008 - 2*bark$bark.depth.mm
#2. log-transform both diam_nobark_2008 (x) and bark.depth.mm (y)
#3. Fit a linear model, and use model to predict log(bark.depth.mm)
source_gist("524eade46135f6348140")
ggplot(data = bark, aes(x = log(diam_nobark_2008.mm), y = log(bark.depth.mm))) +
stat_smooth_func(geom="text",method="lm",hjust=0.16, vjust=-1,parse=TRUE) +
geom_smooth(method="lm", se=FALSE, color="black") +
geom_point(color = "#0c4c8a") +
theme_minimal() +
facet_wrap(vars(species))
#this full equation is used further down
ggplot(data = bark, aes(x = log(diam_nobark_2008.mm), y = log(bark.depth.mm))) +
stat_smooth_func(geom="text",method="lm",hjust=0.16, vjust=-1,parse=TRUE) +
geom_smooth(method="lm", se=FALSE, color="black") +
geom_point(color = "#0c4c8a") +
theme_minimal()
#no total regression equation at bottom because all species are accounted for in dataset.
bark$predict_barkthick.ln.mm <- NA
bark$predict_barkthick.ln.mm <-
ifelse(bark$species == "caco", -1.56+0.416*log(bark$diam_nobark_2008.mm),
ifelse(bark$species == "cagl", -0.393+0.268*log(bark$diam_nobark_2008.mm),
ifelse(bark$species == "caovl", -2.18+0.651*log(bark$diam_nobark_2008.mm),
ifelse(bark$species == "cato", -0.477+0.301*log(bark$diam_nobark_2008.mm),
ifelse(bark$species == "fram", 0.418+0.268*log(bark$diam_nobark_2008.mm),
ifelse(bark$species == "juni", 0.346+0.279*log(bark$diam_nobark_2008.mm),
ifelse(bark$species == "litu", -1.14+0.463*log(bark$diam_nobark_2008.mm),
ifelse(bark$species == "qual", -2.09+0.637*log(bark$diam_nobark_2008.mm),
ifelse(bark$species == "qupr", -1.31+0.528*log(bark$diam_nobark_2008.mm),
ifelse(bark$species == "quru", -0.593+0.292*log(bark$diam_nobark_2008.mm),
ifelse(bark$species == "quve", 0.245+0.219*log(bark$diam_nobark_2008.mm),
bark$predict_barkthick.ln)))))))))))
#4. Take exponent of bark.depth.mm and make sure predicted values look good.
bark$predict_barkthick.mm <- exp(bark$predict_barkthick.ln.mm)
range(bark$predict_barkthick.mm - bark$bark.depth.mm)
#5. Get mean bark thickness per species in 2008.
## The equation for calculating old dbh, using 1999 as an example, is
## dbh1999 = dbh2008 - 2(ring.width2013 - ring.width1999) - 2(bark.depth2008) + 2(bark.depth1999)
## using the dataset from calculating the regression equations, we can get mean bark thickness per species in 2008.
##set up dbh dataframe
dbh <- trees_all[, c(1:4)]
scbi.stem1 <- read.csv(text=getURL("https://raw.githubusercontent.com/SCBI-ForestGEO/SCBI-ForestGEO-Data/master/tree_main_census/data/census-csv-files/scbi.stem1.csv"), stringsAsFactors = FALSE)
scbi.stem1$dbh <- as.numeric(scbi.stem1$dbh)
dbh$dbh2008.mm <- scbi.stem1$dbh[match(dbh$tree, scbi.stem1$tag)]
mean_bark <- aggregate(bark$bark.depth.mm, by=list(bark$species), mean) #mm
colnames(mean_bark) <- c("sp", "mean_bark_2008.mm")
dbh$mean_bark_2008.mm <- ifelse(dbh$sp %in% mean_bark$sp, mean_bark$mean_bark_2008.mm[match(dbh$sp, mean_bark$sp)], mean(bark$bark.depth.mm))
dbh$mean_bark_2008.mm <- round(dbh$mean_bark_2008.mm, 2)
#6.Thus, the only value we're missing is bark depth in 1999.
## This is ok, because we can calculate from the regression equation per each species (all we need is diam_nobark_1999).Calculate diam_nobark_1999 using
## diam_nobark_1999 = dbh2008 - 2*(bark.depth2008) - 2*(sum(ring.width1999:ring.width2008))
##define this column before loop
dbh$diam_nobark_old.mm <- 0
for (i in seq(along=widths)){
df <- widths[[i]] #the list "widths" comes from #4a-4b
colnames(df) <- gsub("A", "", colnames(df)) #remove "A"
colnames(df) <- gsub("^0", "", colnames(df)) #remove leading 0
cols <- colnames(df) #define cols for below
colnames(df) <- gsub("^", "x", colnames(df)) #add "x" to make calling colnames below feasible
for (j in seq(along=cols)){
for (k in seq(along=colnames(df))){
ring_ind <- cols[[j]]
ring_col <- colnames(df)[[k]]
if(j==k){
#the output of this loop is 3 separate columns for each year's old dbh, hence why it is set to q as a dataframe before being combined below. Pointer_years_simple comes from #4d.
q <- data.frame(sapply(pointer_years_simple, function(x){
rw <- df[rownames(df)>=x, ]
ifelse(dbh$year == x & dbh$tree == ring_ind,
dbh$dbh2008.mm - 2*(dbh$mean_bark_2008.mm) - sum(rw[rownames(rw) %in% c(x:2008), ring_col], na.rm=TRUE), 0)
}))
q$diam_nobark_old.mm <- q[,1] +q[,2] + q[,3] #add columns together
# q$dbh_old.mm <- q[,1] +q[,2] + q[,3] + q[,4]
dbh$diam_nobark_old.mm <- dbh$diam_nobark_old.mm + q$diam_nobark_old.mm #combine with dbh (it's the same order of rows) #mm
}
}
}
}
#7. Calculate bark thickness using regression equation per appropriate sp
## log(bark.depth.1999) = intercept + log(diam_nobark)*constant
## bark.depth.1999 = exp(log(bark.depth.1999))
#the full equation at the bottom is the regression equation for all these species put together. "fagr" is given a bark thickness of 0 because it is negligble
#these equations are the same as above in #3 of this code section
dbh$bark_thick_old.ln.mm <- NA
dbh$bark_thick_old.ln.mm <- ifelse(dbh$sp == "caco", -1.56+0.416*log(dbh$diam_nobark_old.mm),
ifelse(dbh$sp == "cagl", -0.393+0.268*log(dbh$diam_nobark_old.mm),
ifelse(dbh$sp == "caovl", -2.18+0.651*log(dbh$diam_nobark_old.mm),
ifelse(dbh$sp == "cato", -0.477+0.301*log(dbh$diam_nobark_old.mm),
ifelse(dbh$sp == "fram", 0.418+0.268*log(dbh$diam_nobark_old.mm),
ifelse(dbh$sp == "juni", 0.346+0.279*log(dbh$diam_nobark_old.mm),
ifelse(dbh$sp == "litu", -1.14+0.463*log(dbh$diam_nobark_old.mm),
ifelse(dbh$sp == "qual", -2.09+0.637*log(dbh$diam_nobark_old.mm),
ifelse(dbh$sp == "qupr", -1.31+0.528*log(dbh$diam_nobark_old.mm),
ifelse(dbh$sp == "quru", -0.593+0.292*log(dbh$diam_nobark_old.mm),
ifelse(dbh$sp == "quve", 0.245+0.219*log(dbh$diam_nobark_old.mm),
ifelse(dbh$sp == "fagr", 0,
-1.01+0.213*log(dbh$diam_nobark_old.mm)))))))))))))
dbh$bark_thick_old.mm <- ifelse(dbh$sp == "fagr", 0, exp(dbh$bark_thick_old.ln.mm))
#8. Add to solution from #6 to get full dbh1999
## dbh1999 = diam_nobark_1999 + 2*bark.depth.1999
dbh$dbh_old.mm <- dbh$diam_nobark_old.mm + 2*dbh$bark_thick_old.mm
##NOTE
##The first time I ran this code I was getting NaNs for one tree (140939), because the dbh in 2008 was listed as 16.9. I double-checked this, and that was the second stem, which we obviously didn't core at a size of 1.69 cm (or 2.2 cm in 2013). The dbh is meant to be the first stem. However, there was confusion with the dbh in the field.
trees_all$dbh_old.mm <- dbh$dbh_old.mm[match(trees_all$tree, dbh$tree) & match(trees_all$year, dbh$year)] #mm
trees_all$dbh_old.cm <- trees_all$dbh_old.mm/10
trees_all$dbh.ln.cm <- log(trees_all$dbh_old.cm)
##5f. add in ratio of sapwood area to total wood ####
### It has been determined that since sapwood ratio is so tied to DBH (in other words, testing it in a model is akin to testing DBH again), that we are going to leave it out of the full models. However, I'm leaving the code here in case we want anything with it later.
#calculate sapwood area
##sapwood area[iii] = tree area (minus bark)[i] - heartwood area[ii]
sap <- read.csv("data/traits/SCBI_Sapwood_Data.csv", stringsAsFactors = FALSE)
sap <- sap[,c(1:5,8:10,24)]
sap$sp <- paste0(gsub("^(..).*", "\\1", sap$Latin),
gsub("^.* (..).*", "\\1", sap$Latin))
sap$sp <- tolower(sap$sp)
##subtract bark thickness from dbh
##NOTE bark thickness is from 2008, even tho sap data collected 2010
##[[i]]
sap$dbh_nobark.mm <- 0
for (i in seq(along=mean_bark$mean_bark_2008)){
sub <- mean_bark[mean_bark$mean_bark_2008[[i]] == mean_bark$mean_bark_2008, ]
sap$dbh_nobark.mm <- ifelse(sap$sp == sub$sp, sap$DBH-sub$mean_bark_2008, sap$dbh_nobark)
}
#[ii]
#heartwood radius = 0.5*dbh – sapwood depth (mm)
sap$hw_rad.mm <- 0.5*sap$dbh_nobark.mm - sap$sapwood.depth..mm.
#Heartwood area = pi*(heartwood radius)^2 (mm^2)
sap$hw_area.mm2 <- pi*(sap$hw_rad.mm)^2
#[iii]
#Sapwood area = pi*((0.5*dbh)^2) – heartwood area (cm^2 with the /100)
sap$sap_area.cm2 <- (pi*(0.5*sap$dbh_nobark.mm)^2 - sap$hw_area.mm2)/100
sap <- sap[sap$sp %in% sp_can | sap$sp %in% sp_subcan, ]
#ratio = sapwood area:total wood area (without bark)
##calculate ratio to find the regression equations
sap$dbh_nobark.cm <- sap$dbh_nobark.mm/10
sap$total_wood_area.cm2 <- pi*(sap$dbh_nobark.cm/2)^2
sap$sap_ratio <- sap$sap_area.cm2/sap$total_wood_area.cm2
#these equations are for getting the sapwood_area for the dbh df, which are then converted to sap_ratio for that df.
source_gist("524eade46135f6348140")
#DBH = mm, sap_area = cm^2
ggplot(data = sap, aes(x = log(DBH), y = log(sap_area.cm2))) +
stat_smooth_func(geom="text",method="lm",hjust=0.16, vjust=0.8,parse=TRUE) +
geom_smooth(method="lm", se=FALSE, color="black") +
geom_point(color = "#0c4c8a") +
theme_minimal() +
facet_wrap(vars(sp))
ggplot(data = sap, aes(x = log(DBH), y = log(sap_area.cm2))) +
stat_smooth_func(geom="text",method="lm",hjust=0.16, vjust=-1,parse=TRUE) +
geom_smooth(method="lm", se=FALSE, color="black") +
geom_point(color = "#0c4c8a") +
theme_minimal()
#original equations. I'm not sure what happened, but I think after changing some units, I forgot to update these. Nevertheless, I'm leaving them as is in case I messed up.
# #the bottom equation is the total regression equation
# dbh$sapwood_area.ln <- NA
# dbh$sapwood_area.ln <- ifelse(dbh$sp == "caco", 6.17-0.419*log(dbh$dbh_old.mm),
#                        ifelse(dbh$sp == "cagl", 5.32-0.26*log(dbh$dbh_old.mm),
#                        ifelse(dbh$sp == "cato", 6.51-0.444*log(dbh$dbh_old.mm),
#                        ifelse(dbh$sp == "fram", 2.19+0.326*log(dbh$dbh_old.mm),
#                        ifelse(dbh$sp == "juni", 5.53-0.404*log(dbh$dbh_old.mm),
#                        ifelse(dbh$sp == "litu", 4.31-0.0718*log(dbh$dbh_old.mm),
#                        ifelse(dbh$sp == "qual", 7.09-0.692*log(dbh$dbh_old.mm),
#                        ifelse(dbh$sp == "qupr", 4.99-0.305*log(dbh$dbh_old.mm),
#                        ifelse(dbh$sp == "quru", 4.27-0.282*log(dbh$dbh_old.mm),
#                        ifelse(dbh$sp == "quve", 5.1-0.402*log(dbh$dbh_old.mm),
#                                    6.6-0.543*log(dbh$dbh_old.mm)))))))))))
#the bottom equation is the total regression equation
dbh$sapwood_area.ln <- NA
dbh$sapwood_area.ln <- ifelse(dbh$sp == "caco", -3.41+1.6*log(dbh$dbh_old.mm),
ifelse(dbh$sp == "cagl", -4.34+1.77*log(dbh$dbh_old.mm),
ifelse(dbh$sp == "cato", -3.14+1.59*log(dbh$dbh_old.mm),
ifelse(dbh$sp == "fram", -7.75+2.4*log(dbh$dbh_old.mm),
ifelse(dbh$sp == "juni", -4.23+1.64*log(dbh$dbh_old.mm),
ifelse(dbh$sp == "litu", -5.5+1.98*log(dbh$dbh_old.mm),
ifelse(dbh$sp == "qual", -2.66+1.35*log(dbh$dbh_old.mm),
ifelse(dbh$sp == "qupr", -4.89+1.76*log(dbh$dbh_old.mm),
ifelse(dbh$sp == "quru", -5.35+1.74*log(dbh$dbh_old.mm),
ifelse(dbh$sp == "quve", -4.57+1.63*log(dbh$dbh_old.mm),
-3.13+1.5*log(dbh$dbh_old.mm)))))))))))
dbh$sapwood_area.cm2 <- exp(dbh$sapwood_area.ln)
#calculate ratio for each tree using regression equations
##prepare: get radius.w/o.bark (/2) and convert to cm (/10).
dbh$radius_nobark.cm <- (dbh$diam_nobark_old/2)/10
##total wood area = pi*(radius.nobark)^2 (cm^2)
dbh$total_wood_area.cm2 <- pi*(dbh$radius_nobark.cm)^2
dbh$sap_ratio <- dbh$sapwood_area.cm2/dbh$total_wood_area.cm2
trees_all$sap_ratio <- dbh$sap_ratio[match(trees_all$tree, dbh$tree) & match(trees_all$year, dbh$year)]
##5g. add in tree heights ####
## taken from the canopy_heights script
#the full equation is using all points for which we have data to create the equation, despite that for several species we don't have enough data to get a sp-specific equation
trees_all$height.ln.m <- ifelse(trees_all$sp == "caco", (0.348+0.808*trees_all$dbh.ln.cm),
ifelse(trees_all$sp == "cagl", (0.681+0.704*trees_all$dbh.ln.cm),
ifelse(trees_all$sp == "caovl", (0.621+0.722*trees_all$dbh.ln.cm),
ifelse(trees_all$sp == "cato", (0.776+0.701*trees_all$dbh.ln.cm),
ifelse(trees_all$sp == "fagr", (0.708+0.662*trees_all$dbh.ln.cm),
ifelse(trees_all$sp == "fram", (0.715+0.619*trees_all$dbh.ln.cm),
ifelse(trees_all$sp == "juni", (1.22+0.49*trees_all$dbh.ln.cm),
ifelse(trees_all$sp == "litu", (1.32+0.524*trees_all$dbh.ln.cm),
ifelse(trees_all$sp == "qual", (1.14+0.548*trees_all$dbh.ln.cm),
ifelse(trees_all$sp == "qupr", (0.44+0.751*trees_all$dbh.ln.cm),
ifelse(trees_all$sp == "quru", (1.17+0.533*trees_all$dbh.ln.cm),
ifelse(trees_all$sp == "quve", (0.864+0.585*trees_all$dbh.ln.cm),
(0.791+0.645*trees_all$dbh.ln.cm)))))))))))))
#0.849+0.659*trees_all$dbh_ln.cm -> original equation that was yielding predicted heights for some trees of about 54m.
trees_all$height.m <- exp(trees_all$height.ln.m) #m, because these equations come from a plotting of log(DBH in cm) against log(height in m).
#see mean of height changes
ht_change <- trees_all %>%
group_by(tree) %>%
summarize(max(height.m) - min(height.m))
ht_change <- ht_change[ht_change$`max(height.m) - min(height.m)` > 0, ]
mean(ht_change$`max(height.m) - min(height.m)`)
#cap values at max for different species.
# heights_full <- read.csv(text=getURL("https://raw.githubusercontent.com/SCBI-ForestGEO/SCBI-ForestGEO-Data/master/tree_dimensions/tree_heights/SCBI_tree_heights.csv"), stringsAsFactors = FALSE)
#
# max_ht <- aggregate(height.m ~ sp, data=heights_full, FUN=max)
##5h. add in all crown positions ####
positions <- read.csv(text=getURL("https://raw.githubusercontent.com/SCBI-ForestGEO/SCBI-ForestGEO-Data/master/tree_dimensions/tree_crowns/cored_dendroband_crown_position_data/dendro_cored_full.csv"))
trees_all$position_all <- positions$crown.position[match(trees_all$tree, positions$tag)]
trees_all$position_all <- gsub("D", "dominant", trees_all$position_all)
trees_all$position_all <- gsub("C", "co-dominant", trees_all$position_all)
trees_all$position_all <- gsub("I", "intermediate", trees_all$position_all)
trees_all$position_all <- gsub("S", "suppressed", trees_all$position_all)
#this has been proven to be roughly equivalent to position_all, so we're sticking with position_all
# trees_all$illum <- positions$illum[match(trees_all$tree, positions$tag)]
# trees_all$illum <- as.character(trees_all$illum)
#this csv has avg/min/max dbh for each canopy position by sp
# positionsp <- read.csv("data/core_chronologies_by_crownposition.csv")
##5i. add in topographic wetness index ####
### this code comes from topo_wetness_index in ForestGEO-Data
ext <- extent(747370.6, 747785.8, 4308505.5, 4309154.8)
xy <- abs(apply(as.matrix(bbox(ext)), 1, diff))
n <- 5
r <- raster(ext, ncol=xy[1]*n, nrow=xy[2]*n)
proj4string(r) <- CRS("+proj=utm +zone=17 +datum=NAD83 +units=m +no_defs +ellps=GRS80 +towgs84=0,0,0")
#2 Get elevation raster from online
q <- get_elev_raster(r, z=14)
#3 Crop online raster to the dimensions of the empty raster, set resolution to 5m
r <- raster(ext, res = 5)
q <- resample(q, r)
res(q)
proj4string(q) <- CRS("+proj=utm +zone=17 +datum=NAD83 +units=m +no_defs +ellps=GRS80 +towgs84=0,0,0") #q lost its crs in the resample function
plot(q)
#4 Get hydrological features of landscape (upslope area and topographical wetness index)
layers <- build_layers(q)
sp::plot(layers, main=c("Elevation AMSL (m)", "Upslope area (log(m^2/m))", "TWI ((log(m^2/m))"))
#5 get TWI values for trees
twi_trees <- read.csv("D:/Dropbox (Smithsonian)/Github_Ian/McGregor_climate-sensitivity-variation/data/core_list_for_neil.csv")
twi_trees <- twi_trees[, c(1,23:24)]
twi_trees1 <- twi_trees[, c(2:3)]
twi <- extract(layers[[3]], twi_trees1, method="simple")
twi_trees$TWI <- twi
#6 add to trees_all
trees_all$TWI <- twi_trees$TWI[match(trees_all$tree, twi_trees$tag)]
trees_all$TWI.ln <- log(trees_all$TWI)
##5i1. write trees_all to csv for use in manuscript code ####
write.csv(trees_all, "manuscript/tables_figures/trees_all.csv", row.names=FALSE)
##5j. remove one bad tree & resistance values >2 ####
##fram 140939 has been mislabeled. It is recorded as having a small dbh when that is the second stem. In terms of canopy position, though, it fell between time of coring and when positions were recorded, thus we do not know its position.
trees_all <- trees_all[!trees_all$tree == 140939, ]
trees_all <- trees_all[trees_all$resist.value <=2,]
##5k. subset for either leaf hydraulic traits or biophysical ####
trees_all_traits <- trees_all[complete.cases(trees_all), ]
write.csv(trees_all_traits, "manuscript/tables_figures/trees_all_traits.csv", row.names=FALSE)
##take out columns that are unnecessary for model runs
trees_all_sub <- trees_all[, !colnames(trees_all) %in% c("p50.MPa", "p80.MPa", "dbh_old.mm",  "dbh_old.cm", "sap_ratio", "height.m")]
##get rid of missing data
trees_all_sub <- trees_all_sub[complete.cases(trees_all_sub), ]
##5ki. NOTE ####
##originally I was separating out trees_all into 2 datasets (trees_all_bio and trees_all_full) because I thought that there was alternative missing data depending on if you were looking at biophysical traits compared to leaf traits. It turns out this was mainly due to p50 and p80, which we have since determined will not be in the model runs at all. Thus, I'm only doing one subset here.
#
# trees_all_bio <- trees_all[c("year", "sp", "tree", "position", "resist.value", "elev.m", "distance.ln.m", "dbh.ln.cm", "height.ln.m", "position_all", "TWI")]
# trees_all_bio <- trees_all_bio[complete.cases(trees_all_bio), ]
# write.csv(trees_all_bio, "manuscript/tables_figures/trees_all_bio.csv", row.names=FALSE)
#
# #take out p50 and p80, then keep all leaf traits and additionally height plus position
# trees_all_full <- trees_all[!colnames(trees_all) %in% c("p50.MPa", "p80.MPa")]
# trees_all_full <- trees_all_full[, c(1:10,17:20)]
# trees_all_full<- trees_all_full[complete.cases(trees_all_full), ]
# write.csv(trees_all_full, "manuscript/tables_figures/trees_all_full.csv", row.names=FALSE)
##5l. make subsets for individual years, combine all to list ####
x1966 <- trees_all_sub[trees_all_sub$year == 1966, ]
x1977 <- trees_all_sub[trees_all_sub$year == 1977, ]
x1999 <- trees_all_sub[trees_all_sub$year == 1999, ]
model_df <- list(trees_all_sub, x1966, x1977, x1999)
names(model_df) <- c("trees_all_sub", "x1966", "x1977", "x1999")
