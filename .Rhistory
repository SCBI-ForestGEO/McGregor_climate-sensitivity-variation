core_list <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/SCBI-ForestGEO-Data/tree_dimensions/tree_crowns/core_list_for_neil.csv")
core_list <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/SCBI-ForestGEO-Data/tree-growth-and-productivity/core_list_for_neil.csv")
core_list <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/tree-growth-and-productivity/core_list_for_neil.csv")
unique(core_list$sp)
###################################################
### code chunk number 1: Roptions
###################################################
library(MASS)
lg5.pred <- function(params, doy) {
L <- params[1] # min(dbh, na.rm = T)
K <- params[2]
doy.ip <- params[3]
r <- params[4]
theta <- params[5]
dbh <- vector(length = length(doy))
dbh <- L + ((K - L) / (1 + 1/theta * exp(-(r * (doy - doy.ip) / theta)) ^ theta))
return(dbh)
}
lg5.ML <- function(params, doy, dbh, resid.sd) {
pred.dbh <- lg5.pred(params, doy)
pred.ML <-  -sum(dnorm(dbh, pred.dbh, resid.sd, log = T))
return(pred.ML)
}
lg5.ML.wt <- function(params, doy, dbh, resid.sd) {
wts <- 1 / dnorm(abs(seq(-2, 2, length = length(doy))), 0, 1)
pred.dbh <- lg5.pred(params, doy)
pred.ML <- -sum((wts * dnorm(dbh, pred.dbh, resid.sd, log = T)))
return(pred.ML)
}
get.doy <- function(x) {
names.data <- names(x)
doy.1 <- as.numeric(unlist(strsplit(names.data[grep("X", names.data)], "X")))
doy <- doy.1[!is.na(doy.1)]
return(doy)
}
get.lg5.resids <- function(params, doy, dbh) {
lg5.resid <- dbh - lg5.pred(params, doy)
return(lg5.resid)
}
pred.doy <- function(params, a, diam.given = 0) {
params <- as.numeric(params)
L <- params[1] # min(dbh, na.rm = T)
K <- params[2]
doy.ip <- params[3]
r <- params[4]
theta <- params[5]
a.par <- a
.expr1 <- (K - L) / (a.par - L)
.expr2 <- doy.ip * r - theta * log(((.expr1 - 1) * theta) ^ (1/theta))
.expr3 <- .expr2 / r
dcrit <- .expr3
return(dcrit)
}
lg5.pred.a <- function (a, params, doy, dbh, asymptote = "lower") {
asymptote <- ifelse(length(a) > 1, "both", asymptote)
L <- params[1] # min(dbh, na.rm = T)
K <- params[2]
doy.ip <- params[3]
r <- params[4]
theta <- params[5]
diam <- vector(length = length(doy))
if(asymptote == "lower") {
d.crit <- pred.doy(params, a)
diam[which(doy <= d.crit)] <- a
diam[which(doy > d.crit)] <- L + ((K - L) / (1 + 1/theta * exp(-(r * (doy[which(doy > d.crit)] - doy.ip) / theta)) ^ theta))
}else{
if(asymptote == "upper") {
d.crit <- pred.doy(params, a)
diam[which(doy >= d.crit)] <- a
diam[which(doy < d.crit)] <- L + ((K - L) / (1 + 1/theta * exp(-(r * (doy[which(doy < d.crit)] - doy.ip) / theta)) ^ theta))
}else{
if(asymptote == "both") {
d.crit <- pred.doy(params, a)
diam[which(doy <= d.crit[1])] <- a[1]
diam[which(doy >= d.crit[2])] <- a[2]
diam[which(doy > d.crit[1] & doy < d.crit[2])] <- L + ((K - L) / (1 + 1/theta * exp(-(r * (doy[which(doy > d.crit[1] & doy < d.crit[2])] - doy.ip) / theta)) ^ theta))
}
return(diam)
}
lg5.ML.a <- function(a, params, doy, dbh, resid.sd) {
pred.dbh <- lg5.pred.a(a, params, doy)
pred.ML <- -sum(dnorm(dbh, pred.dbh, resid.sd, log = T))
}
make.seq <- function(param, params, deviation = 0.1, len.seq = 50, CI = c(0, 0), asymptote = "lower", min.val = NULL, max.val = NULL) {
if(asymptote == "lower") {
if(CI[1] > 0) {
lower.lim <- max(min.val, CI[1] * (1 - deviation), na.rm = T)
par.seq <- seq(lower.lim, (CI[2] * (1 + deviation)), length = len.seq)
}else{
par.seq <- seq(min.val, (param + deviation * param), length = len.seq)
}
}else{
if(CI[1] > 0) {
upper.lim <- min(max.val, CI[2] * (1 + deviation), na.rm = T)
par.seq <- seq((CI[1] * (1 - deviation)), upper.lim, length = len.seq)
}else{
par.seq <- seq((param - deviation * param), max.val, length = len.seq)
}
return(par.seq)
}
start.diam <- function(params, seq.l, doy, dbh, deviation.val, figure = FALSE, resid.sd = 0.1) {
complete <- complete.cases(doy, dbh)
doy <- doy[complete]
dbh <- dbh[complete]
profile.like.vec <- vector(length = seq.l)
pred.min <- lg5.pred(params, doy[1])
min.val <- max(min(dbh), pred.min, min(params[1], params[2]))
param.vec.tmp <- make.seq(param = min(dbh, na.rm = T), params, deviation = deviation.val, len.seq = seq.l, asymptote = "lower", min.val = min.val)
for(p in 1:seq.l) {
pred.dbh <- lg5.pred.a(a = param.vec.tmp[p], params, doy)
profile.like.vec[p] <- sum(dnorm(dbh, pred.dbh, resid.sd, log = T))
}
xi.val <- max(profile.like.vec) - 1.92
max.value <- param.vec.tmp[which(profile.like.vec == max(profile.like.vec))]
values.above <- which(profile.like.vec > xi.val)
ci.lower <- param.vec.tmp[min(values.above)]
ci.upper <- param.vec.tmp[max(values.above)]
ci.params <- c(ci.lower, ci.upper)
param.vec.tmp <- make.seq(param = max.value, params, deviation = 0.0001, len.seq = seq.l, CI = ci.params, asymptote = "lower", min.val = min.val)
for(p in 1:seq.l) {
pred.dbh <- lg5.pred.a(a = param.vec.tmp[p], params, doy)
profile.like.vec[p] <- sum(dnorm(dbh, pred.dbh, resid.sd, log = T))
}
xi.val <- max(profile.like.vec) - 1.92
max.value <- param.vec.tmp[which(profile.like.vec == max(profile.like.vec))]
values.above <- which(profile.like.vec > xi.val)
ci.lower <- param.vec.tmp[min(values.above)]
ci.upper <- param.vec.tmp[max(values.above)]
ci.params <- c(ci.lower, ci.upper)
if(figure) {
plot(param.vec.tmp, profile.like.vec, type = "l", xlab = "Parameter value", ylab = "Likelihood")
abline(h = xi.val, col = "darkred")
abline(v = c(ci.lower, ci.upper), col = "darkblue", lty = 2)
}
start.values <- c(max.value, ci.lower, ci.upper, max(profile.like.vec, na.rm = TRUE))
return(start.values)
}
end.diam <- function(seq.l, params, doy, dbh, deviation.val, figure = FALSE, resid.sd = 0.1) {
complete <- complete.cases(doy, dbh)
doy <- doy[complete]
dbh <- dbh[complete]
profile.like.vec <- vector(length = seq.l)
pred.max <- lg5.pred(params, doy[length(doy)])
max.val <- min(max(dbh), pred.max, max(params[1], params[2]))
param.vec.tmp <- make.seq(param = max(dbh, na.rm = T), params, deviation = deviation.val, len.seq = seq.l, asymptote = "upper", max.val = max.val)
for(p in 1:seq.l) {
pred.dbh <- lg5.pred.a(a = param.vec.tmp[p], params = params, doy, asymptote = "upper")
profile.like.vec[p] <- sum(dnorm(dbh, pred.dbh, resid.sd, log = T))
}
xi.val <- max(profile.like.vec) - 1.92
max.value <- param.vec.tmp[which(profile.like.vec == max(profile.like.vec))]
values.above <- which(profile.like.vec > xi.val)
ci.lower <- param.vec.tmp[min(values.above)]
ci.upper <- param.vec.tmp[max(values.above)]
ci.params <- c(ci.lower, ci.upper)
param.vec.tmp <- make.seq(param = max.value, params, deviation = 0.0001, len.seq = seq.l, CI = ci.params, asymptote = "upper", max.val = max.val)
for(p in 1:seq.l) {
pred.dbh <- lg5.pred.a(a = param.vec.tmp[p], params = params, doy, asymptote = "upper")
profile.like.vec[p] <- sum(dnorm(dbh, pred.dbh, resid.sd, log = T))
}
values.above <- which(profile.like.vec > xi.val)
ci.lower <- param.vec.tmp[min(values.above)]
ci.upper <- param.vec.tmp[max(values.above)]
ci.params <- c(ci.lower, ci.upper)
max.value <- param.vec.tmp[which(profile.like.vec == max(profile.like.vec))]
if(figure) {
plot(param.vec.tmp, profile.like.vec, type = "l", xlab = "Parameter value", ylab = "Likelihood")
xi.val <- max(profile.like.vec) - 1.92
abline(h = xi.val, col = "darkred")
abline(v = c(ci.lower, ci.upper), col = "darkblue", lty = 2)
}
end.values <- c(max.value, ci.lower, ci.upper, max(profile.like.vec, na.rm = TRUE))
return(end.values)
}
View(core_list)
###################################################
### code chunk number 5: data
###################################################
doy.1 <- c(112, 120, 124, 130, 134, 139,
144, 148, 153, 158, 165, 172, 179, 187, 190, 193, 200, 207, 214, 217, 221,
225, 228, 232, 237, 244, 251, 256, 263, 270, 285, 291, 301)
dbh.1 <- c(18.99449, 18.99512, 19.00085, 19.01008, 19.03077, 19.06038, 19.07406,
19.08584, 19.12659, 19.17465, 19.19821, 19.24150, 19.27619, 19.30579,
19.30898, 19.34113, 19.37105, 19.38919, 19.39365, 19.41243, 19.41911,
19.43471, 19.43726, 19.44076, 19.44553, 19.44458, 19.44521, 19.44903,
19.44872, 19.45254, 19.45731, 19.45890, 19.45890)
dbh.data <- read.csv("C:/Users/mcgregori/Downloads/ece31117-sup-0002-appendixs2.csv")
View(dbh.data)
tree.no <- dim(dbh.data)[1]
doy.full <- get.doy(dbh.data)
lg5.hess <- vector("list", tree.no)
winning.optim.call <- c()
optim.output.df <- c()
resids.mat <- matrix(NA, tree.no, length(doy.full))
pdf("FIGURES/lg5_fit_all.pdf")
par(mfrow = c(2,2))
pb <- txtProgressBar(style = 3)
for(i in 1:tree.no) {
setTxtProgressBar(pb, i / tree.no, title = NULL, label = NULL)
par(mfrow = c(1,1))
#	pdf(file = sprintf("FIGURES/lg5_fit_%i.pdf", i))
dbh <- as.numeric(dbh.data[i,])
complete <- complete.cases(dbh)
dbh <- dbh[complete]
doy <- doy.full[complete]
doy.ip.hat <- doy[(which(dbh > mean(dbh)))[1]]
par.list <- list(L = min(dbh, na.rm = TRUE), K = max(dbh, na.rm = TRUE), doy.ip = doy.ip.hat, r = .08, theta = 1)
params <- as.numeric(unlist(par.list))
params.start <- params
optim.min <- c((min(dbh, na.rm = TRUE) * 0.99), quantile(dbh, 0.5, na.rm = TRUE), 0, 0, 0.01)
optim.max <- c(min(dbh, na.rm = TRUE), max(dbh, na.rm = TRUE), 350, 0.1, 15)
resid.sd <- 0.1
hess.tmp <- vector("list", 6)
##  THESE ARE THE CALLS TO OPTIM  ##
# weigted values have false ML estimates, so the estimate is re-assessed based on the optimized parameters in an unweighted call
lg5.output.LB <- optim(par = params, doy = doy, dbh = dbh, resid.sd = resid.sd, fn = lg5.ML, method = "L-BFGS-B", lower = optim.min, upper = optim.max, hessian = TRUE, control = list(trace = 0))
hess.tmp[[1]] <- lg5.output.LB$hessian
params <- lg5.output.LB$par
lg5.output.LB.wt <- optim(par = params, doy = doy, dbh = dbh, resid.sd = resid.sd, fn = lg5.ML.wt, method = "L-BFGS-B", lower = optim.min, upper = optim.max, hessian = TRUE, control = list(trace = 0))
lg5.output.LB.wt$value <- lg5.ML(params = lg5.output.LB.wt$par, doy, dbh, resid.sd = resid.sd)
hess.tmp[[2]] <- lg5.output.LB.wt$hessian
lg5.output.NM <- optim(par = params, fn = lg5.ML, resid.sd = resid.sd,  method = "Nelder-Mead", hessian = TRUE, control = list(trace = 0), doy = doy, dbh = dbh)
hess.tmp[[3]] <- lg5.output.NM$hessian
lg5.output.NM.wt <- optim(par = params, fn = lg5.ML.wt, resid.sd = resid.sd,  method = "Nelder-Mead", hessian = TRUE, control = list(trace = 0), doy = doy, dbh = dbh)
lg5.output.NM.wt$value <- lg5.ML(lg5.output.NM.wt$par, doy, dbh, resid.sd = resid.sd)
hess.tmp[[4]] <- lg5.output.NM.wt$hessian
lg5.output.SANN <- optim(par = params, doy = doy, dbh = dbh, resid.sd = resid.sd, fn = lg5.ML, method = "SANN",  hessian = TRUE, control = list(maxit = 30000, trace = F))
hess.tmp[[5]] <- lg5.output.SANN$hessian
lg5.output.SANN.wt <- optim(par = params, doy = doy, dbh = dbh, resid.sd = resid.sd, fn = lg5.ML.wt, method = "SANN",  hessian = TRUE, control = list(maxit = 30000, trace = F))
hess.tmp[[6]] <- lg5.output.SANN.wt$hessian
lg5.output.SANN.wt$value <- lg5.ML(lg5.output.SANN.wt$par, doy, dbh, resid.sd = resid.sd)
## CONSOLIDATE THE RESULTS  ##
optim.output <- rbind(c(params.start, NA), c(lg5.output.LB$par, lg5.output.LB$value), c(lg5.output.LB.wt$par, lg5.output.LB.wt$value), c(lg5.output.NM$par, lg5.output.NM$value), c(lg5.output.NM.wt$par, lg5.output.NM.wt$value), c(lg5.output.SANN$par, lg5.output.SANN$value), c(lg5.output.SANN.wt$par, lg5.output.SANN.wt$value))
winner <- rep(".", length = 7)
winner[1] <- NA
winner[which(optim.output[,6] == min(optim.output[-1,6], na.rm = T))] <- "*"
calls <- c("Starting", "L-BFGS-B", "L-BFGS-B wt", "N-M", "N-M wt", "SANN", "SANN wt")
##  MAKE A DATAFRAME OF THE RESULTS  ##
optim.output.tmp <- round(optim.output, digits = 4)
optim.output.df <- as.data.frame(rbind(optim.output.df, cbind(i, calls, optim.output.tmp, winner)))
#############################
lg5.hess[[i]] <- hess.tmp[which(winner == "*")]
winner <- match(min(optim.output[-1, 6], na.rm = T), optim.output[-1, 6])
win.vec <- rep(2, 6)
win.vec[winner] <- 1
cols <- brewer.pal(dim(optim.output)[1], name = "Dark2")
if(i == 1) {
optim.output1 <- optim.output
win.vec1 <- win.vec
optim.output.df.1 <- optim.output.df[, -1]
names(optim.output.df.1) <- c("Optim.call", "L", "K", "doy_ip", "r", "theta", "ML", "Best.ML")
doy1 <- doy
dbh1 <- dbh
}
plot(doy, dbh, xlab = "Day of the year", ylab = "DBH (cm)", pch = 19, col = "gray15", main = sprintf("Annual Growth for tree %i", i), cex = 1)
days <- seq(365)
for(j in 2:dim(optim.output)[1]) {
lines(days, lg5.pred(params = optim.output[j ,], doy = days), col = cols[j - 1], lty = win.vec[j - 1], lwd = 1)
}
legend("bottomright", legend = calls[-1], col = cols, lwd = 2, lty = win.vec)
#	dev.off()
winning.optim.call[i] <- c("L-BFGS-B", "L-BFGS-B wt", "N-M", "N-M wt", "SANN", "SANN wt")[winner]
resids.mat[i, complete] <- get.lg5.resids(params = lg5.output.LB.wt$par, doy, dbh)
}
close(pb)
names(optim.output.df) <- c("Tree.no", "Optim.call", "L", "K", "doy_ip", "r", "theta", "ML", "Best.ML")
winner.tab <- table(winning.optim.call)
###################################################
### code chunk number 16: data_fig
###################################################
plot(doy.1, dbh.1, xlab = "Day of the year", ylab = "DBH (cm)", pch = 18,
col = "tomato", main = "Cumulative annual growth")
###################################################
### code chunk number 17: four_examples
###################################################
par(mfrow = c(2,2), mar = c(4,4,2,2))
trees <- c(1, 5, 9, 17)
for(ct in 1:length(trees)) {
t <- trees[ct]
cex.val <- 0.8
dbh <- as.numeric(dbh.data[t,])
params.tmp <- as.numeric(Param.df[t, ])
params.out.tmp <- subset(optim.output.df, Tree.no == t, select = -c(Tree.no, Optim.call, Best.ML))
params.out <- as.matrix(params.out.tmp)
complete <- complete.cases(dbh)
dbh <- dbh[complete]
doy <- doy.full[complete]
cols <- brewer.pal(dim(optim.output)[1], name = "Dark2")
plot(doy, dbh, xlab = "Day of the year", ylab = "DBH (cm)", pch = 19, col = "gray15",
main = sprintf("Annual Growth for tree %i", t), cex = 0.8, cex.axis = cex.val,
cex.lab = cex.val, cex.main = cex.val)
days <- seq(365)
for(j in 2:dim(params.out)[1]) {
lines(days, lg5.pred(params = as.numeric(params.out[j ,]), doy = days),
col = cols[j - 1], lty = 2, lwd = 0.75)
}
a <- params.tmp[6:7]
lines(days, lg5.pred.a(a, params = params.tmp, doy = days, asymptote = "both"),
col = "darkred", lty = 1.5, lwd = 1)
legend("topleft", legend = sprintf("%s)", letters[ct]), bty = "n",
cex = cex.val, inset)
legend("bottomright", legend = c(calls[-1], "Lo-Hi"), col = c(cols, "darkred"),
lty = c(rep(2, 6), 1), lwd = 1, cex = 0.5)
}
layout(matrix(c(1,1,1,1,2,2,3,3), ncol = 2, byrow = TRUE))
QH.list <- vector("list", dim(Param.df)[1])
WD.sum <- vector(length = dim(Param.df)[1])
D.sum <- vector(length = dim(Param.df)[1])
RGR <- vector(length = dim(Param.df)[1])
GR <- vector(length = dim(Param.df)[1])
Size <- vector(length = dim(Param.df)[1])
tree.no <- dim(dbh.data)[1]
doy.full <- get.doy(dbh.data)
Param.df <- as.data.frame(array(dim = c(tree.no, 7)))
deviation.val <- c(0.01)
seq.l <- 200
start.d <- matrix(NA, tree.no, 4)
end.d <- matrix(NA, tree.no, 4)
par(mfrow = c(2,2))
for(i in 1:tree.no) {
print(i)
#	par(mfrow = c(1,1))
#	pdf(file = sprintf("FIGURES/Low_up_%i.pdf", i))
dbh <- as.numeric(dbh.data[i,])
complete <- complete.cases(dbh)
dbh <- dbh[complete]
doy <- doy.full[complete]
doy.ip.hat <- doy[(which(dbh > mean(dbh)))[1]]
par.list <- list(L = min(dbh, na.rm = TRUE), K = max(dbh, na.rm = TRUE), doy.ip = doy.ip.hat, r = 0.08, theta = 1)
params <- as.numeric(unlist(par.list))
optim.min <- c((min(dbh, na.rm = TRUE) * 0.99), quantile(dbh, 0.5, na.rm = TRUE), 0, 0, 0.01)
optim.max <- c(min(dbh, na.rm = TRUE), max(dbh, na.rm = TRUE), 350, 0.1, 15)
resid.sd <- 0.1
##  THESE ARE THE CALLS TO OPTIM  ##
lg5.output.LB <- optim(par = params, doy = doy, dbh = dbh, resid.sd = resid.sd, fn = lg5.ML, method = "L-BFGS-B", lower = optim.min, upper = optim.max, hessian = TRUE, control = list(trace = 0))
params <- lg5.output.LB$par
win.optim.call <- winning.optim.call[i]
if(win.optim.call == "L-BFGS-B wt") {
hi.lo.output <- optim(par = params, doy = doy, dbh = dbh, resid.sd = resid.sd, fn = lg5.ML.wt, method = "L-BFGS-B", hessian = TRUE, control = list(trace = 0))
}else{
hi.lo.output <- optim(par = params, doy = doy, dbh = dbh, resid.sd = resid.sd, fn = lg5.ML.wt, method = "Nelder-Mead", hessian = TRUE, control = list(trace = 0))
}
params.tmp <- hi.lo.output$par
## Now call the boundary functions
start.d[i ,] <- start.diam(params = params.tmp, seq.l = seq.l,  doy = doy, dbh, deviation.val = deviation.val, figure = FALSE, resid.sd)
end.d[i, ] <- end.diam(params = params.tmp, seq.l, doy, dbh, deviation.val, figure = FALSE, resid.sd)  #fix this ... dev.val too small
a <- c(start.d[i, 1], end.d[i, 1])
plot(doy, dbh, xlab = "Day of the year", ylab = "DBH (cm)", pch = 19, col = "gray15", main = sprintf("Annual Growth for tree %i", i), cex = 1)
lines(days, lg5.pred.a(a, params = params.tmp, doy = days, asymptote = "both"), col = "darkred", lty = 1, lwd = 1)
Param.df[i, 6:7] <- a
Param.df[i, 1:5] <- params.tmp
#	dev.off()
}
names(Param.df) <- c("L", "K", "doy_ip", "r", "theta", "a", "b")
View(Param.df)
#first, functions are defined to resemble the equations described on the website. Each function is used in the following one.
objectiveFuncDendro= function(diameter2,diameter1,gap1,gap2){
if(gap1>diameter1) return(20)
if(gap2>diameter2) return(20)
delta=abs(diameter1 - diameter2 + (1/pi) * diameter2 * asin(gap2/diameter2) - (1/pi) * diameter1 * asin(gap1/diameter1))
return(return(delta))
}
findOneDendroDBH= function(dbh1,m1,m2,func=objectiveFuncDendro){
if(is.na(dbh1)|is.na(m1)|is.na(m2)|dbh1<=0) return(NA)
if(m2>0) upper=dbh1+m2
else upper=dbh1+1
if(m2<m1) lower=0
else lower=dbh1
result=optimize(f=func,interval=c(lower,upper),diameter1=dbh1,gap1=m1,gap2=m2)
return(result$minimum)
}
findDendroDBH= function(dbh1,m1,m2,func=objectiveFuncDendro){
records=max(length(dbh1),length(m1),length(m2))
if(length(dbh1)==1) dbh1=rep(dbh1,records)
if(length(m1)==1) m1=rep(m1,records)
if(length(m2)==1) m2=rep(m2,records)
dbh2=numeric()
for(i in 1:records) dbh2[i]=findOneDendroDBH(dbh1[i],m1[i],m2[i],func)
return(dbh2)
}
#next, with sample data of dbh1, measure 1, and measure 2, here's an example of what the derived dbh would be based on measurements.
dbh1 = c(100, 200, 300, 100, 200, 300)
m1 = c(0, 0, 0, 0, 0, 0)
m2 = c(2, 2, 2, 50, 50, 50)
dbh2 = findDendroDBH(dbh1, m1, m2)
data.frame(dbh1, m1, m2, dbh)
data.frame(dbh1, m1, m2, dbh2)
install.packages("rdata")
attach('C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/Dendrobands/Rscripts/analysis/CTFSRPackage.rdata')
ls(2)
