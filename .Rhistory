theme_minimal()
#no total regression equation at bottom because all species are accounted for in dataset.
bark$predict_barkthick.ln.mm <- NA
bark$predict_barkthick.ln.mm <-
ifelse(bark$species == "caco", -1.56+0.416*log(bark$diam_nobark_2008.mm),
ifelse(bark$species == "cagl", -0.393+0.268*log(bark$diam_nobark_2008.mm),
ifelse(bark$species == "caovl", -2.18+0.651*log(bark$diam_nobark_2008.mm),
ifelse(bark$species == "cato", -0.477+0.301*log(bark$diam_nobark_2008.mm),
ifelse(bark$species == "fram", 0.418+0.268*log(bark$diam_nobark_2008.mm),
ifelse(bark$species == "juni", 0.346+0.279*log(bark$diam_nobark_2008.mm),
ifelse(bark$species == "litu", -1.14+0.463*log(bark$diam_nobark_2008.mm),
ifelse(bark$species == "qual", -2.09+0.637*log(bark$diam_nobark_2008.mm),
ifelse(bark$species == "qupr", -1.31+0.528*log(bark$diam_nobark_2008.mm),
ifelse(bark$species == "quru", -0.593+0.292*log(bark$diam_nobark_2008.mm),
ifelse(bark$species == "quve", 0.245+0.219*log(bark$diam_nobark_2008.mm),
bark$predict_barkthick.ln)))))))))))
#4. Take exponent of bark.depth.mm and make sure predicted values look good.
bark$predict_barkthick.mm <- exp(bark$predict_barkthick.ln.mm)
range(bark$predict_barkthick.mm - bark$bark.depth.mm)
#5. Get mean bark thickness per species in 2008.
## The equation for calculating old dbh, using 1999 as an example, is
## dbh1999 = dbh2008 - 2(ring.width2013 - ring.width1999) - 2(bark.depth2008) + 2(bark.depth1999)
## using the dataset from calculating the regression equations, we can get mean bark thickness per species in 2008.
##set up dbh dataframe
dbh <- trees_all[, c(1:4)]
scbi.stem1 <- read.csv(text=getURL("https://raw.githubusercontent.com/SCBI-ForestGEO/SCBI-ForestGEO-Data/master/tree_main_census/data/census-csv-files/scbi.stem1.csv"))
dbh$dbh2008.mm <- scbi.stem1$dbh[match(dbh$tree, scbi.stem1$tag)]
mean_bark <- aggregate(bark$bark.depth.mm, by=list(bark$species), mean) #mm
colnames(mean_bark) <- c("sp", "mean_bark_2008.mm")
dbh$mean_bark_2008.mm <- ifelse(dbh$sp %in% mean_bark$sp, mean_bark$mean_bark_2008.mm[match(dbh$sp, mean_bark$sp)], mean(bark$bark.depth.mm))
dbh$mean_bark_2008.mm <- round(dbh$mean_bark_2008.mm, 2)
#6.Thus, the only value we're missing is bark depth in 1999.
## This is ok, because we can calculate from the regression equation per each species (all we need is diam_nobark_1999).Calculate diam_nobark_1999 using
## diam_nobark_1999 = dbh2008 - 2*(bark.depth2008) - 2*(sum(ring.width1999:ring.width2008))
##define this column before loop
dbh$diam_nobark_old.mm <- 0
for (i in seq(along=widths)){
df <- widths[[i]] #the list "widths" comes from #4a-4b
colnames(df) <- gsub("A", "", colnames(df)) #remove "A"
colnames(df) <- gsub("^0", "", colnames(df)) #remove leading 0
cols <- colnames(df) #define cols for below
colnames(df) <- gsub("^", "x", colnames(df)) #add "x" to make calling colnames below feasible
for (j in seq(along=cols)){
for (k in seq(along=colnames(df))){
ring_ind <- cols[[j]]
ring_col <- colnames(df)[[k]]
if(j==k){
#the output of this loop is 3 separate columns for each year's old dbh, hence why it is set to q as a dataframe before being combined below. Pointer_years_simple comes from #4d.
q <- data.frame(sapply(pointer_years_simple, function(x){
rw <- df[rownames(df)>=x, ]
ifelse(dbh$year == x & dbh$tree == ring_ind,
dbh$dbh2008.mm - 2*(dbh$mean_bark_2008.mm) - sum(rw[rownames(rw) %in% c(x:2008), ring_col], na.rm=TRUE), 0)
}))
q$diam_nobark_old.mm <- q[,1] +q[,2] + q[,3] #add columns together
# q$dbh_old.mm <- q[,1] +q[,2] + q[,3] + q[,4]
dbh$diam_nobark_old.mm <- dbh$diam_nobark_old.mm + q$diam_nobark_old.mm #combine with dbh (it's the same order of rows) #mm
}
#7. Calculate bark thickness using regression equation per appropriate sp
## log(bark.depth.1999) = intercept + log(diam_nobark)*constant
## bark.depth.1999 = exp(log(bark.depth.1999))
#the full equation at the bottom is the regression equation for all these species put together. "fagr" is given a bark thickness of 0 because it is negligble
#these equations are the same as above in #3 of this code section
dbh$bark_thick_old.ln.mm <- NA
dbh$bark_thick_old.ln.mm <- ifelse(dbh$sp == "caco", -1.56+0.416*log(dbh$diam_nobark_old.mm),
ifelse(dbh$sp == "cagl", -0.393+0.268*log(dbh$diam_nobark_old.mm),
ifelse(dbh$sp == "caovl", -2.18+0.651*log(dbh$diam_nobark_old.mm),
ifelse(dbh$sp == "cato", -0.477+0.301*log(dbh$diam_nobark_old.mm),
ifelse(dbh$sp == "fram", 0.418+0.268*log(dbh$diam_nobark_old.mm),
ifelse(dbh$sp == "juni", 0.346+0.279*log(dbh$diam_nobark_old.mm),
ifelse(dbh$sp == "litu", -1.14+0.463*log(dbh$diam_nobark_old.mm),
ifelse(dbh$sp == "qual", -2.09+0.637*log(dbh$diam_nobark_old.mm),
ifelse(dbh$sp == "qupr", -1.31+0.528*log(dbh$diam_nobark_old.mm),
ifelse(dbh$sp == "quru", -0.593+0.292*log(dbh$diam_nobark_old.mm),
ifelse(dbh$sp == "quve", 0.245+0.219*log(dbh$diam_nobark_old.mm),
ifelse(dbh$sp == "fagr", 0,
-1.01+0.213*log(dbh$diam_nobark_old.mm)))))))))))))
dbh$bark_thick_old.mm <- ifelse(dbh$sp == "fagr", 0, exp(dbh$bark_thick_old.ln.mm))
#8. Add to solution from #6 to get full dbh1999
## dbh1999 = diam_nobark_1999 + 2*bark.depth.1999
dbh$dbh_old.mm <- dbh$diam_nobark_old.mm + 2*dbh$bark_thick_old.mm
##NOTE
##The first time I ran this code I was getting NaNs for one tree (140939), because the dbh in 2008 was listed as 16.9. I double-checked this, and that was the second stem, which we obviously didn't core at a size of 1.69 cm (or 2.2 cm in 2013). The dbh is meant to be the first stem. However, there was confusion with the dbh in the field.
trees_all$dbh_old.mm <- dbh$dbh_old.mm[match(trees_all$tree, dbh$tree) & match(trees_all$year, dbh$year)] #mm
trees_all$dbh_old.cm <- trees_all$dbh_old.mm/10
trees_all$dbh.ln.cm <- log(trees_all$dbh_old.cm)
##5f. add in ratio of sapwood area to total wood ####
### It has been determined that since sapwood ratio is so tied to DBH (in other words, testing it in a model is akin to testing DBH again), that we are going to leave it out of the full models. However, I'm leaving the code here in case we want anything with it later.
#calculate sapwood area
##sapwood area[iii] = tree area (minus bark)[i] - heartwood area[ii]
sap <- read.csv("data/SCBI_Sapwood_Data.csv", stringsAsFactors = FALSE)
sap <- sap[,c(1:5,8:10,24)]
sap$sp <- paste0(gsub("^(..).*", "\\1", sap$Latin),
gsub("^.* (..).*", "\\1", sap$Latin))
sap$sp <- tolower(sap$sp)
##subtract bark thickness from dbh
##NOTE bark thickness is from 2008, even tho sap data collected 2010
##[[i]]
sap$dbh_nobark.mm <- 0
for (i in seq(along=mean_bark$mean_bark_2008)){
sub <- mean_bark[mean_bark$mean_bark_2008[[i]] == mean_bark$mean_bark_2008, ]
sap$dbh_nobark.mm <- ifelse(sap$sp == sub$sp, sap$DBH-sub$mean_bark_2008, sap$dbh_nobark)
}
#[ii]
#heartwood radius = 0.5*dbh – sapwood depth (mm)
sap$hw_rad.mm <- 0.5*sap$dbh_nobark.mm - sap$sapwood.depth..mm.
#Heartwood area = pi*(heartwood radius)^2 (mm^2)
sap$hw_area.mm2 <- pi*(sap$hw_rad.mm)^2
#[iii]
#Sapwood area = pi*((0.5*dbh)^2) – heartwood area (cm^2 with the /100)
sap$sap_area.cm2 <- (pi*(0.5*sap$dbh_nobark.mm)^2 - sap$hw_area.mm2)/100
sap <- sap[sap$sp %in% sp_can | sap$sp %in% sp_subcan, ]
#ratio = sapwood area:area without bark
##calculate ratio to find the regression equations
sap$dbh_nobark.cm <- sap$dbh_nobark.mm/10
sap$total_wood_area.cm2 <- pi*(sap$dbh_nobark.cm/2)^2
sap$sap_ratio <- sap$sap_area.cm2/sap$total_wood_area.cm2
#these equations are for getting the sapwood_area for the dbh df, which are then converted to sap_ratio for that df.
source_gist("524eade46135f6348140")
#DBH = mm, sap_area = cm^2
ggplot(data = sap, aes(x = log(DBH), y = log(sap_area.cm2))) +
stat_smooth_func(geom="text",method="lm",hjust=0.16, vjust=0.8,parse=TRUE) +
geom_smooth(method="lm", se=FALSE, color="black") +
geom_point(color = "#0c4c8a") +
theme_minimal() +
facet_wrap(vars(sp))
ggplot(data = sap, aes(x = log(DBH), y = log(sap_area.cm2))) +
stat_smooth_func(geom="text",method="lm",hjust=0.16, vjust=-1,parse=TRUE) +
geom_smooth(method="lm", se=FALSE, color="black") +
geom_point(color = "#0c4c8a") +
theme_minimal()
#original equations. I'm not sure what happened, but I think after changing some units, I forgot to update these. Nevertheless, I'm leaving them as is in case I messed up.
# #the bottom equation is the total regression equation
# dbh$sapwood_area.ln <- NA
# dbh$sapwood_area.ln <- ifelse(dbh$sp == "caco", 6.17-0.419*log(dbh$dbh_old.mm),
#                        ifelse(dbh$sp == "cagl", 5.32-0.26*log(dbh$dbh_old.mm),
#                        ifelse(dbh$sp == "cato", 6.51-0.444*log(dbh$dbh_old.mm),
#                        ifelse(dbh$sp == "fram", 2.19+0.326*log(dbh$dbh_old.mm),
#                        ifelse(dbh$sp == "juni", 5.53-0.404*log(dbh$dbh_old.mm),
#                        ifelse(dbh$sp == "litu", 4.31-0.0718*log(dbh$dbh_old.mm),
#                        ifelse(dbh$sp == "qual", 7.09-0.692*log(dbh$dbh_old.mm),
#                        ifelse(dbh$sp == "qupr", 4.99-0.305*log(dbh$dbh_old.mm),
#                        ifelse(dbh$sp == "quru", 4.27-0.282*log(dbh$dbh_old.mm),
#                        ifelse(dbh$sp == "quve", 5.1-0.402*log(dbh$dbh_old.mm),
#                                    6.6-0.543*log(dbh$dbh_old.mm)))))))))))
#the bottom equation is the total regression equation
dbh$sapwood_area.ln <- NA
dbh$sapwood_area.ln <- ifelse(dbh$sp == "caco", -3.41+1.6*log(dbh$dbh_old.mm),
ifelse(dbh$sp == "cagl", -4.34+1.77*log(dbh$dbh_old.mm),
ifelse(dbh$sp == "cato", -3.14+1.59*log(dbh$dbh_old.mm),
ifelse(dbh$sp == "fram", -7.75+2.4*log(dbh$dbh_old.mm),
ifelse(dbh$sp == "juni", -4.23+1.64*log(dbh$dbh_old.mm),
ifelse(dbh$sp == "litu", -5.5+1.98*log(dbh$dbh_old.mm),
ifelse(dbh$sp == "qual", -2.66+1.35*log(dbh$dbh_old.mm),
ifelse(dbh$sp == "qupr", -4.89+1.76*log(dbh$dbh_old.mm),
ifelse(dbh$sp == "quru", -5.35+1.74*log(dbh$dbh_old.mm),
ifelse(dbh$sp == "quve", -4.57+1.63*log(dbh$dbh_old.mm),
-3.13+1.5*log(dbh$dbh_old.mm)))))))))))
dbh$sapwood_area.cm2 <- exp(dbh$sapwood_area.ln)
#calculate ratio for each tree using regression equations
##prepare: get radius.w/o.bark (/2) and convert to cm (/10).
dbh$radius_nobark.cm <- (dbh$diam_nobark_old/2)/10
##total wood area = pi*(radius.nobark)^2 (cm^2)
dbh$total_wood_area.cm2 <- pi*(dbh$radius_nobark.cm)^2
dbh$sap_ratio <- dbh$sapwood_area.cm2/dbh$total_wood_area.cm2
trees_all$sap_ratio <- dbh$sap_ratio[match(trees_all$tree, dbh$tree) & match(trees_all$year, dbh$year)]
##5g. add in tree heights ####
## taken from the canopy_heights script
#the full equation is using all points for which we have data to create the equation, despite that for several species we don't have enough data to get a sp-specific equation
trees_all$height.ln.m <- ifelse(trees_all$sp == "caco", (0.55+0.766*trees_all$dbh.ln.cm),
ifelse(trees_all$sp == "cagl", (0.652+0.751*trees_all$dbh.ln.cm),
ifelse(trees_all$sp == "caovl", (0.9+0.659*trees_all$dbh.ln.cm),
ifelse(trees_all$sp == "cato", (0.879+0.668*trees_all$dbh.ln.cm),
ifelse(trees_all$sp == "fagr", (0.513+0.712*trees_all$dbh.ln.cm),
ifelse(trees_all$sp == "litu", (1.57+0.488*trees_all$dbh.ln.cm),
ifelse(trees_all$sp == "quru", (1.13+0.54*trees_all$dbh.ln.cm),
(1.11+0.573*trees_all$dbh.ln.cm))))))))
#0.849+0.659*trees_all$dbh_ln.cm -> original equation only using points from the species for which we had equations. This was yielding predicted heights for some trees of about 54m.
trees_all$height.m <- exp(trees_all$height.ln.m) #m, because these equations come from a plotting of log(DBH in cm) against log(height in m).
##5h. add in all crown positions ####
positions <- read.csv(text=getURL("https://raw.githubusercontent.com/SCBI-ForestGEO/SCBI-ForestGEO-Data/master/tree_dimensions/tree_crowns/cored_dendroband_crown_position_data/dendro_cored_full.csv"))
trees_all$position_all <- positions$crown.position[match(trees_all$tree, positions$tag)]
trees_all$position_all <- gsub("D", "dominant", trees_all$position_all)
trees_all$position_all <- gsub("C", "co-dominant", trees_all$position_all)
trees_all$position_all <- gsub("I", "intermediate", trees_all$position_all)
trees_all$position_all <- gsub("S", "suppressed", trees_all$position_all)
#this has been proven to be roughly equivalent to position_all, so we're sticking with position_all
# trees_all$illum <- positions$illum[match(trees_all$tree, positions$tag)]
# trees_all$illum <- as.character(trees_all$illum)
#this csv has avg/min/max dbh for each canopy position by sp
# positionsp <- read.csv("data/core_chronologies_by_crownposition.csv")
##5i. remove all NAs and one bad tree ####
trees_all <- trees_all[complete.cases(trees_all), ]
##fram 140939 has been mislabeled. It is recorded as having a small dbh when that is the second stem. In terms of canopy position, though, it fell between time of coring and when positions were recorded, thus we do not know its position.
trees_all <- trees_all[!trees_all$tree == 140939, ]
##5j. remove resistance values >2 ####
trees_all <- trees_all[trees_all$resist.value <=2,]
##5k. make subsets for individual years, combine all to list ####
# x1964 <- trees_all[trees_all$year == 1964, ]
x1966 <- trees_all[trees_all$year == 1966, ]
x1977 <- trees_all[trees_all$year == 1977, ]
x1999 <- trees_all[trees_all$year == 1999, ]
model_df <- list(trees_all, x1966, x1977, x1999)
names(model_df) <- c("all_years", "x1966", "x1977", "x1999")
library(lme4)
library(AICcmodavg) #aictab function
library(car)
library(piecewiseSEM) #for R^2 values for all model outputs in a list
library(MuMIn) #for R^2 values of one model output
library(stringr)
library(dplyr)
summary_models <- data.frame(
"prediction" = c("1.0", "1.1", "1.2a", "1.2b", "1.2c1, 1.3a1", "1.2c2", "1.3b1", "1.3a2", "1.3b2", "2.1", "2.2", "4"),
"model_vars_all_years" =
c("resist.value ~ dbh.ln.cm+year+(1|sp/tree)",
"resist.value ~ height.ln.m+year+(1|sp/tree)",
"resist.value ~ position_all+year+(1|sp/tree)",
"resist.value ~ position_all+height.ln.m+year+(1|sp/tree)",
"resist.value ~ elev.m+height.ln.m+year+(1|sp/tree)",
"resist.value ~ elev.m*height.ln.m+height.ln.m+year+(1|sp/tree)",
"resist.value ~ distance.ln.m+height.ln.m+year+(1|sp/tree)",
"resist.value ~ distance.ln.m*height.ln.m+height.ln.m+year+(1|sp/tree)",
"resist.value ~ tlp+height.ln.m+year+(1|sp/tree)",
"resist.value ~ rp+height.ln.m+year+(1|sp/tree)",
"resist.value ~ sap_ratio+position_all+height.ln.m+height.ln.m*elev.m+distance.ln.m+tlp+rp+year+(1|sp/tree)"),
"null_model_all_years" = NA,
"model_vars_sep_years" = NA,
"null_model_sep_years" = NA,
"response_predict" = c(-1, -1, -1, -1, 1, 1, -1, 1, -1, -1, 1, NA),
"response_sign" = c("-", "-", "dominant < codominant < intermediate < supressed", "dominant < codominant < intermediate < supressed", "+", "+", "-", "+", "-", "-", "ring>diffuse", "+"),
"dAIC_all_years" = NA,
"response_obs_all" = NA,
"coef_all_years" = NA,
"dAIC_1964.1966" = NA,
"response_obs_1964.1966" = NA,
"coef_1964.1966" = NA,
"dAIC_1977" = NA,
"response_obs_1977" = NA,
"coef_1977" = NA,
"dAIC_1999" = NA,
"response_obs_1999" = NA,
"coef_1999" = NA,
"notes" = "",
"coef_all_big" = NA,
"coef_1966_big" = NA,
"coef_1977_big" = NA,
"coef_1999_big" = NA)
# change factor columns to character
summary_models %>% mutate_if(is.factor, as.character) -> summary_models
# fill in other columns
summary_models[c(1:3), 3] <- "resist.value ~ year+(1|sp/tree)"
summary_models[c(4:12), 3] <- "resist.value ~ height.ln.m+year+(1|sp/tree)"
summary_models$model_vars_sep_years <- gsub("year\\+|/tree", "", summary_models$model_vars_all_years)
summary_models$null_model_sep_years <- gsub("year\\+|/tree", "", summary_models$null_model_all_years)
#define vectors to be used in loop
summary_mod_vars_all <- summary_models$model_vars_all_years
summary_mod_vars_sep <- summary_models$model_vars_sep_years
summary_mod_null_all <- summary_models$null_model_all_years
summary_mod_null_sep <- summary_models$null_model_sep_years
##this loop goes through each mix of effects from each prediction (nrow(summary_models)), and runs those models for each of the datasets (all years and the three individual ones). For each iteration (44 total), it calculates dAIC (AIC of model with variable defined in model_vars columns minus the AIC of the null model) and the coefficients before putting them in the table created above.
for (i in seq_along(model_df)){
for (h in seq(along=summary_mod_vars_all)){
if (i==1){
#structure of creating the model strings come from 6a above.
response <- gsub(" ~.*", "", summary_mod_vars_all[[h]])
effects <- unlist(strsplit(summary_mod_vars_all[[h]], "\\+|~ "))[-1]
#create all combinations of random / fixed effects
effects_comb <-
unlist( sapply( seq_len(length(effects)),
function(i) {
apply( combn(effects,i), 2, function(x) paste(x, collapse = "+"))
}))
#make table
var_comb <- expand.grid(response, effects_comb)
var_comb <- var_comb[grepl("1", var_comb$Var2), ] #only keep in fixed/random combos
var_comb <- var_comb[grepl("year", var_comb$Var2), ] #keep year in for drought sake
}
else {
#define response and effects
response <- gsub(" ~.*", "", summary_mod_vars_sep[[h]])
effects <- unlist(strsplit(summary_mod_vars_sep[[h]], "\\+|~ "))[-1]
# all fixed effects <- c("position", "tlp", "rp", "elev.m", "dbh_ln", "height_ln.m")
#create all combinations of random / fixed effects
effects_comb <-
unlist( sapply( seq_len(length(effects)),
function(i) {
apply( combn(effects,i), 2, function(x) paste(x, collapse = "+"))
}))
#=make table
var_comb <- expand.grid(response, effects_comb)
var_comb <- var_comb[grepl("1", var_comb$Var2), ] #only keep in fixed+random combos
}
#formulas for all combinations.
formula_vec <- sprintf("%s ~ %s", var_comb$Var1, var_comb$Var2)
# create list of model outputs
lmm_all <- lapply(formula_vec, function(x){
fit1 <- lmer(x, data = model_df[[i]], REML=FALSE,
control = lmerControl(optimizer ="Nelder_Mead"))
return(fit1)
})
names(lmm_all) <- formula_vec
var_aic <- aictab(lmm_all, second.ord=TRUE, sort=TRUE) #rank based on AICc
r <- rsquared(lmm_all) #gives R^2 values for models. "Marginal" is the R^2 for just the fixed effects, "Conditional" is the R^2 for everything.
#fill in table
if(i == 1){
#isolate the AIC values of the target (sub) and null models, then math
var_aic_sub <- var_aic[var_aic$Modnames == summary_mod_vars_all[[h]], ]
var_aic_null <- var_aic[var_aic$Modnames == summary_mod_null_all[[h]], ]
summary_models[,8][[h]] <- round(var_aic_null$Delta_AICc - var_aic_sub$Delta_AICc, 2)
var_aic_sub$Modnames <- as.character(var_aic_sub$Modnames)
#this loop says for the models run for this iteration of h, take the model output represented by the target model (1). Get the coefficients and put in df (2). Rename variables such that you only pull what you need (3) and extract the coefficient for the variable you want (4).
for (z in seq(along = lmm_all)){
if (z == rownames(var_aic_sub)){ ##1
coeff <- data.frame(coef(summary(lmm_all[[z]]))[ , "Estimate"]) ##2
coeff[,2] <- rownames(coeff)
colnames(coeff) <- c("value", "model_var")
if (h == 3){ ##3
coeff$model_var <- gsub("subcanopy", "", coeff$model_var)
} else if (h == 4){
coeff$model_var <- gsub("subcanopy", "", coeff$model_var)
coeff$model_var <- gsub("height", "ht_nat_ln", coeff$model_var)
} else if (h %in% 5:10){
coeff$model_var <- gsub("height", "ht_nat_ln", coeff$model_var)
} else if (h == 11){
coeff$model_var <- gsub("ring", "", coeff$model_var)
coeff$model_var <- gsub("height", "ht_nat_ln", coeff$model_var)
} else if (h == 12){
coeff$model_var <- gsub("subcanopy", "", coeff$model_var)
coeff$model_var <- gsub("ring", "", coeff$model_var)
coeff$model_var <- gsub("height", "ht_nat_ln", coeff$model_var)
full_mod <- var_aic[!duplicated(var_aic$Delta_AICc), ]
full_mod <- full_mod[1:10, c(1,4)]
full_mod[11,] <- var_aic_sub[,c(1,4)]
colnames(full_mod) <- c("Modnames_all_years", "dAIC_all_years")
}
for (y in seq(along = coeff$model_var)){ ##4
same <- coeff$model_var[[y]]
if(grepl(same, summary_mod_vars_all[[h]])){
coeff_sub <- coeff[coeff$model_var == same, ]
}
#update the coefficient value
summary_models[,9][[h]] <- ifelse(coeff_sub$value<0, -1, 1)
summary_models[,10][[h]] <- ifelse(h == 12, NA, coeff_sub$value)
#update the table. If the sign conventions of the coefficient and the predicted response do not match, assign NA.
# if (h!=12){
#   summary_models[,8][[h]] <- ifelse(
#     (coeff_sub$value <0 & summary_models$response_predict[[h]] <0) |
#       (coeff_sub$value >0 & summary_models$response_predict[[h]] >0),
#     summary_models[,8][[h]], NA)
# }
if(h==12){
coeff <- coeff[-1,]
coeff_max <- coeff[coeff$value == max(coeff$value), ]
summary_models[,21][[h]] <- coeff_max$model_var
}
else if (i == 2) {
#isolate the AIC values of the target (sub) and null models, then math
var_aic_sub <- var_aic[var_aic$Modnames == summary_mod_vars_sep[[h]], ]
var_aic_null <- var_aic[var_aic$Modnames == summary_mod_null_sep[[h]], ]
summary_models[,11][[h]] <- round(var_aic_null$Delta_AICc - var_aic_sub$Delta_AICc, 2)
var_aic_sub$Modnames <- as.character(var_aic_sub$Modnames)
#this loop says for the models run for this iteration of h, take the model output represented by the target model (1). Get the coefficients and put in df (2). Rename variables such that you only pull what you need (3) and extract the coefficient for the variable you want (4).
for (z in seq(along = lmm_all)){
if (z == rownames(var_aic_sub)){ ##1
coeff <- data.frame(coef(summary(lmm_all[[z]]))[ , "Estimate"]) ##2
coeff[,2] <- rownames(coeff)
colnames(coeff) <- c("value", "model_var")
if (h == 3){ ##3
coeff$model_var <- gsub("subcanopy", "", coeff$model_var)
} else if (h == 4){
coeff$model_var <- gsub("subcanopy", "", coeff$model_var)
coeff$model_var <- gsub("height", "ht_nat_ln", coeff$model_var)
} else if (h %in% 5:10){
coeff$model_var <- gsub("height", "ht_nat_ln", coeff$model_var)
} else if (h == 11){
coeff$model_var <- gsub("ring", "", coeff$model_var)
coeff$model_var <- gsub("height", "ht_nat_ln", coeff$model_var)
} else if (h == 12){
coeff$model_var <- gsub("subcanopy", "", coeff$model_var)
coeff$model_var <- gsub("ring", "", coeff$model_var)
coeff$model_var <- gsub("height", "ht_nat_ln", coeff$model_var)
full_mod_1966 <- var_aic[!duplicated(var_aic$Delta_AICc), ]
full_mod_1966 <- full_mod_1966[1:10, c(1,4)]
full_mod_1966[11,] <- var_aic_sub[,c(1,4)]
colnames(full_mod_1966) <- c("Modnames_1966", "dAIC_1966")
}
for (y in seq(along = coeff$model_var)){ ##4
same <- coeff$model_var[[y]]
if(grepl(same, summary_mod_vars_all[[h]])){
coeff_sub <- coeff[coeff$model_var == same, ]
}
#update the coefficient value
summary_models[,12][[h]] <- ifelse(coeff_sub$value<0, -1, 1)
summary_models[,13][[h]] <- ifelse(h == 12, NA, coeff_sub$value)
#update the table. If the sign conventions of the coefficient and the predicted response do not match, assign NA.
# if (h!=12){
#   summary_models[,10][[h]] <- ifelse(
#     (coeff_sub$value <0 & summary_models$response_predict[[h]] <0) |
#       (coeff_sub$value >0 & summary_models$response_predict[[h]] >0),
#     summary_models[,10][[h]], NA)
# }
if(h==12){
coeff <- coeff[-1,]
coeff_max <- coeff[coeff$value == max(coeff$value), ]
summary_models[,22][[h]] <- coeff_max$model_var
}
else if (i == 3){
#isolate the AIC values of the target (sub) and null models, then math
var_aic_sub <- var_aic[var_aic$Modnames == summary_mod_vars_sep[[h]], ]
var_aic_null <- var_aic[var_aic$Modnames == summary_mod_null_sep[[h]], ]
summary_models[,14][[h]] <- round(var_aic_null$Delta_AICc - var_aic_sub$Delta_AICc, 2)
var_aic_sub$Modnames <- as.character(var_aic_sub$Modnames)
#this loop says for the models run for this iteration of h, take the model output represented by the target model (1). Get the coefficients and put in df (2). Rename variables such that you only pull what you need (3) and extract the coefficient for the variable you want (4).
for (z in seq(along = lmm_all)){
if (z == rownames(var_aic_sub)){ ##1
coeff <- data.frame(coef(summary(lmm_all[[z]]))[ , "Estimate"]) ##2
coeff[,2] <- rownames(coeff)
colnames(coeff) <- c("value", "model_var")
if (h == 3){ ##3
coeff$model_var <- gsub("subcanopy", "", coeff$model_var)
} else if (h == 4){
coeff$model_var <- gsub("subcanopy", "", coeff$model_var)
coeff$model_var <- gsub("height", "ht_nat_ln", coeff$model_var)
} else if (h %in% 5:10){
coeff$model_var <- gsub("height", "ht_nat_ln", coeff$model_var)
} else if (h == 11){
coeff$model_var <- gsub("ring", "", coeff$model_var)
coeff$model_var <- gsub("height", "ht_nat_ln", coeff$model_var)
} else if (h == 12){
coeff$model_var <- gsub("subcanopy", "", coeff$model_var)
coeff$model_var <- gsub("ring", "", coeff$model_var)
coeff$model_var <- gsub("height", "ht_nat_ln", coeff$model_var)
full_mod_1977 <- var_aic[!duplicated(var_aic$Delta_AICc), ]
full_mod_1977 <- full_mod_1977[1:10, c(1,4)]
full_mod_1977[11,] <- var_aic_sub[,c(1,4)]
colnames(full_mod_1977) <- c("Modnames_1977", "dAIC_1977")
}
for (y in seq(along = coeff$model_var)){ ##4
same <- coeff$model_var[[y]]
if(grepl(same, summary_mod_vars_all[[h]])){
coeff_sub <- coeff[coeff$model_var == same, ]
}
#update the coefficient value
summary_models[,15][[h]] <- ifelse(coeff_sub$value<0, -1, 1)
summary_models[,16][[h]] <- ifelse(h == 12, NA, coeff_sub$value)
#update the table. If the sign conventions of the coefficient and the predicted response do not match, assign NA.
# if(h!=12){
#   summary_models[,12][[h]] <- ifelse(
#     (coeff_sub$value <0 & summary_models$response_predict[[h]] <0) |
#       (coeff_sub$value >0 & summary_models$response_predict[[h]] >0),
#     summary_models[,12][[h]], NA)
# }
if(h==12){
coeff <- coeff[-1,]
coeff_max <- coeff[coeff$value == max(coeff$value), ]
summary_models[,23][[h]] <- coeff_max$model_var
}
else if (i == 4){
#isolate the AIC values of the target (sub) and null models, then math
var_aic_sub <- var_aic[var_aic$Modnames == summary_mod_vars_sep[[h]], ]
var_aic_null <- var_aic[var_aic$Modnames == summary_mod_null_sep[[h]], ]
summary_models[,17][[h]] <- round(var_aic_null$Delta_AICc - var_aic_sub$Delta_AICc, 2)
var_aic_sub$Modnames <- as.character(var_aic_sub$Modnames)
#this loop says for the models run for this iteration of h, take the model output represented by the target model (1). Get the coefficients and put in df (2). Rename variables such that you only pull what you need (3) and extract the coefficient for the variable you want (4).
for (z in seq(along = lmm_all)){
if (z == rownames(var_aic_sub)){ ##1
coeff <- data.frame(coef(summary(lmm_all[[z]]))[ , "Estimate"]) ##2
coeff[,2] <- rownames(coeff)
colnames(coeff) <- c("value", "model_var")
if (h == 3){ ##3
coeff$model_var <- gsub("subcanopy", "", coeff$model_var)
} else if (h == 4){
coeff$model_var <- gsub("subcanopy", "", coeff$model_var)
coeff$model_var <- gsub("height", "ht_nat_ln", coeff$model_var)
} else if (h %in% 5:10){
coeff$model_var <- gsub("height", "ht_nat_ln", coeff$model_var)
} else if (h == 11){
coeff$model_var <- gsub("ring", "", coeff$model_var)
coeff$model_var <- gsub("height", "ht_nat_ln", coeff$model_var)
} else if (h == 12){
coeff$model_var <- gsub("subcanopy", "", coeff$model_var)
coeff$model_var <- gsub("ring", "", coeff$model_var)
coeff$model_var <- gsub("height", "ht_nat_ln", coeff$model_var)
full_mod_1999 <- var_aic[!duplicated(var_aic$Delta_AICc), ]
full_mod_1999 <- full_mod_1999[1:10, c(1,4)]
full_mod_1999[11,] <- var_aic_sub[,c(1,4)]
colnames(full_mod_1999) <- c("Modnames_1999", "dAIC_1999")
full_mod_all <- cbind(full_mod, full_mod_1966, full_mod_1977, full_mod_1999)
}
for (y in seq(along = coeff$model_var)){ ##4
same <- coeff$model_var[[y]]
if(grepl(same, summary_mod_vars_all[[h]])){
coeff_sub <- coeff[coeff$model_var == same, ]
}
#update the coefficient value
summary_models[,18][[h]] <- ifelse(coeff_sub$value<0, -1, 1)
summary_models[,19][[h]] <- ifelse(h == 12, NA, coeff_sub$value)
#update the table. If the sign conventions of the coefficient and the predicted response do not match, assign NA.
# if (h!=12){
#   summary_models[,14][[h]] <- ifelse(
#     (coeff_sub$value <0 & summary_models$response_predict[[h]] <0) |
#       (coeff_sub$value >0 & summary_models$response_predict[[h]] >0),
#     summary_models[,14][[h]], NA)
# }
if (h==12){
coeff <- coeff[-1,]
coeff_max <- coeff[coeff$value == max(coeff$value), ]
summary_models[,24][[h]] <- coeff_max$model_var
}
View(summary_models)
View(full_mod_all)
View(trees_all)
View(dbh)
