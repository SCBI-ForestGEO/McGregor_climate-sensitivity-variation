}
top_models <- rbind(top_models, top)
}
ord_lab <- c("trees_all", "x1966", "x1977", "x1999")
coeff_list1 <- list()
for(q in seq(along=ord_lab)){
coeff_list_temp <- coeff_list[grepl(ord_lab[[q]], names(coeff_list))]
coeff_list_temp <-
coeff_list_temp[
order((as.numeric(
str_extract(names(coeff_list_temp)
[grepl(ord_lab[[q]], names(coeff_list_temp))],
"[[:digit:]]$")
)))]
coeff_list1 <- c(coeff_list1, coeff_list_temp)
}
View(coeff_list1)
merge.all <- function(x, y) {
merge(x, y, all=TRUE, by="model_var")
}
coeff_table <- Reduce(merge.all, coeff_list1)
coeff_table[,2:ncol(coeff_table)] <- round(coeff_table[,2:ncol(coeff_table)], 3)
coeff_new <- as.data.frame(t(coeff_table[,-1]))
colnames(coeff_new) <- coeff_table$model_var
# coeff_new$year1966 <- ifelse(!is.na(coeff_new$year1977), 0, NA) #only applicable if "year" is a significant variable
coeff_new$codominant <- ifelse(!is.na(coeff_new$position_alldominant), 0, NA)
coeff_new$rpdiffuse <- ifelse(!is.na(coeff_new$rpring), 0, NA)
# coeff_new <- coeff_new[, c("dAICc","r^2", "(Intercept)", "height.ln.m",
#                            "position_alldominant", "codominant", "position_allintermediate","position_allsuppressed",
#                           "rpdiffuse", "rpring", "rpsemi-ring", "TWI.ln", "PLA_dry_percent", "mean_TLP_Mpa")]
coeff_new <- coeff_new[, c("dAICc","r^2", "(Intercept)", "height.ln.m",
"position_alldominant", "codominant", "position_allintermediate","position_allsuppressed",
"rpdiffuse", "rpring", "TWI.ln", "PLA_dry_percent", "mean_TLP_Mpa")]
# colnames(coeff_new) <- c("dAICc", "r^2", "Intercept","ln[H]", "D", "C", "I", "S", "diffuse", "ring", "semi-ring", "ln[TWI]", "PLA", "TLP")
colnames(coeff_new) <- c("dAICc", "r^2", "Intercept","ln[H]", "D", "C", "I", "S", "diffuse", "ring", "ln[TWI]", "PLA", "TLP")
coeff_new <- setDT(coeff_new, keep.rownames = TRUE)[]
setnames(coeff_new, old="rn", new="rank")
patterns <- c("\\[", "x", "\\]")
for(i in seq(along=patterns)){
coeff_new$rank <- gsub(patterns[[i]], "", coeff_new$rank)
}
write.csv(coeff_new, "manuscript/tables_figures/tested_traits_best_coeff.csv", row.names=FALSE)
write.csv(coeff_new, "manuscript/tables_figures/tested_traits_best_coeff.csv", row.names=FALSE)
library(ggplot2)
library(RCurl)
library(tidyr)
library(grid)
library(gridExtra)
trees_all_full <- read.csv("manuscript/tables_figures/trees_all_full.csv", stringsAsFactors = FALSE)
trees_all_full <- read.csv("manuscript/tables_figures/trees_all_sub.csv", stringsAsFactors = FALSE)
graph_traits <- colnames(trees_all_full[, 7:11])
color <- c("dark green", "blue", "gold", "purple", "magenta")
for(i in seq(along=graph_traits)){
trait <- graph_traits[[i]]
trees_all_full$trait <- trees_all_full[, trait]
p <- ggplot(trees_all_full) +
geom_point(aes(x = trait, y = height.ln.m), color = color[[i]]) +
xlab(print(trait)) +
theme_minimal()
assign(paste0(trait, "_plot"), p)
}
graph <- grid.arrange(PLA_dry_percent_plot, LMA_g_per_m2_plot, Chl_m2_per_g_plot, mean_TLP_Mpa_plot, WD_g_per_cm3_plot, nrow=2, top = textGrob(expression(bold("Hydraulic Traits by Height"))))
View(trees_all_full)
graph_traits <- colnames(trees_all_full[, 5:9])
color <- c("dark green", "blue", "gold", "purple", "magenta")
for(i in seq(along=graph_traits)){
trait <- graph_traits[[i]]
trees_all_full$trait <- trees_all_full[, trait]
p <- ggplot(trees_all_full) +
geom_point(aes(x = trait, y = height.ln.m), color = color[[i]]) +
xlab(print(trait)) +
theme_minimal()
assign(paste0(trait, "_plot"), p)
}
graph <- grid.arrange(PLA_dry_percent_plot, LMA_g_per_m2_plot, Chl_m2_per_g_plot, mean_TLP_Mpa_plot, WD_g_per_cm3_plot, nrow=2, top = textGrob(expression(bold("Hydraulic Traits by Height"))))
WD_g_per_cm3_plot
PLA_dry_percent_plot
?gather
graph_traits <- graph_traits %>%
gather("PLA_dry_percent", "LMA_g_per_m2", "Chl_m2_per_g", "mean_TLP_Mpa", "WD_g_per_cm3", key = "trait", value = measure)
data_2018 <- read.csv(text=getURL("https://raw.githubusercontent.com/SCBI-ForestGEO/SCBI-ForestGEO-Data/master/tree_main_census/data/scbi.stem3.csv"), stringsAsFactors=FALSE)
data_2018 <- read.csv(text=getURL("https://raw.githubusercontent.com/SCBI-ForestGEO/SCBI-ForestGEO-Data/master/tree_main_census/data/census-csv-files/scbi.stem3.csv"), stringsAsFactors=FALSE)
data_live <- data_2018[data_2018$Tree_Status == "Live", ]
data_2018 <- read.csv(text=getURL("https://raw.githubusercontent.com/SCBI-ForestGEO/SCBI-ForestGEO-Data/master/tree_main_census/data/census-csv-files/scbi.stem3.csv"), stringsAsFactors=FALSE)
View(data_2018)
data_live <- data_2018[data_2018$Tree_Status == "A", ]
data_live <- data_2018[data_2018$status == "A", ]
data_live <- data_2018[data_2018$status == "A", ]
cru1901 <- read.csv(text=getURL("https://raw.githubusercontent.com/SCBI-ForestGEO/climate_sensitivity_cores/master/results/canopy_vs_subcanopy/1901_2009/tables/monthly_correlation/correlation_with_CRU_SCBI_1901_2016_climate_data.csv"), stringsAsFactors = FALSE)
library(ggplot2)
library(ggpubr)
#subset out caco, cato, and frni because they don't have pair of canopy and subcanopy
cru1901 <- cru1901[!(cru1901$Species %in% c("CACO_subcanopy", "CATO_subcanopy", "FRNI_subcanopy")), ]
cru1901_loop <- cru1901
#create separate identifier
cru1901_loop$position <- ifelse(grepl("subcanopy", cru1901$Species), "subcanopy", "canopy")
cru1901_loop$Species <- gsub("_[[:alpha:]]+$", "", cru1901$Species)
##########################################################################################
#2. box plots ####
cru1901_loop$variable <- as.character(cru1901_loop$variable)
clim <- unique(cru1901_loop$variable)
species <- unique(cru1901_loop$Species)
months <- c("curr.may", "curr.jun", "curr.jul", "curr.aug")
#creates a lattice graph showing box plot of variables grouped by species
ggplot(data = cru1901) +
aes(x = Species, y = coef, fill = variable) +
geom_boxplot() +
labs(title = "Correlation by species and variable",
y = "Correlation") +
facet_wrap( ~ Species, scales="free", nrow=4) +
theme_minimal()
cru1901_loop$Species <- as.factor(cru1901_loop$Species)
#this piece of code puts the graphs in date order
cru1901_loop <- within(cru1901_loop, month <- factor(month, levels=cru1901_loop$month[1:17]))
with(cru1901_loop, levels(month))
for (j in seq(along=clim)){
cru1901_sub <- cru1901_loop[cru1901_loop$variable %in% clim[[j]], ]
cru1901_sub <- group_by(cru1901_sub, month)
q <- ggplot(data = cru1901_sub) +
geom_boxplot(aes(x = position, y = coef, fill = position)) +
labs(title = paste0("Canopy vs subcanopy: ", clim[[j]]),
y = "Correlation") +
stat_compare_means(aes(x=position, y=coef), method="t.test", label.x.npc = 0, label.y.npc = 0.97) +
facet_wrap(~ month, scales="free", nrow=4) +
theme_minimal()
print(q)
}
q
q
install.packages("neonUtilities")
library(RCurl) #2
library(tidyr) #2
library(grid) #2
library(gridExtra) #2
library(data.table)
library(stringi)
library(ggplot2)
##2a. heights for all cored trees ####
trees_all <- read.csv("manuscript/tables_figures/trees_all.csv", stringsAsFactors = FALSE) #these graphs are meant to be for all cored trees, not just the ones being used in analysis
scbi.stem3 <- read.csv(text=getURL("https://raw.githubusercontent.com/SCBI-ForestGEO/SCBI-ForestGEO-Data/master/tree_main_census/data/census-csv-files/scbi.stem3.csv"), stringsAsFactors = FALSE)
scbi.stem3$dbh <- as.numeric(scbi.stem3$dbh)
current_ht <- trees_all[!duplicated(trees_all$tree), ]
current_ht$year <- 2018
current_ht <- current_ht[,c(1:4,17:19)]
current_ht$dbh_old.mm <- scbi.stem3$dbh[match(current_ht$tree, scbi.stem3$tag)]
current_ht <- trees_all[!duplicated(trees_all$tree), ]
current_ht$year <- 2018
View(current_ht)
current_ht$dbh_old.mm <- scbi.stem3$dbh[match(current_ht$tree, scbi.stem3$tag)]
current_ht$dbh_old.cm <- current_ht$dbh_old.mm/10
current_ht$year_dbh <- ifelse(!is.na(current_ht$dbh_old.cm), 2018, NA)
#get original dbh if they died before 2018 (only need 2013)
scbi.stem2 <- read.csv(text=getURL("https://raw.githubusercontent.com/SCBI-ForestGEO/SCBI-ForestGEO-Data/master/tree_main_census/data/census-csv-files/scbi.stem2.csv"), stringsAsFactors = FALSE)
##2a. heights for all cored trees ####
trees_all <- read.csv("manuscript/tables_figures/trees_all.csv", stringsAsFactors = FALSE) #these graphs are meant to be for all cored trees, not just the ones being used in analysis
View(trees_all)
current_ht <- trees_all[!duplicated(trees_all$tree), ]
current_ht$year <- 2018
current_ht$dbh_old.mm <- scbi.stem3$dbh[match(current_ht$tree, scbi.stem3$tag)]
current_ht$dbh_old.cm <- current_ht$dbh_old.mm/10
current_ht$year_dbh <- ifelse(!is.na(current_ht$dbh_old.cm), 2018, NA)
current_ht$dbh_old.mm <- ifelse(is.na(current_ht$dbh_old.mm),
scbi.stem2$dbh[match(current_ht$tree, scbi.stem2$tag)],
current_ht$dbh_old.mm)
current_ht$dbh_old.cm <- ifelse(is.na(current_ht$dbh_old.cm),
current_ht$dbh_old.mm/10,
current_ht$dbh_old.cm)
current_ht$year_dbh <- ifelse(is.na(current_ht$year_dbh), 2013, current_ht$year_dbh)
#get the log dbh and get heights
current_ht$dbh.ln.cm <- log(current_ht$dbh_old.cm)
#this csv is from the end of the #4 in canopy_heights.R
height_regr <- read.csv("manuscript/tables_figures/tableS2_height_regression.csv", stringsAsFactors = FALSE)
current_ht$height.ln.m <- NA
for(w in seq(along=height_regr$sp)){
sp_foc <- height_regr$sp[[w]]
ht_eq <- height_regr[height_regr$sp == sp_foc, ]
num <- gsub("\\*x", "", ht_eq$Equations)
num1 <- as.numeric(stri_extract_first_regex(num, "[[:digit:]].[[:digit:]]+"))
num2 <- as.numeric(stri_extract_last_regex(num, "[[:digit:]].[[:digit:]]+"))
if(sp_foc %in% current_ht[,"sp"]){
current_ht$height.ln.m <-
ifelse(current_ht$sp == sp_foc,
num1 + num2*current_ht$dbh.ln.cm,
current_ht$height.ln.m)
} else {
current_ht$height.ln.m <-
ifelse(current_ht$sp != sp_foc,
num1 + num2*current_ht$dbh.ln.cm,
current_ht$height.ln.m)
}
}
current_ht$height.m <- exp(current_ht$height.ln.m)
current_ht <- current_ht[order(current_ht$tree, current_ht$year), ]
#graphing height by crown position (for paper)
current_ht <- current_ht[!is.na(current_ht$position_all), ]
current_ht$position_all_abb <- substring(current_ht$position_all, 0, 1)
current_ht$position_all_abb <- toupper(current_ht$position_all_abb)
current_ht$position_all_abb <- factor(current_ht$position_all_abb, levels = c("D", "C", "I", "S"))
heights <-
ggplot(data = current_ht, aes(x = position_all_abb, y = height.m, group = position_all)) +
# aes(x=position_all, y=height.m, fill=year) +
geom_boxplot() +
xlab("Crown position") +
ylab("Height [m]") +
scale_y_continuous(breaks = scales::pretty_breaks(n = 6), limits=c(0,60)) +
theme_minimal() +
theme(axis.text = element_text(size=12)) +
theme(axis.title = element_text(size=14))
heights
##2b. get height data for all trees >10cm dbh in census ####
scbi.stem3 <- read.csv(text=getURL("https://raw.githubusercontent.com/SCBI-ForestGEO/SCBI-ForestGEO-Data/master/tree_main_census/data/census-csv-files/scbi.stem3.csv"), stringsAsFactors = FALSE)
library(RCurl)
library(tidyr)
library(grid)
library(gridExtra)
library(data.table)
library(stringi)
library(ggplot2)
##2b. get height data for all trees >10cm dbh in census ####
scbi.stem3 <- read.csv(text=getURL("https://raw.githubusercontent.com/SCBI-ForestGEO/SCBI-ForestGEO-Data/master/tree_main_census/data/census-csv-files/scbi.stem3.csv"), stringsAsFactors = FALSE)
#this csv is from the end of the #4 in canopy_heights.R
height_regr <- read.csv("manuscript/tables_figures/tableS2_height_regression.csv", stringsAsFactors = FALSE)
scbi.stem3$dbh <- as.numeric(scbi.stem3$dbh)
scbi.stem3$dbh <- ifelse(is.na(scbi.stem3$dbh), 0, scbi.stem3$dbh)
scbi18_ht <- scbi.stem3
scbi18_ht <- scbi18_ht[scbi18_ht$dbh>=100, ]
scbi18_ht <- scbi18_ht[,c(2:5,11,14:15)]
scbi18_ht$dbh_old.cm <- scbi18_ht$dbh/10
scbi18_ht$dbh.ln.cm <- log(scbi18_ht$dbh_old.cm)
scbi18_ht$height.ln.m <- NA
for(w in seq(along=height_regr$sp)){
sp_foc <- height_regr$sp[[w]]
ht_eq <- height_regr[height_regr$sp == sp_foc, ]
num <- gsub("\\*x", "", ht_eq$Equations)
num1 <- as.numeric(stri_extract_first_regex(num, "[[:digit:]].[[:digit:]]+"))
num2 <- as.numeric(stri_extract_last_regex(num, "[[:digit:]].[[:digit:]]+"))
if(sp_foc %in% scbi18_ht[,"sp"]){
scbi18_ht$height.ln.m <-
ifelse(scbi18_ht$sp == sp_foc,
num1 + num2*scbi18_ht$dbh.ln.cm,
scbi18_ht$height.ln.m)
} else {
scbi18_ht$height.ln.m <-
ifelse(scbi18_ht$sp != sp_foc,
num1 + num2*scbi18_ht$dbh.ln.cm,
scbi18_ht$height.ln.m)
}
}
scbi18_ht$height.m <- exp(scbi18_ht$height.ln.m) #used below in #3
##2c. Figure S3: combine heights to make plot with all years ####
trees_all$position_all_abb <- ifelse(trees_all$position_all == "dominant", "D",
ifelse(trees_all$position_all == "co-dominant", "C",
ifelse(trees_all$position_all == "suppressed", "S", "I")))
?levelplot
library(rasterVis)
?levelplot
library(ggpubr)
library(extrafont)
library(rasterVis)
loadfonts(device="win") #to get TNR
quantile(current_ht$height.m, c(.95), na.rm=TRUE) #95% quantile = 35.002m
quant <- data.frame(yintercept = 35.0022, Lines = "95th percentile")
##2a. Get NEON plots ####
source('scripts/vertical_height_neon.R', echo=TRUE)
NEON_list <- list(wind_plot, RH_plot, SAAT_plot) #,"biotemp_plot")
names(NEON_list) <- c("wind_plot", "RH_plot", "SAAT_plot") #,"biotemp_plot
##2b. Format the NEON plots ####
NEON_order <- c("(a)", "(b)", "(c)")
NEON_order_x <- c(0.5, 35, 7.5)
NEON_order_y <- c(57.5, 57.5, 57.5)
for (i in seq(along=1:3)){
NEON_list[[i]] <-
NEON_list[[i]] +
theme_bw(base_size = 16) +
# theme_bw(base_family = "serif") + #for TNR font
geom_hline(aes(yintercept = yintercept), linetype = "longdash", quant) +
annotate(geom="text", x=NEON_order_x[[i]], y=NEON_order_y[[i]],
label = NEON_order[[i]], fontface="bold", size=7)
if(i==3){
NEON_list[[i]] <-
NEON_list[[i]] +
theme(legend.title = element_blank(),
legend.box = "vertical",
legend.position = c(0.8, 0.85),
legend.background = element_rect(fill=alpha("white", 0.01)),
legend.text=element_text(size=12),
legend.key.size=unit(4,"mm"),
legend.spacing=unit(-0.5,"cm")
)
}
if(!i==3){
NEON_list[[i]] <-
NEON_list[[i]] +
theme(legend.position = "none")
}
if(!i==1){
NEON_list[[i]] <-
NEON_list[[i]] +
theme(axis.title.y = element_blank(),
axis.text.y=element_blank(),
axis.ticks.y=element_blank())
}
}
NEON <- ggarrange(NEON_list$wind_plot, NEON_list$RH_plot, NEON_list$SAAT_plot,  nrow=1, ncol=3, align="h")
##2c. Get the boxplots for 2018 heights (this is also prep for #3) ####
trees_all <- read.csv("manuscript/tables_figures/trees_all.csv", stringsAsFactors = FALSE) #these graphs are meant to be for all cored trees, not just the ones being used in analysis
scbi.stem3 <- read.csv(text=getURL("https://raw.githubusercontent.com/SCBI-ForestGEO/SCBI-ForestGEO-Data/master/tree_main_census/data/census-csv-files/scbi.stem3.csv"), stringsAsFactors = FALSE)
scbi.stem3$dbh <- as.numeric(scbi.stem3$dbh)
current_ht <- trees_all[!duplicated(trees_all$tree), ]
current_ht$year <- 2018
current_ht <- current_ht[,c(1:4,17:19)]
current_ht$dbh_old.mm <- scbi.stem3$dbh[match(current_ht$tree, scbi.stem3$tag)]
current_ht$dbh_old.cm <- current_ht$dbh_old.mm/10
current_ht$year_dbh <- ifelse(!is.na(current_ht$dbh_old.cm), 2018, NA)
#get original dbh if they died before 2018 (only need 2013)
scbi.stem2 <- read.csv(text=getURL("https://raw.githubusercontent.com/SCBI-ForestGEO/SCBI-ForestGEO-Data/master/tree_main_census/data/census-csv-files/scbi.stem2.csv"), stringsAsFactors = FALSE)
current_ht$dbh_old.mm <- ifelse(is.na(current_ht$dbh_old.mm),
scbi.stem2$dbh[match(current_ht$tree, scbi.stem2$tag)],
current_ht$dbh_old.mm)
current_ht$dbh_old.cm <- ifelse(is.na(current_ht$dbh_old.cm),
current_ht$dbh_old.mm/10,
current_ht$dbh_old.cm)
current_ht$year_dbh <- ifelse(is.na(current_ht$year_dbh), 2013, current_ht$year_dbh)
#get the log dbh and get heights
current_ht$dbh.ln.cm <- log(current_ht$dbh_old.cm)
#linear log-log regression
#the full equation is using all points for which we have data to create the equation, despite that for several species we don't have enough data to get a sp-specific equation
#this csv is created from #4 of canopy_heights.R
height_regr <- read.csv("manuscript/tables_figures/tableS2_height_regression.csv", stringsAsFactors = FALSE)
current_ht$height.ln.m <- NA
for(w in seq(along=height_regr$sp)){
sp_foc <- height_regr$sp[[w]]
ht_eq <- height_regr[height_regr$sp == sp_foc, ]
num <- gsub("\\*x", "", ht_eq$Equations)
num1 <- as.numeric(stri_extract_first_regex(num, "[[:digit:]].[[:digit:]]+"))
num2 <- as.numeric(stri_extract_last_regex(num, "[[:digit:]].[[:digit:]]+"))
if(sp_foc %in% current_ht[,"sp"]){
current_ht$height.ln.m <-
ifelse(current_ht$sp == sp_foc,
num1 + num2*current_ht$dbh.ln.cm,
current_ht$height.ln.m)
} else {
current_ht$height.ln.m <-
ifelse(current_ht$sp != sp_foc,
num1 + num2*current_ht$dbh.ln.cm,
current_ht$height.ln.m)
}
}
current_ht$height.m <- exp(current_ht$height.ln.m)
current_ht <- current_ht[order(current_ht$tree, current_ht$year), ]
#graphing height by crown position (for paper)
current_ht <- current_ht[!is.na(current_ht$position_all), ]
current_ht$position_all_abb <- substring(current_ht$position_all, 0, 1)
current_ht$position_all_abb <- toupper(current_ht$position_all_abb)
current_ht$position_all_abb <- factor(current_ht$position_all_abb, levels = c("D", "C", "I", "S"))
heights_box <-
ggplot(data = current_ht, aes(x = position_all_abb, y = height.m, group = position_all)) +
# aes(x=position_all, y=height.m, fill=year) +
geom_boxplot() +
xlab("Crown position") +
ylab("Height [m]") +
scale_y_continuous(breaks = scales::pretty_breaks(n = 6), limits=c(0,60)) +
theme_minimal() +
theme(axis.text = element_text(size=12)) +
theme(axis.title = element_text(size=14))
##2d. Format the height boxplot and add to NEON, export ####
heights_box <- #all graphs
heights_box +
theme_bw(base_size = 16) +
# theme_bw(base_family = "serif") + #for TNR font
geom_hline(aes(yintercept = yintercept), linetype = "longdash", quant) +
annotate(geom="text", x=0.8, y=57.5,
label = "d", fontface="bold", size=7)
library(neonUtilities)
library(lubridate)
library(dplyr)
library(tidyr)
library(stringr)
library(data.table)
library(grid)
library(gridExtra)
library(ggplot2)
dp <- data.frame("data" = c("SAAT", "wind", "biotemp", "RH", "SR"),
"id" = c("DP1.00002.001", "DP1.00001.001", "DP1.00005.001", "DP1.00098.001", "DP1.00014.001"),
"value" = c("tempSingleMean", "windSpeedMean", "bioTempMean", "RHMean", "difRadMean"),
"xlabs" = c("Mean Air Temperature [°C]", "Wind speed [m/s]", "Mean Infrared Biological Temperature [°C]", "RH [%]", "Mean shortwave downward radiation [W/m^2]"))
dp <- dp[c(2,4,1,3,5), ]
dp[] <- lapply(dp, as.character)
dp$value <- as.character(dp$value)
date <- data.frame("year" = c(rep(2018, 4), rep(2017, 4), rep(2016, 4), rep(2015, 4)),
"month" = c(rep(5:8, 4)))
years <- c("2016", "2017", "2018")
i=1
neon_data_all <- NULL
value <- dp$value[[i]]
for (j in seq(along=years)){
if (value != "RHMean" | j != 1){
neon_tower <- loadByProduct(dpID=dp$id[[i]],
site=c("SCBI"),
package="basic", avg=30,
check.size = FALSE,
#(use TRUE outside loop to see how big the dowloads are)
startdate=paste0(years[[j]], "-05"),
enddate=paste0(years[[j]], "-08"))
neon_data <- neon_tower[[1]]
neon_data_sub <- neon_data[colnames(neon_data) %in% c("verticalPosition", "startDateTime", value, "dirRadMean", "sunPres")]
#reformat dates
neon_data_sub$startDateTime <- as.character(neon_data_sub$startDateTime)
neon_data_sub$startDateTime <- gsub("T", " ", neon_data_sub$startDateTime)
neon_data_sub$startDateTime <- as.POSIXct(neon_data_sub$startDateTime, format = "%Y-%m-%d %H:%M:%OS")
#get rid of erroneous April datapoints
neon_data_sub <- neon_data_sub[!grepl("04-30", neon_data_sub$startDateTime), ]
## make consolidated graph over different months for each variable ####
neon_data_sub$day <- substr(neon_data_sub$startDateTime, 1, nchar(neon_data_sub$startDateTime)-0)
#want to preserve the dfs, so put them in a list
# neon_vars[[i]] <- neon_data_sub
# names(neon_vars)[i] <- paste0("neon_", dp$data[[i]])
neon_data_all <- rbind(neon_data_all, neon_data_sub)
} else if(value == "RHMean" & j == 1){ #no RH data for 2016, so have to recreate the df to make sure code runs
neon_data_sub[, 3] <- NULL
neon_data_sub[, value] <- NA
neon_data_sub <- neon_data_sub[, c(1:2,4,3)]
neon_data_sub$verticalPosition <- ifelse(neon_data_sub$verticalPosition == 20,
60,
neon_data_sub$verticalPosition)
neon_data_sub <- neon_data_sub[neon_data_sub$verticalPosition %in% c(0, 60), ]
neon_data_sub$day <- str_replace(neon_data_sub$day, "2018", "2016")
neon_data_all <- rbind(neon_data_all, neon_data_sub)
}
}
View(dp)
neon_tower <- loadByProduct(dpID=dp$id[[i]],
site=c("SCBI"),
package="basic", avg=30,
check.size = FALSE,
#(use TRUE outside loop to see how big the dowloads are)
startdate=paste0(years[[j]], "-05"),
enddate=paste0(years[[j]], "-08"))
?loadByProduct
dp$id[[i]]
remove.packages("neonUtilities")
install.packages("neonUtilities")
install.packages("neonUtilities")
######################################################
# Purpose: Create vertical profiles of climate variables for ForestGEO plot using NEON tower data
# Developed by: Ian McGregor - mcgregori@si.edu
# R version 3.5.3 - First created May 2019
######################################################
library(neonUtilities)
library(lubridate)
library(dplyr)
library(tidyr)
library(stringr)
library(data.table)
library(grid)
library(gridExtra)
library(ggplot2)
dp <- data.frame("data" = c("SAAT", "wind", "biotemp", "RH", "SR"),
"id" = c("DP1.00002.001", "DP1.00001.001", "DP1.00005.001", "DP1.00098.001", "DP1.00014.001"),
"value" = c("tempSingleMean", "windSpeedMean", "bioTempMean", "RHMean", "difRadMean"),
"xlabs" = c("Mean Air Temperature [°C]", "Wind speed [m/s]", "Mean Infrared Biological Temperature [°C]", "RH [%]", "Mean shortwave downward radiation [W/m^2]"))
dp <- dp[c(2,4,1,3,5), ]
dp[] <- lapply(dp, as.character)
dp$value <- as.character(dp$value)
date <- data.frame("year" = c(rep(2018, 4), rep(2017, 4), rep(2016, 4), rep(2015, 4)),
"month" = c(rep(5:8, 4)))
years <- c("2016", "2017", "2018")
neon_data_all <- NULL
value <- dp$value[[i]]
for (j in seq(along=years)){
if (value != "RHMean" | j != 1){
neon_tower <- loadByProduct(dpID=dp$id[[i]],
site=c("SCBI"),
package="basic", avg=30,
check.size = FALSE,
#(use TRUE outside loop to see how big the dowloads are)
startdate=paste0(years[[j]], "-05"),
enddate=paste0(years[[j]], "-08"))
neon_data <- neon_tower[[1]]
neon_data_sub <- neon_data[colnames(neon_data) %in% c("verticalPosition", "startDateTime", value, "dirRadMean", "sunPres")]
#reformat dates
neon_data_sub$startDateTime <- as.character(neon_data_sub$startDateTime)
neon_data_sub$startDateTime <- gsub("T", " ", neon_data_sub$startDateTime)
neon_data_sub$startDateTime <- as.POSIXct(neon_data_sub$startDateTime, format = "%Y-%m-%d %H:%M:%OS")
#get rid of erroneous April datapoints
neon_data_sub <- neon_data_sub[!grepl("04-30", neon_data_sub$startDateTime), ]
## make consolidated graph over different months for each variable ####
neon_data_sub$day <- substr(neon_data_sub$startDateTime, 1, nchar(neon_data_sub$startDateTime)-0)
#want to preserve the dfs, so put them in a list
# neon_vars[[i]] <- neon_data_sub
# names(neon_vars)[i] <- paste0("neon_", dp$data[[i]])
neon_data_all <- rbind(neon_data_all, neon_data_sub)
} else if(value == "RHMean" & j == 1){ #no RH data for 2016, so have to recreate the df to make sure code runs
neon_data_sub[, 3] <- NULL
neon_data_sub[, value] <- NA
neon_data_sub <- neon_data_sub[, c(1:2,4,3)]
neon_data_sub$verticalPosition <- ifelse(neon_data_sub$verticalPosition == 20,
60,
neon_data_sub$verticalPosition)
neon_data_sub <- neon_data_sub[neon_data_sub$verticalPosition %in% c(0, 60), ]
neon_data_sub$day <- str_replace(neon_data_sub$day, "2018", "2016")
neon_data_all <- rbind(neon_data_all, neon_data_sub)
}
}
j=3
neon_tower <- loadByProduct(dpID=dp$id[[i]],
site=c("SCBI"),
package="basic", avg=30,
check.size = FALSE,
#(use TRUE outside loop to see how big the dowloads are)
startdate=paste0(years[[j]], "-05"),
enddate=paste0(years[[j]], "-08"))
