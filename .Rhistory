unlist(sapply(seq_len(length(effects)), function(i) {
apply( combn(effects,i), 2, function(x) paste(x, collapse = "+"))
}))
# pair response with effect and sub out combinations that don't include random effects
#in general, if two variables are >70% correlated, you can toss one of them without significantly affecting the results
var_comb <- expand.grid(response, effects_comb)
var_comb <- var_comb[grepl("1", var_comb$Var2), ] #only keep in fixed/random combos
# formulas for all combinations. $Var1 is the response, and $Var2 is the effect
# for good stats, you should have no more total parameters than 1/10th the number of observations in your dataset
formula_vec <- sprintf("%s ~ %s", var_comb$Var1, var_comb$Var2)
lmm_all <- lapply(formula_vec, function(x){
fit1 <- lmer(x, data = model_df[[j]], REML=FALSE,
control = lmerControl(optimizer ="Nelder_Mead"))
return(fit1)
})
names(lmm_all) <- formula_vec
var_aic <- aictab(lmm_all, second.ord=TRUE, sort=TRUE) #rank based on AICc
var_aic$Modnames <- as.character(var_aic$Modnames)
best_mod_traits$best_model[[i]] <- var_aic$Modnames[[1]]
#get all mods <2 dAIC
var_aic <- var_aic[var_aic$Delta_AICc <= 2, ]
top <- var_aic[,c(1,4)]
top$Delta_AICc <- round(top$Delta_AICc, 2)
top$scenario <- mods[[i]]
for (z in seq(along = lmm_all)){
if (names(lmm_all[z]) == var_aic$Modnames[[1]]){
#run the best model alone with REML=TRUE
fit1 <- lmer(formula_vec[[z]], data = model_df[[j]], REML=TRUE,
control = lmerControl(optimizer ="Nelder_Mead"))
#get coefficients and put in table
coeff <- data.frame(coef(summary(fit1))[ , "Estimate"]) ##2
coeff[,2] <- rownames(coeff)
coeff[,1] <- round(coeff[,1], 3)
colnames(coeff) <- c(names(model_df[j]), "model_var")
#put r2 in table
r <- rsquared(fit1) #gives R^2 values for models. "Marginal" is the R^2 for just the fixed effects, "Conditional" is the R^2 for everything.
r <- data.frame(r[,6])
colnames(r) <- names(model_df[j])
r$model_var <- "r^2"
r[,1] <- round(r[,1], 2)
coeff <- rbind(r,coeff)
coeff_list[[paste0("coeff_", names(model_df[j]))]] <- coeff
}
if (names(lmm_all[z]) %in% var_aic$Modnames){
#run the best model alone with REML=TRUE
fit1 <- lmer(formula_vec[[z]], data = model_df[[j]], REML=FALSE,
control = lmerControl(optimizer ="Nelder_Mead"))
#get coefficients and put in table
coeff <- data.frame(coef(summary(fit1))[ , "Estimate"]) ##2
coeff[,2] <- rownames(coeff)
coeff[,1] <- round(coeff[,1], 3)
coeff$comb <- paste0(coeff[,2], " (", coeff[,1], ")")
for (g in seq(along=1:3)){
if(rownames(top)[[g]] == z){
top$coef[[g]] <- paste(unlist(coeff$comb), collapse=", ")
}
}
}
}
i=2
response <- "resist.value"
effects <- best_mod_full_year
j=2
#create all combinations of random / fixed effects
effects_comb <-
unlist( sapply( seq_len(length(effects)),
function(i) {
apply( combn(effects,i), 2, function(x) paste(x, collapse = "+"))
}))
var_comb <- expand.grid(response, effects_comb)
var_comb <- var_comb[grepl("1", var_comb$Var2), ] #only keep in fixed/random combos
formula_vec <- sprintf("%s ~ %s", var_comb$Var1, var_comb$Var2)
lmm_all <- lapply(formula_vec, function(x){
fit1 <- lmer(x, data = model_df[[j]], REML=FALSE,
control = lmerControl(optimizer ="Nelder_Mead"))
return(fit1)
})
names(lmm_all) <- formula_vec
var_aic <- aictab(lmm_all, second.ord=TRUE, sort=TRUE) #rank based on AICc
var_aic$Modnames <- as.character(var_aic$Modnames)
best_mod_traits$best_model[[i]] <- var_aic$Modnames[[1]]
#get all mods <2 dAIC
var_aic <- var_aic[var_aic$Delta_AICc <= 2, ]
top <- var_aic[,c(1,4)]
top$Delta_AICc <- round(top$Delta_AICc, 2)
top$scenario <- mods[[i]]
View(var_aic)
for (z in seq(along = lmm_all)){
if (names(lmm_all[z]) == var_aic$Modnames[[1]]){
#run the best model alone with REML=TRUE
fit1 <- lmer(formula_vec[[z]], data = model_df[[j]], REML=TRUE,
control = lmerControl(optimizer ="Nelder_Mead"))
#get coefficients and put in table
coeff <- data.frame(coef(summary(fit1))[ , "Estimate"]) ##2
coeff[,2] <- rownames(coeff)
coeff[,1] <- round(coeff[,1], 3)
colnames(coeff) <- c(names(model_df[j]), "model_var")
#put r2 in table
r <- rsquared(fit1) #gives R^2 values for models. "Marginal" is the R^2 for just the fixed effects, "Conditional" is the R^2 for everything.
r <- data.frame(r[,6])
colnames(r) <- names(model_df[j])
r$model_var <- "r^2"
r[,1] <- round(r[,1], 2)
coeff <- rbind(r,coeff)
coeff_list[[paste0("coeff_", names(model_df[j]))]] <- coeff
}
}
for (z in seq(along = lmm_all)){
if (names(lmm_all[z]) == var_aic$Modnames[[1]]){
#run the best model alone with REML=TRUE
fit1 <- lmer(formula_vec[[z]], data = model_df[[j]], REML=TRUE,
control = lmerControl(optimizer ="Nelder_Mead"))
#get coefficients and put in table
coeff <- data.frame(coef(summary(fit1))[ , "Estimate"]) ##2
coeff[,2] <- rownames(coeff)
coeff[,1] <- round(coeff[,1], 3)
colnames(coeff) <- c(names(model_df[j]), "model_var")
#put r2 in table
r <- rsquared(fit1) #gives R^2 values for models. "Marginal" is the R^2 for just the fixed effects, "Conditional" is the R^2 for everything.
r <- data.frame(r[,6])
colnames(r) <- names(model_df[j])
r$model_var <- "r^2"
r[,1] <- round(r[,1], 2)
coeff <- rbind(r,coeff)
coeff_list[[paste0("coeff_", names(model_df[j]))]] <- coeff
}
if (names(lmm_all[z]) %in% var_aic$Modnames){
#run the best model alone with REML=TRUE
fit1 <- lmer(formula_vec[[z]], data = model_df[[j]], REML=FALSE,
control = lmerControl(optimizer ="Nelder_Mead"))
#get coefficients and put in table
coeff <- data.frame(coef(summary(fit1))[ , "Estimate"]) ##2
coeff[,2] <- rownames(coeff)
coeff[,1] <- round(coeff[,1], 3)
coeff$comb <- paste0(coeff[,2], " (", coeff[,1], ")")
for (g in seq(along=1:3)){
if(rownames(top)[[g]] == z){
top$coef[[g]] <- paste(unlist(coeff$comb), collapse=", ")
}
}
}
}
#this loop determines the best full model for each scenario, using the traits from cand_full in #6a, and populates the table created above
mods <- names(model_df)
top_models <- NULL
coeff_list <- list()
##6b. determine the best full model ####
best_mod_traits <- data.frame("best_model" = NA,
"scenario" = c("all droughts", "1964-1966", "1977", "1999")
)
best_mod_full <- c(unique(cand_full$variable), "(1|sp/tree)")
best_mod_full_year <- gsub("/tree", "", best_mod_full)
best_mod_full_year <- best_mod_full_year[!best_mod_full_year %in% c("year")]
#this loop determines the best full model for each scenario, using the traits from cand_full in #6a, and populates the table created above
mods <- names(model_df)
top_models <- NULL
coeff_list <- list()
for (i in seq(along=c(1:4))){
for (j in seq(along=model_df)){
#ALL YEARS
if(j == 1 & i == 1){
response <- "resist.value"
effects <- best_mod_full
#create all combinations of random / fixed effects
effects_comb <-
unlist(sapply(seq_len(length(effects)), function(i) {
apply( combn(effects,i), 2, function(x) paste(x, collapse = "+"))
}))
# pair response with effect and sub out combinations that don't include random effects
#in general, if two variables are >70% correlated, you can toss one of them without significantly affecting the results
var_comb <- expand.grid(response, effects_comb)
var_comb <- var_comb[grepl("1", var_comb$Var2), ] #only keep in fixed/random combos
# formulas for all combinations. $Var1 is the response, and $Var2 is the effect
# for good stats, you should have no more total parameters than 1/10th the number of observations in your dataset
formula_vec <- sprintf("%s ~ %s", var_comb$Var1, var_comb$Var2)
lmm_all <- lapply(formula_vec, function(x){
fit1 <- lmer(x, data = model_df[[j]], REML=FALSE,
control = lmerControl(optimizer ="Nelder_Mead"))
return(fit1)
})
names(lmm_all) <- formula_vec
var_aic <- aictab(lmm_all, second.ord=TRUE, sort=TRUE) #rank based on AICc
var_aic$Modnames <- as.character(var_aic$Modnames)
best_mod_traits$best_model[[i]] <- var_aic$Modnames[[1]]
#get all mods <2 dAIC
var_aic <- var_aic[var_aic$Delta_AICc <= 2, ]
top <- var_aic[,c(1,4)]
top$Delta_AICc <- round(top$Delta_AICc, 2)
top$scenario <- mods[[i]]
for (z in seq(along = lmm_all)){
if (names(lmm_all[z]) == var_aic$Modnames[[1]]){
#run the best model alone with REML=TRUE
fit1 <- lmer(formula_vec[[z]], data = model_df[[j]], REML=TRUE,
control = lmerControl(optimizer ="Nelder_Mead"))
#get coefficients and put in table
coeff <- data.frame(coef(summary(fit1))[ , "Estimate"]) ##2
coeff[,2] <- rownames(coeff)
coeff[,1] <- round(coeff[,1], 3)
colnames(coeff) <- c(names(model_df[j]), "model_var")
#put r2 in table
r <- rsquared(fit1) #gives R^2 values for models. "Marginal" is the R^2 for just the fixed effects, "Conditional" is the R^2 for everything.
r <- data.frame(r[,6])
colnames(r) <- names(model_df[j])
r$model_var <- "r^2"
r[,1] <- round(r[,1], 2)
coeff <- rbind(r,coeff)
coeff_list[[paste0("coeff_", names(model_df[j]))]] <- coeff
}
if (names(lmm_all[z]) %in% var_aic$Modnames){
#run the best model alone with REML=TRUE
fit1 <- lmer(formula_vec[[z]], data = model_df[[j]], REML=FALSE,
control = lmerControl(optimizer ="Nelder_Mead"))
#get coefficients and put in table
coeff <- data.frame(coef(summary(fit1))[ , "Estimate"]) ##2
coeff[,2] <- rownames(coeff)
coeff[,1] <- round(coeff[,1], 3)
coeff$comb <- paste0(coeff[,2], " (", coeff[,1], ")")
for (g in seq(along=1:3)){
if(rownames(top)[[g]] == z){
top$coef[[g]] <- paste(unlist(coeff$comb), collapse=", ")
}
}
}
}
#INDIVIDUAL YEARS
} else if (j == i){
response <- "resist.value"
effects <- best_mod_full_year
#create all combinations of random / fixed effects
effects_comb <-
unlist( sapply( seq_len(length(effects)),
function(i) {
apply( combn(effects,i), 2, function(x) paste(x, collapse = "+"))
}))
var_comb <- expand.grid(response, effects_comb)
var_comb <- var_comb[grepl("1", var_comb$Var2), ] #only keep in fixed/random combos
formula_vec <- sprintf("%s ~ %s", var_comb$Var1, var_comb$Var2)
lmm_all <- lapply(formula_vec, function(x){
fit1 <- lmer(x, data = model_df[[j]], REML=FALSE,
control = lmerControl(optimizer ="Nelder_Mead"))
return(fit1)
})
names(lmm_all) <- formula_vec
var_aic <- aictab(lmm_all, second.ord=TRUE, sort=TRUE) #rank based on AICc
var_aic$Modnames <- as.character(var_aic$Modnames)
best_mod_traits$best_model[[i]] <- var_aic$Modnames[[1]]
#get all mods <2 dAIC
var_aic <- var_aic[var_aic$Delta_AICc <= 2, ]
top <- var_aic[,c(1,4)]
top$Delta_AICc <- round(top$Delta_AICc, 2)
top$scenario <- mods[[i]]
for (z in seq(along = lmm_all)){
if (names(lmm_all[z]) == var_aic$Modnames[[1]]){
#run the best model alone with REML=TRUE
fit1 <- lmer(formula_vec[[z]], data = model_df[[j]], REML=TRUE,
control = lmerControl(optimizer ="Nelder_Mead"))
#get coefficients and put in table
coeff <- data.frame(coef(summary(fit1))[ , "Estimate"]) ##2
coeff[,2] <- rownames(coeff)
coeff[,1] <- round(coeff[,1], 3)
colnames(coeff) <- c(names(model_df[j]), "model_var")
#put r2 in table
r <- rsquared(fit1) #gives R^2 values for models. "Marginal" is the R^2 for just the fixed effects, "Conditional" is the R^2 for everything.
r <- data.frame(r[,6])
colnames(r) <- names(model_df[j])
r$model_var <- "r^2"
r[,1] <- round(r[,1], 2)
coeff <- rbind(r,coeff)
coeff_list[[paste0("coeff_", names(model_df[j]))]] <- coeff
}
if (names(lmm_all[z]) %in% var_aic$Modnames){
#run the best model alone with REML=TRUE
fit1 <- lmer(formula_vec[[z]], data = model_df[[j]], REML=FALSE,
control = lmerControl(optimizer ="Nelder_Mead"))
#get coefficients and put in table
coeff <- data.frame(coef(summary(fit1))[ , "Estimate"]) ##2
coeff[,2] <- rownames(coeff)
coeff[,1] <- round(coeff[,1], 3)
coeff$comb <- paste0(coeff[,2], " (", coeff[,1], ")")
for (g in seq(along=1:3)){
if(rownames(top)[[g]] == z){
top$coef[[g]] <- paste(unlist(coeff$comb), collapse=", ")
}
}
}
}
}
}
top_models <- rbind(top_models, top)
}
View(top_models)
i=3
j=3
response <- "resist.value"
effects <- best_mod_full_year
#create all combinations of random / fixed effects
effects_comb <-
unlist( sapply( seq_len(length(effects)),
function(i) {
apply( combn(effects,i), 2, function(x) paste(x, collapse = "+"))
}))
var_comb <- expand.grid(response, effects_comb)
var_comb <- var_comb[grepl("1", var_comb$Var2), ] #only keep in fixed/random combos
formula_vec <- sprintf("%s ~ %s", var_comb$Var1, var_comb$Var2)
lmm_all <- lapply(formula_vec, function(x){
fit1 <- lmer(x, data = model_df[[j]], REML=FALSE,
control = lmerControl(optimizer ="Nelder_Mead"))
return(fit1)
})
names(lmm_all) <- formula_vec
var_aic <- aictab(lmm_all, second.ord=TRUE, sort=TRUE) #rank based on AICc
View(var_aic)
i=4
j=4
response <- "resist.value"
effects <- best_mod_full_year
#create all combinations of random / fixed effects
effects_comb <-
unlist( sapply( seq_len(length(effects)),
function(i) {
apply( combn(effects,i), 2, function(x) paste(x, collapse = "+"))
}))
var_comb <- expand.grid(response, effects_comb)
var_comb <- var_comb[grepl("1", var_comb$Var2), ] #only keep in fixed/random combos
formula_vec <- sprintf("%s ~ %s", var_comb$Var1, var_comb$Var2)
lmm_all <- lapply(formula_vec, function(x){
fit1 <- lmer(x, data = model_df[[j]], REML=FALSE,
control = lmerControl(optimizer ="Nelder_Mead"))
return(fit1)
})
names(lmm_all) <- formula_vec
var_aic <- aictab(lmm_all, second.ord=TRUE, sort=TRUE) #rank based on AICc
View(var_aic)
var_aic$Modnames <- as.character(var_aic$Modnames)
#get all mods <2 dAIC
var_aic <- var_aic[var_aic$Delta_AICc <= 2, ]
View(var_aic)
top <- var_aic[,c(1,4)]
top$Delta_AICc <- round(top$Delta_AICc, 2)
top$scenario <- mods[[i]]
z=47
names(lmm_all[z]) %in% var_aic$Modnames
#run the best model alone with REML=TRUE
fit1 <- lmer(formula_vec[[z]], data = model_df[[j]], REML=FALSE,
control = lmerControl(optimizer ="Nelder_Mead"))
#get coefficients and put in table
coeff <- data.frame(coef(summary(fit1))[ , "Estimate"]) ##2
coeff[,2] <- rownames(coeff)
coeff[,1] <- round(coeff[,1], 3)
coeff$comb <- paste0(coeff[,2], " (", coeff[,1], ")")
for (g in seq(along=1:nrow(top))){
if(rownames(top)[[g]] == z){
top$coef[[g]] <- paste(unlist(coeff$comb), collapse=", ")
}
}
g in seq(along=1:nrow(top))
rownames(top)[[g]] == z
top$coef[[g]]
top$coef <- NA
for (g in seq(along=1:nrow(top))){
if(rownames(top)[[g]] == z){
top$coef[[g]] <- paste(unlist(coeff$comb), collapse=", ")
}
}
##6b. determine the best full model ####
best_mod_traits <- data.frame("best_model" = NA,
"scenario" = c("all droughts", "1964-1966", "1977", "1999")
)
best_mod_full <- c(unique(cand_full$variable), "(1|sp/tree)")
best_mod_full_year <- gsub("/tree", "", best_mod_full)
best_mod_full_year <- best_mod_full_year[!best_mod_full_year %in% c("year")]
#this loop determines the best full model for each scenario, using the traits from cand_full in #6a, and populates the table created above
mods <- names(model_df)
top_models <- NULL
coeff_list <- list()
for (i in seq(along=c(1:4))){
for (j in seq(along=model_df)){
#ALL YEARS
if(j == 1 & i == 1){
response <- "resist.value"
effects <- best_mod_full
#create all combinations of random / fixed effects
effects_comb <-
unlist(sapply(seq_len(length(effects)), function(i) {
apply( combn(effects,i), 2, function(x) paste(x, collapse = "+"))
}))
# pair response with effect and sub out combinations that don't include random effects
#in general, if two variables are >70% correlated, you can toss one of them without significantly affecting the results
var_comb <- expand.grid(response, effects_comb)
var_comb <- var_comb[grepl("1", var_comb$Var2), ] #only keep in fixed/random combos
# formulas for all combinations. $Var1 is the response, and $Var2 is the effect
# for good stats, you should have no more total parameters than 1/10th the number of observations in your dataset
formula_vec <- sprintf("%s ~ %s", var_comb$Var1, var_comb$Var2)
lmm_all <- lapply(formula_vec, function(x){
fit1 <- lmer(x, data = model_df[[j]], REML=FALSE,
control = lmerControl(optimizer ="Nelder_Mead"))
return(fit1)
})
names(lmm_all) <- formula_vec
var_aic <- aictab(lmm_all, second.ord=TRUE, sort=TRUE) #rank based on AICc
var_aic$Modnames <- as.character(var_aic$Modnames)
best_mod_traits$best_model[[i]] <- var_aic$Modnames[[1]]
#get all mods <2 dAIC
var_aic <- var_aic[var_aic$Delta_AICc <= 2, ]
top <- var_aic[,c(1,4)]
top$Delta_AICc <- round(top$Delta_AICc, 2)
top$scenario <- mods[[i]]
top$coef <- NA
for (z in seq(along = lmm_all)){
if (names(lmm_all[z]) == var_aic$Modnames[[1]]){
#run the best model alone with REML=TRUE
fit1 <- lmer(formula_vec[[z]], data = model_df[[j]], REML=TRUE,
control = lmerControl(optimizer ="Nelder_Mead"))
#get coefficients and put in table
coeff <- data.frame(coef(summary(fit1))[ , "Estimate"]) ##2
coeff[,2] <- rownames(coeff)
coeff[,1] <- round(coeff[,1], 3)
colnames(coeff) <- c(names(model_df[j]), "model_var")
#put r2 in table
r <- rsquared(fit1) #gives R^2 values for models. "Marginal" is the R^2 for just the fixed effects, "Conditional" is the R^2 for everything.
r <- data.frame(r[,6])
colnames(r) <- names(model_df[j])
r$model_var <- "r^2"
r[,1] <- round(r[,1], 2)
coeff <- rbind(r,coeff)
coeff_list[[paste0("coeff_", names(model_df[j]))]] <- coeff
}
if (names(lmm_all[z]) %in% var_aic$Modnames){
#run the best model alone with REML=TRUE
fit1 <- lmer(formula_vec[[z]], data = model_df[[j]], REML=FALSE,
control = lmerControl(optimizer ="Nelder_Mead"))
#get coefficients and put in table
coeff <- data.frame(coef(summary(fit1))[ , "Estimate"]) ##2
coeff[,2] <- rownames(coeff)
coeff[,1] <- round(coeff[,1], 3)
coeff$comb <- paste0(coeff[,2], " (", coeff[,1], ")")
for (g in seq(along=1:nrow(top))){
if(rownames(top)[[g]] == z){
top$coef[[g]] <- paste(unlist(coeff$comb), collapse=", ")
}
}
}
}
#INDIVIDUAL YEARS
} else if (j == i){
response <- "resist.value"
effects <- best_mod_full_year
#create all combinations of random / fixed effects
effects_comb <-
unlist( sapply( seq_len(length(effects)),
function(i) {
apply( combn(effects,i), 2, function(x) paste(x, collapse = "+"))
}))
var_comb <- expand.grid(response, effects_comb)
var_comb <- var_comb[grepl("1", var_comb$Var2), ] #only keep in fixed/random combos
formula_vec <- sprintf("%s ~ %s", var_comb$Var1, var_comb$Var2)
lmm_all <- lapply(formula_vec, function(x){
fit1 <- lmer(x, data = model_df[[j]], REML=FALSE,
control = lmerControl(optimizer ="Nelder_Mead"))
return(fit1)
})
names(lmm_all) <- formula_vec
var_aic <- aictab(lmm_all, second.ord=TRUE, sort=TRUE) #rank based on AICc
var_aic$Modnames <- as.character(var_aic$Modnames)
best_mod_traits$best_model[[i]] <- var_aic$Modnames[[1]]
#get all mods <2 dAIC
var_aic <- var_aic[var_aic$Delta_AICc <= 2, ]
top <- var_aic[,c(1,4)]
top$Delta_AICc <- round(top$Delta_AICc, 2)
top$scenario <- mods[[i]]
top$coef <- NA
for (z in seq(along = lmm_all)){
if (names(lmm_all[z]) == var_aic$Modnames[[1]]){
#run the best model alone with REML=TRUE
fit1 <- lmer(formula_vec[[z]], data = model_df[[j]], REML=TRUE,
control = lmerControl(optimizer ="Nelder_Mead"))
#get coefficients and put in table
coeff <- data.frame(coef(summary(fit1))[ , "Estimate"]) ##2
coeff[,2] <- rownames(coeff)
coeff[,1] <- round(coeff[,1], 3)
colnames(coeff) <- c(names(model_df[j]), "model_var")
#put r2 in table
r <- rsquared(fit1) #gives R^2 values for models. "Marginal" is the R^2 for just the fixed effects, "Conditional" is the R^2 for everything.
r <- data.frame(r[,6])
colnames(r) <- names(model_df[j])
r$model_var <- "r^2"
r[,1] <- round(r[,1], 2)
coeff <- rbind(r,coeff)
coeff_list[[paste0("coeff_", names(model_df[j]))]] <- coeff
}
if (names(lmm_all[z]) %in% var_aic$Modnames){
#run the best model alone with REML=TRUE
fit1 <- lmer(formula_vec[[z]], data = model_df[[j]], REML=FALSE,
control = lmerControl(optimizer ="Nelder_Mead"))
#get coefficients and put in table
coeff <- data.frame(coef(summary(fit1))[ , "Estimate"]) ##2
coeff[,2] <- rownames(coeff)
coeff[,1] <- round(coeff[,1], 3)
coeff$comb <- paste0(coeff[,2], " (", coeff[,1], ")")
for (g in seq(along=1:nrow(top))){
if(rownames(top)[[g]] == z){
top$coef[[g]] <- paste(unlist(coeff$comb), collapse=", ")
}
}
}
}
}
}
top_models <- rbind(top_models, top)
}
View(top_models)
write.csv(top_models, "manuscript/tables_figures/top_models_dAIC.csv", row.names=FALSE)
