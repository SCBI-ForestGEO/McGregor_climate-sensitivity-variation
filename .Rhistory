#ALL YEARS
if(j == 1 & i == 1){
response <- "resist.value"
effects <- best_mod_full
#create all combinations of random / fixed effects
effects_comb <-
unlist(sapply(seq_len(length(effects)), function(i) {
apply( combn(effects,i), 2, function(x) paste(x, collapse = "+"))
}))
#pair response with effect and sub out combinations that don't include random effects
#in general, if two variables are >70% correlated, you can toss one of them without significantly affecting the results
var_comb <- expand.grid(response, effects_comb)
var_comb <- var_comb[grepl("1", var_comb$Var2), ] #only keep in fixed/random combos
var_comb$Var2 <- as.character(var_comb$Var2)
#can't have height and TWI separately when the interaction is in
for (q in seq(along=var_comb$Var2)){
cell <- var_comb$Var2[[q]]
if(grepl("\\*", cell)){
if(grepl("\\+TWI.ln", cell)){
var_comb$Var2[[q]] <- gsub("\\+TWI.ln", "", var_comb$Var2[[q]])
}
if(grepl("\\+height.ln.m", cell)){
var_comb$Var2[[q]] <- gsub("\\+height.ln.m\\+", "\\+", var_comb$Var2[[q]])
}
}
}
var_comb <- unique(var_comb[,1:2])
# formulas for all combinations. $Var1 is the response, and $Var2 is the effect
# for good stats, you should have no more total parameters than 1/10th the number of observations in your dataset
formula_vec <- sprintf("%s ~ %s", var_comb$Var1, var_comb$Var2)
lmm_all <- lapply(formula_vec, function(x){
fit1 <- lmer(x, data = model_df[[j]], REML=FALSE,
control = lmerControl(optimizer ="Nelder_Mead"))
return(fit1)
})
names(lmm_all) <- formula_vec
var_aic <- aictab(lmm_all, second.ord=TRUE, sort=TRUE) #rank based on AICc
var_aic$Modnames <- as.character(var_aic$Modnames)
best_mod_traits$best_model[[i]] <- var_aic$Modnames[[1]]
#get all mods <2 dAIC
var_aic <- var_aic[var_aic$Delta_AICc <= 2, ]
var_aic$mod_no <- rownames(var_aic)
top <- var_aic[,c(1,4)]
top$Delta_AICc <- round(top$Delta_AICc, 2)
top$scenario <- mods[[i]]
top$coef <- NA
for (z in seq(along = lmm_all)){
for (w in seq(along=1:nrow(var_aic))){
if (names(lmm_all[z]) == var_aic$Modnames[[w]]){
#run the best model alone with REML=TRUE
fit1 <- lmer(formula_vec[[z]], data = model_df[[j]], REML=TRUE,
control = lmerControl(optimizer ="Nelder_Mead"))
#get coefficients and put in table
coeff <- data.frame(coef(summary(fit1))[ , "Estimate"]) ##2
coeff[,2] <- rownames(coeff)
coeff[,1] <- round(coeff[,1], 3)
colnames(coeff) <- c(paste0("[All years] ","Model #", w), "model_var")
#put r2 in table
delta <- data.frame(var_aic$Delta_AICc[[w]])
colnames(delta) <- paste0("[All years] ","Model #", w)
delta$model_var <- "dAICc"
r <- rsquared(fit1) #gives R^2 values for models. "Marginal" is the R^2 for just the fixed effects, "Conditional" is the R^2 for everything.
r <- data.frame(r[,6])
colnames(r) <- paste0("[All years] ","Model #", w)
r$model_var <- "r^2"
r[,1] <- round(r[,1], 2)
coeff <- rbind(delta, r, coeff)
coeff_list[[paste0("coeff_", names(model_df[j]), "_", w)]] <- coeff
}
}
}
#INDIVIDUAL YEARS
} else if (j == i){
response <- "resist.value"
effects <- best_mod_full_year
#create all combinations of random / fixed effects
effects_comb <-
unlist( sapply( seq_len(length(effects)),
function(i) {
apply( combn(effects,i), 2, function(x) paste(x, collapse = "+"))
}))
var_comb <- expand.grid(response, effects_comb)
var_comb <- var_comb[grepl("1", var_comb$Var2), ] #only keep in fixed/random combos
var_comb$Var2 <- as.character(var_comb$Var2)
#can't have height and TWI separately when the interaction is in
for (q in seq(along=var_comb$Var2)){
cell <- var_comb$Var2[[q]]
if(grepl("\\*", cell)){
if(grepl("\\+TWI.ln", cell)){
var_comb$Var2[[q]] <- gsub("\\+TWI.ln", "", var_comb$Var2[[q]])
}
if(grepl("\\+height.ln.m", cell)){
var_comb$Var2[[q]] <- gsub("\\+height.ln.m\\+", "\\+", var_comb$Var2[[q]])
}
}
}
var_comb <- unique(var_comb[,1:2])
formula_vec <- sprintf("%s ~ %s", var_comb$Var1, var_comb$Var2)
lmm_all <- lapply(formula_vec, function(x){
fit1 <- lmer(x, data = model_df[[j]], REML=FALSE,
control = lmerControl(optimizer ="Nelder_Mead"))
return(fit1)
})
names(lmm_all) <- formula_vec
var_aic <- aictab(lmm_all, second.ord=TRUE, sort=TRUE) #rank based on AICc
var_aic$Modnames <- as.character(var_aic$Modnames)
best_mod_traits$best_model[[i]] <- var_aic$Modnames[[1]]
#get all mods <2 dAIC
var_aic <- var_aic[var_aic$Delta_AICc <= 2, ]
top <- var_aic[,c(1,4)]
top$Delta_AICc <- round(top$Delta_AICc, 2)
top$scenario <- mods[[i]]
top$coef <- NA
for (z in seq(along = lmm_all)){
for (w in seq(along=1:nrow(var_aic))){
if (names(lmm_all[z]) == var_aic$Modnames[[w]]){
#run the best model alone with REML=TRUE
fit1 <- lmer(formula_vec[[z]], data = model_df[[j]], REML=TRUE,
control = lmerControl(optimizer ="Nelder_Mead"))
#get coefficients and put in table
coeff <- data.frame(coef(summary(fit1))[ , "Estimate"]) ##2
coeff[,2] <- rownames(coeff)
coeff[,1] <- round(coeff[,1], 3)
colnames(coeff) <- c(paste0("[", names(model_df[j]), "] ","Model #", w), "model_var")
#put r2 in table
delta <- data.frame(var_aic$Delta_AICc[[w]])
colnames(delta) <- paste0("[", names(model_df[j]), "] ","Model #", w)
delta$model_var <- "dAICc"
r <- rsquared(fit1) #gives R^2 values for models. "Marginal" is the R^2 for just the fixed effects, "Conditional" is the R^2 for everything.
r <- data.frame(r[,6])
colnames(r) <- paste0("[", names(model_df[j]), "] ","Model #", w)
r$model_var <- "r^2"
r[,1] <- round(r[,1], 2)
coeff <- rbind(delta, r, coeff)
coeff_list[[paste0("coeff_", names(model_df[j]), "_", w)]] <- coeff
}
}
}
}
}
top_models <- rbind(top_models, top)
}
ord_lab <- c("trees_all", "x1966", "x1977", "x1999")
coeff_list1 <- list()
for(q in seq(along=ord_lab)){
coeff_list_temp <- coeff_list[grepl(ord_lab[[q]], names(coeff_list))]
coeff_list_temp <-
coeff_list_temp[
order((as.numeric(
str_extract(names(coeff_list_temp)
[grepl(ord_lab[[q]], names(coeff_list_temp))],
"[[:digit:]]$")
)))]
coeff_list1 <- c(coeff_list1, coeff_list_temp)
}
View(coeff_list1)
merge.all <- function(x, y) {
merge(x, y, all=TRUE, by="model_var")
}
coeff_table <- Reduce(merge.all, coeff_list1)
coeff_table[,2:ncol(coeff_table)] <- round(coeff_table[,2:ncol(coeff_table)], 3)
coeff_new <- as.data.frame(t(coeff_table[,-1]))
colnames(coeff_new) <- coeff_table$model_var
# coeff_new$year1966 <- ifelse(!is.na(coeff_new$year1977), 0, NA) #only applicable if "year" is a significant variable
coeff_new$codominant <- ifelse(!is.na(coeff_new$position_alldominant), 0, NA)
coeff_new$rpdiffuse <- ifelse(!is.na(coeff_new$rpring), 0, NA)
# coeff_new <- coeff_new[, c("dAICc","r^2", "(Intercept)", "height.ln.m",
#                            "position_alldominant", "codominant", "position_allintermediate","position_allsuppressed",
#                           "rpdiffuse", "rpring", "rpsemi-ring", "TWI.ln", "PLA_dry_percent", "mean_TLP_Mpa")]
coeff_new <- coeff_new[, c("dAICc","r^2", "(Intercept)", "height.ln.m",
"position_alldominant", "codominant", "position_allintermediate","position_allsuppressed",
"rpdiffuse", "rpring", "TWI.ln", "PLA_dry_percent", "mean_TLP_Mpa")]
# colnames(coeff_new) <- c("dAICc", "r^2", "Intercept","ln[H]", "D", "C", "I", "S", "diffuse", "ring", "semi-ring", "ln[TWI]", "PLA", "TLP")
colnames(coeff_new) <- c("dAICc", "r^2", "Intercept","ln[H]", "D", "C", "I", "S", "diffuse", "ring", "ln[TWI]", "PLA", "TLP")
coeff_new <- setDT(coeff_new, keep.rownames = TRUE)[]
setnames(coeff_new, old="rn", new="rank")
patterns <- c("\\[", "x", "\\]")
for(i in seq(along=patterns)){
coeff_new$rank <- gsub(patterns[[i]], "", coeff_new$rank)
}
write.csv(coeff_new, "manuscript/tables_figures/tested_traits_best_coeff.csv", row.names=FALSE)
write.csv(coeff_new, "manuscript/tables_figures/tested_traits_best_coeff.csv", row.names=FALSE)
library(ggplot2)
library(RCurl)
library(tidyr)
library(grid)
library(gridExtra)
trees_all_full <- read.csv("manuscript/tables_figures/trees_all_full.csv", stringsAsFactors = FALSE)
trees_all_full <- read.csv("manuscript/tables_figures/trees_all_sub.csv", stringsAsFactors = FALSE)
graph_traits <- colnames(trees_all_full[, 7:11])
color <- c("dark green", "blue", "gold", "purple", "magenta")
for(i in seq(along=graph_traits)){
trait <- graph_traits[[i]]
trees_all_full$trait <- trees_all_full[, trait]
p <- ggplot(trees_all_full) +
geom_point(aes(x = trait, y = height.ln.m), color = color[[i]]) +
xlab(print(trait)) +
theme_minimal()
assign(paste0(trait, "_plot"), p)
}
graph <- grid.arrange(PLA_dry_percent_plot, LMA_g_per_m2_plot, Chl_m2_per_g_plot, mean_TLP_Mpa_plot, WD_g_per_cm3_plot, nrow=2, top = textGrob(expression(bold("Hydraulic Traits by Height"))))
View(trees_all_full)
graph_traits <- colnames(trees_all_full[, 5:9])
color <- c("dark green", "blue", "gold", "purple", "magenta")
for(i in seq(along=graph_traits)){
trait <- graph_traits[[i]]
trees_all_full$trait <- trees_all_full[, trait]
p <- ggplot(trees_all_full) +
geom_point(aes(x = trait, y = height.ln.m), color = color[[i]]) +
xlab(print(trait)) +
theme_minimal()
assign(paste0(trait, "_plot"), p)
}
graph <- grid.arrange(PLA_dry_percent_plot, LMA_g_per_m2_plot, Chl_m2_per_g_plot, mean_TLP_Mpa_plot, WD_g_per_cm3_plot, nrow=2, top = textGrob(expression(bold("Hydraulic Traits by Height"))))
WD_g_per_cm3_plot
PLA_dry_percent_plot
?gather
graph_traits <- graph_traits %>%
gather("PLA_dry_percent", "LMA_g_per_m2", "Chl_m2_per_g", "mean_TLP_Mpa", "WD_g_per_cm3", key = "trait", value = measure)
data_2018 <- read.csv(text=getURL("https://raw.githubusercontent.com/SCBI-ForestGEO/SCBI-ForestGEO-Data/master/tree_main_census/data/scbi.stem3.csv"), stringsAsFactors=FALSE)
data_2018 <- read.csv(text=getURL("https://raw.githubusercontent.com/SCBI-ForestGEO/SCBI-ForestGEO-Data/master/tree_main_census/data/census-csv-files/scbi.stem3.csv"), stringsAsFactors=FALSE)
data_live <- data_2018[data_2018$Tree_Status == "Live", ]
data_2018 <- read.csv(text=getURL("https://raw.githubusercontent.com/SCBI-ForestGEO/SCBI-ForestGEO-Data/master/tree_main_census/data/census-csv-files/scbi.stem3.csv"), stringsAsFactors=FALSE)
View(data_2018)
data_live <- data_2018[data_2018$Tree_Status == "A", ]
data_live <- data_2018[data_2018$status == "A", ]
data_live <- data_2018[data_2018$status == "A", ]
cru1901 <- read.csv(text=getURL("https://raw.githubusercontent.com/SCBI-ForestGEO/climate_sensitivity_cores/master/results/canopy_vs_subcanopy/1901_2009/tables/monthly_correlation/correlation_with_CRU_SCBI_1901_2016_climate_data.csv"), stringsAsFactors = FALSE)
library(ggplot2)
library(ggpubr)
#subset out caco, cato, and frni because they don't have pair of canopy and subcanopy
cru1901 <- cru1901[!(cru1901$Species %in% c("CACO_subcanopy", "CATO_subcanopy", "FRNI_subcanopy")), ]
cru1901_loop <- cru1901
#create separate identifier
cru1901_loop$position <- ifelse(grepl("subcanopy", cru1901$Species), "subcanopy", "canopy")
cru1901_loop$Species <- gsub("_[[:alpha:]]+$", "", cru1901$Species)
##########################################################################################
#2. box plots ####
cru1901_loop$variable <- as.character(cru1901_loop$variable)
clim <- unique(cru1901_loop$variable)
species <- unique(cru1901_loop$Species)
months <- c("curr.may", "curr.jun", "curr.jul", "curr.aug")
#creates a lattice graph showing box plot of variables grouped by species
ggplot(data = cru1901) +
aes(x = Species, y = coef, fill = variable) +
geom_boxplot() +
labs(title = "Correlation by species and variable",
y = "Correlation") +
facet_wrap( ~ Species, scales="free", nrow=4) +
theme_minimal()
cru1901_loop$Species <- as.factor(cru1901_loop$Species)
#this piece of code puts the graphs in date order
cru1901_loop <- within(cru1901_loop, month <- factor(month, levels=cru1901_loop$month[1:17]))
with(cru1901_loop, levels(month))
for (j in seq(along=clim)){
cru1901_sub <- cru1901_loop[cru1901_loop$variable %in% clim[[j]], ]
cru1901_sub <- group_by(cru1901_sub, month)
q <- ggplot(data = cru1901_sub) +
geom_boxplot(aes(x = position, y = coef, fill = position)) +
labs(title = paste0("Canopy vs subcanopy: ", clim[[j]]),
y = "Correlation") +
stat_compare_means(aes(x=position, y=coef), method="t.test", label.x.npc = 0, label.y.npc = 0.97) +
facet_wrap(~ month, scales="free", nrow=4) +
theme_minimal()
print(q)
}
q
q
install.packages("neonUtilities")
library(RCurl) #2
library(tidyr) #2
library(grid) #2
library(gridExtra) #2
library(data.table)
library(stringi)
library(ggplot2)
##2a. heights for all cored trees ####
trees_all <- read.csv("manuscript/tables_figures/trees_all.csv", stringsAsFactors = FALSE) #these graphs are meant to be for all cored trees, not just the ones being used in analysis
scbi.stem3 <- read.csv(text=getURL("https://raw.githubusercontent.com/SCBI-ForestGEO/SCBI-ForestGEO-Data/master/tree_main_census/data/census-csv-files/scbi.stem3.csv"), stringsAsFactors = FALSE)
scbi.stem3$dbh <- as.numeric(scbi.stem3$dbh)
current_ht <- trees_all[!duplicated(trees_all$tree), ]
current_ht$year <- 2018
current_ht <- current_ht[,c(1:4,17:19)]
current_ht$dbh_old.mm <- scbi.stem3$dbh[match(current_ht$tree, scbi.stem3$tag)]
current_ht <- trees_all[!duplicated(trees_all$tree), ]
current_ht$year <- 2018
View(current_ht)
current_ht$dbh_old.mm <- scbi.stem3$dbh[match(current_ht$tree, scbi.stem3$tag)]
current_ht$dbh_old.cm <- current_ht$dbh_old.mm/10
current_ht$year_dbh <- ifelse(!is.na(current_ht$dbh_old.cm), 2018, NA)
#get original dbh if they died before 2018 (only need 2013)
scbi.stem2 <- read.csv(text=getURL("https://raw.githubusercontent.com/SCBI-ForestGEO/SCBI-ForestGEO-Data/master/tree_main_census/data/census-csv-files/scbi.stem2.csv"), stringsAsFactors = FALSE)
##2a. heights for all cored trees ####
trees_all <- read.csv("manuscript/tables_figures/trees_all.csv", stringsAsFactors = FALSE) #these graphs are meant to be for all cored trees, not just the ones being used in analysis
View(trees_all)
current_ht <- trees_all[!duplicated(trees_all$tree), ]
current_ht$year <- 2018
current_ht$dbh_old.mm <- scbi.stem3$dbh[match(current_ht$tree, scbi.stem3$tag)]
current_ht$dbh_old.cm <- current_ht$dbh_old.mm/10
current_ht$year_dbh <- ifelse(!is.na(current_ht$dbh_old.cm), 2018, NA)
current_ht$dbh_old.mm <- ifelse(is.na(current_ht$dbh_old.mm),
scbi.stem2$dbh[match(current_ht$tree, scbi.stem2$tag)],
current_ht$dbh_old.mm)
current_ht$dbh_old.cm <- ifelse(is.na(current_ht$dbh_old.cm),
current_ht$dbh_old.mm/10,
current_ht$dbh_old.cm)
current_ht$year_dbh <- ifelse(is.na(current_ht$year_dbh), 2013, current_ht$year_dbh)
#get the log dbh and get heights
current_ht$dbh.ln.cm <- log(current_ht$dbh_old.cm)
#this csv is from the end of the #4 in canopy_heights.R
height_regr <- read.csv("manuscript/tables_figures/tableS2_height_regression.csv", stringsAsFactors = FALSE)
current_ht$height.ln.m <- NA
for(w in seq(along=height_regr$sp)){
sp_foc <- height_regr$sp[[w]]
ht_eq <- height_regr[height_regr$sp == sp_foc, ]
num <- gsub("\\*x", "", ht_eq$Equations)
num1 <- as.numeric(stri_extract_first_regex(num, "[[:digit:]].[[:digit:]]+"))
num2 <- as.numeric(stri_extract_last_regex(num, "[[:digit:]].[[:digit:]]+"))
if(sp_foc %in% current_ht[,"sp"]){
current_ht$height.ln.m <-
ifelse(current_ht$sp == sp_foc,
num1 + num2*current_ht$dbh.ln.cm,
current_ht$height.ln.m)
} else {
current_ht$height.ln.m <-
ifelse(current_ht$sp != sp_foc,
num1 + num2*current_ht$dbh.ln.cm,
current_ht$height.ln.m)
}
}
current_ht$height.m <- exp(current_ht$height.ln.m)
current_ht <- current_ht[order(current_ht$tree, current_ht$year), ]
#graphing height by crown position (for paper)
current_ht <- current_ht[!is.na(current_ht$position_all), ]
current_ht$position_all_abb <- substring(current_ht$position_all, 0, 1)
current_ht$position_all_abb <- toupper(current_ht$position_all_abb)
current_ht$position_all_abb <- factor(current_ht$position_all_abb, levels = c("D", "C", "I", "S"))
heights <-
ggplot(data = current_ht, aes(x = position_all_abb, y = height.m, group = position_all)) +
# aes(x=position_all, y=height.m, fill=year) +
geom_boxplot() +
xlab("Crown position") +
ylab("Height [m]") +
scale_y_continuous(breaks = scales::pretty_breaks(n = 6), limits=c(0,60)) +
theme_minimal() +
theme(axis.text = element_text(size=12)) +
theme(axis.title = element_text(size=14))
heights
##2b. get height data for all trees >10cm dbh in census ####
scbi.stem3 <- read.csv(text=getURL("https://raw.githubusercontent.com/SCBI-ForestGEO/SCBI-ForestGEO-Data/master/tree_main_census/data/census-csv-files/scbi.stem3.csv"), stringsAsFactors = FALSE)
library(RCurl)
library(tidyr)
library(grid)
library(gridExtra)
library(data.table)
library(stringi)
library(ggplot2)
##2b. get height data for all trees >10cm dbh in census ####
scbi.stem3 <- read.csv(text=getURL("https://raw.githubusercontent.com/SCBI-ForestGEO/SCBI-ForestGEO-Data/master/tree_main_census/data/census-csv-files/scbi.stem3.csv"), stringsAsFactors = FALSE)
#this csv is from the end of the #4 in canopy_heights.R
height_regr <- read.csv("manuscript/tables_figures/tableS2_height_regression.csv", stringsAsFactors = FALSE)
scbi.stem3$dbh <- as.numeric(scbi.stem3$dbh)
scbi.stem3$dbh <- ifelse(is.na(scbi.stem3$dbh), 0, scbi.stem3$dbh)
scbi18_ht <- scbi.stem3
scbi18_ht <- scbi18_ht[scbi18_ht$dbh>=100, ]
scbi18_ht <- scbi18_ht[,c(2:5,11,14:15)]
scbi18_ht$dbh_old.cm <- scbi18_ht$dbh/10
scbi18_ht$dbh.ln.cm <- log(scbi18_ht$dbh_old.cm)
scbi18_ht$height.ln.m <- NA
for(w in seq(along=height_regr$sp)){
sp_foc <- height_regr$sp[[w]]
ht_eq <- height_regr[height_regr$sp == sp_foc, ]
num <- gsub("\\*x", "", ht_eq$Equations)
num1 <- as.numeric(stri_extract_first_regex(num, "[[:digit:]].[[:digit:]]+"))
num2 <- as.numeric(stri_extract_last_regex(num, "[[:digit:]].[[:digit:]]+"))
if(sp_foc %in% scbi18_ht[,"sp"]){
scbi18_ht$height.ln.m <-
ifelse(scbi18_ht$sp == sp_foc,
num1 + num2*scbi18_ht$dbh.ln.cm,
scbi18_ht$height.ln.m)
} else {
scbi18_ht$height.ln.m <-
ifelse(scbi18_ht$sp != sp_foc,
num1 + num2*scbi18_ht$dbh.ln.cm,
scbi18_ht$height.ln.m)
}
}
scbi18_ht$height.m <- exp(scbi18_ht$height.ln.m) #used below in #3
##2c. Figure S3: combine heights to make plot with all years ####
trees_all$position_all_abb <- ifelse(trees_all$position_all == "dominant", "D",
ifelse(trees_all$position_all == "co-dominant", "C",
ifelse(trees_all$position_all == "suppressed", "S", "I")))
?levelplot
library(rasterVis)
?levelplot
library(ggpubr)
library(extrafont)
library(rasterVis)
loadfonts(device="win") #to get TNR
quantile(current_ht$height.m, c(.95), na.rm=TRUE) #95% quantile = 35.002m
quant <- data.frame(yintercept = 35.0022, Lines = "95th percentile")
##2a. Get NEON plots ####
source('scripts/vertical_height_neon.R', echo=TRUE)
NEON_list <- list(wind_plot, RH_plot, SAAT_plot) #,"biotemp_plot")
names(NEON_list) <- c("wind_plot", "RH_plot", "SAAT_plot") #,"biotemp_plot
##2b. Format the NEON plots ####
NEON_order <- c("(a)", "(b)", "(c)")
NEON_order_x <- c(0.5, 35, 7.5)
NEON_order_y <- c(57.5, 57.5, 57.5)
for (i in seq(along=1:3)){
NEON_list[[i]] <-
NEON_list[[i]] +
theme_bw(base_size = 16) +
# theme_bw(base_family = "serif") + #for TNR font
geom_hline(aes(yintercept = yintercept), linetype = "longdash", quant) +
annotate(geom="text", x=NEON_order_x[[i]], y=NEON_order_y[[i]],
label = NEON_order[[i]], fontface="bold", size=7)
if(i==3){
NEON_list[[i]] <-
NEON_list[[i]] +
theme(legend.title = element_blank(),
legend.box = "vertical",
legend.position = c(0.8, 0.85),
legend.background = element_rect(fill=alpha("white", 0.01)),
legend.text=element_text(size=12),
legend.key.size=unit(4,"mm"),
legend.spacing=unit(-0.5,"cm")
)
}
if(!i==3){
NEON_list[[i]] <-
NEON_list[[i]] +
theme(legend.position = "none")
}
if(!i==1){
NEON_list[[i]] <-
NEON_list[[i]] +
theme(axis.title.y = element_blank(),
axis.text.y=element_blank(),
axis.ticks.y=element_blank())
}
}
NEON <- ggarrange(NEON_list$wind_plot, NEON_list$RH_plot, NEON_list$SAAT_plot,  nrow=1, ncol=3, align="h")
##2c. Get the boxplots for 2018 heights (this is also prep for #3) ####
trees_all <- read.csv("manuscript/tables_figures/trees_all.csv", stringsAsFactors = FALSE) #these graphs are meant to be for all cored trees, not just the ones being used in analysis
scbi.stem3 <- read.csv(text=getURL("https://raw.githubusercontent.com/SCBI-ForestGEO/SCBI-ForestGEO-Data/master/tree_main_census/data/census-csv-files/scbi.stem3.csv"), stringsAsFactors = FALSE)
scbi.stem3$dbh <- as.numeric(scbi.stem3$dbh)
current_ht <- trees_all[!duplicated(trees_all$tree), ]
current_ht$year <- 2018
current_ht <- current_ht[,c(1:4,17:19)]
current_ht$dbh_old.mm <- scbi.stem3$dbh[match(current_ht$tree, scbi.stem3$tag)]
current_ht$dbh_old.cm <- current_ht$dbh_old.mm/10
current_ht$year_dbh <- ifelse(!is.na(current_ht$dbh_old.cm), 2018, NA)
#get original dbh if they died before 2018 (only need 2013)
scbi.stem2 <- read.csv(text=getURL("https://raw.githubusercontent.com/SCBI-ForestGEO/SCBI-ForestGEO-Data/master/tree_main_census/data/census-csv-files/scbi.stem2.csv"), stringsAsFactors = FALSE)
current_ht$dbh_old.mm <- ifelse(is.na(current_ht$dbh_old.mm),
scbi.stem2$dbh[match(current_ht$tree, scbi.stem2$tag)],
current_ht$dbh_old.mm)
current_ht$dbh_old.cm <- ifelse(is.na(current_ht$dbh_old.cm),
current_ht$dbh_old.mm/10,
current_ht$dbh_old.cm)
current_ht$year_dbh <- ifelse(is.na(current_ht$year_dbh), 2013, current_ht$year_dbh)
#get the log dbh and get heights
current_ht$dbh.ln.cm <- log(current_ht$dbh_old.cm)
#linear log-log regression
#the full equation is using all points for which we have data to create the equation, despite that for several species we don't have enough data to get a sp-specific equation
#this csv is created from #4 of canopy_heights.R
height_regr <- read.csv("manuscript/tables_figures/tableS2_height_regression.csv", stringsAsFactors = FALSE)
current_ht$height.ln.m <- NA
for(w in seq(along=height_regr$sp)){
sp_foc <- height_regr$sp[[w]]
ht_eq <- height_regr[height_regr$sp == sp_foc, ]
num <- gsub("\\*x", "", ht_eq$Equations)
num1 <- as.numeric(stri_extract_first_regex(num, "[[:digit:]].[[:digit:]]+"))
num2 <- as.numeric(stri_extract_last_regex(num, "[[:digit:]].[[:digit:]]+"))
if(sp_foc %in% current_ht[,"sp"]){
current_ht$height.ln.m <-
ifelse(current_ht$sp == sp_foc,
num1 + num2*current_ht$dbh.ln.cm,
current_ht$height.ln.m)
} else {
current_ht$height.ln.m <-
ifelse(current_ht$sp != sp_foc,
num1 + num2*current_ht$dbh.ln.cm,
current_ht$height.ln.m)
}
}
current_ht$height.m <- exp(current_ht$height.ln.m)
current_ht <- current_ht[order(current_ht$tree, current_ht$year), ]
#graphing height by crown position (for paper)
current_ht <- current_ht[!is.na(current_ht$position_all), ]
current_ht$position_all_abb <- substring(current_ht$position_all, 0, 1)
current_ht$position_all_abb <- toupper(current_ht$position_all_abb)
current_ht$position_all_abb <- factor(current_ht$position_all_abb, levels = c("D", "C", "I", "S"))
heights_box <-
ggplot(data = current_ht, aes(x = position_all_abb, y = height.m, group = position_all)) +
# aes(x=position_all, y=height.m, fill=year) +
geom_boxplot() +
xlab("Crown position") +
ylab("Height [m]") +
scale_y_continuous(breaks = scales::pretty_breaks(n = 6), limits=c(0,60)) +
theme_minimal() +
theme(axis.text = element_text(size=12)) +
theme(axis.title = element_text(size=14))
##2d. Format the height boxplot and add to NEON, export ####
heights_box <- #all graphs
heights_box +
theme_bw(base_size = 16) +
# theme_bw(base_family = "serif") + #for TNR font
geom_hline(aes(yintercept = yintercept), linetype = "longdash", quant) +
annotate(geom="text", x=0.8, y=57.5,
label = "d", fontface="bold", size=7)
