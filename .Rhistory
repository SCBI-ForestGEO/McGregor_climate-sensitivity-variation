Merged_dendroband_utm_lat_lon <- read.csv("V:/SIGEO/GIS_data/dendroband surveys/Merged_dendroband_utm_lat_lon.csv")
View(Merged_dendroband_utm_lat_lon)
tree_sp <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/Dendrobands/metadata/tree_sp.csv")
View(tree_sp)
tree_sp_new <- merge(Merged_dendroband_utm_lat_lon, tree_sp, by=c("tag"))
View(tree_sp_new)
tree_sp_new <- merge(tree_sp, Merged_dendroband_utm_lat_lon, by=c("tag"))
tree_sp_new <- merge(tree_sp, Merged_dendroband_utm_lat_lon, by=c("tag", "StemTag"))
duplicated(tree_sp_new)
tree_sp_new[!duplicated(tree_sp_new[c('tag')]),]
tree_sp_new1 <- tree_sp_new[!duplicated(tree_sp_new[c('tag')]),]
View(tree_sp_new1)
tree_sp_new <- merge(tree_sp, Merged_dendroband_utm_lat_lon, by=c("tag", "StemTag"))
View(tree_sp_new)
View(tree_sp)
View(tree_sp_new)
tree_sp_new <- merge(tree_sp, Merged_dendroband_utm_lat_lon, by=c("tag", "StemTag", all=FALSE))
tree_sp_new <- merge(tree_sp, Merged_dendroband_utm_lat_lon, by=c("tag", "StemTag"), all=FALSE)
View(tree_sp_new)
View(tree_sp)
View(tree_sp_new1)
View(tree_sp_new)
View(Merged_dendroband_utm_lat_lon)
?grepl
grepl(10011, tree_sp$tag)
tree_sp_new <- merge(tree_sp, Merged_dendroband_utm_lat_lon, by=c("tag", "StemTag", "treeID"), all=FALSE)
View(tree_sp_new)
install.packages("compare")
library(compare)
compare(tree_sp, tree_sp_new,allowAll = TRUE)
comparison<-compare(tree_sp, tree_sp_new,allowAll = TRUE)
View(comparison)
comparison$tag
library(dplyr)
anti_join(tree_sp$tag, tree_sp_new$tag)
anti_join(tree_sp, tree_sp_new)
View(tree_sp)
colnames(tree_sp)
tree_sp$tag
tree_sp_new$tag
getwd(\)
getwd()
write.csv(tree_sp_new, "testthing.csv")
?unique
unique(tree_sp_new)
tree_sp_new1<-unique(tree_sp_new)
View(tree_sp_new1)
tree_sp_new1<-tree_sp_new %>% distinct(tag, .keep_all=TRUE)
View(tree_sp_new1)
tree_sp_new1<-tree_sp_new %>% distinct(tag, StemTag, .keep_all=TRUE)
tree_sp_new1<-tree_sp_new %>% distinct(tag, StemTag, stemID, .keep_all=TRUE)
View(tree_sp_new1)
ifelse(tree_sp$tag==tree_sp_new1, TRUE, FALSE)
ifelse(tree_sp$tag==tree_sp_new1$tag, TRUE, FALSE)
ifelse(tree_sp$tag==tree_sp_new1$tag, TRUE, FALSE)
View(tree_sp_new1)
tree_sp<-c(tree_sp$tag)
tree_sp_new1<-c(tree_sp_new1$tag)
original<-c(tree_sp$tag)
tree_sp <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/Dendrobands/metadata/tree_sp.csv")
View(tree_sp)
original<-c(tree_sp$tag)
original[original %in% tree_sp_new1]
original[!(original %in% tree_sp_new1)]
tree_sp_new1<-tree_sp_new %>% distinct(tag, StemTag, stemID, .keep_all=TRUE)
new1<-c(tree_sp_new1$tag)
original[original %in% new1]
original[!(original %in% new1)]
write.csv(tree_sp_new1, "tree_sp.csv")
#adapted from http://spatialanalysis.co.uk/wp-content/uploads/2012/07/exporting-to-kml.txt
library(sp)
library(maptools)
library(rgdal)
library(mapview)
setwd()
ForC_sites <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/ForC/data/ForC_sites.csv")
coordinates(ForC_sites)<- c("lon", "lat")
BNG<- CRS("+init=epsg:4326") #reference from http://spatialreference.org/ref/epsg/4326/
p4s <- CRS("+proj=longlat +ellps=WGS84 +datum=WGS84")
proj4string(ForC_sites)<-BNG
ForC_wgs84<- spTransform(ForC_sites, CRS=p4s)
mapview(ForC_wgs84, label=ForC_sites$sites.sitename)
#we can use the basic open Esri.WorldImagery behind this and it works. Other maps can be obtained below.
#with mapview it is easy to change symbology, add legends, etc. This can be an option for the future.
library(ggmap)
get_map(source="google", maptype="hybrid")
#for whatever reason it won't let me download the map because it is "403 Forbidden." I have no idea if this is an IT issue or not.
scbi.dendroAll_2018 <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/Dendrobands/data/clean_data_files/2018/scbi.dendroAll_2018.csv")
View(scbi.dendroAll_2018)
dendroID_chronology <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/Dendrobands/data/clean_data_files/dendroID_chronology.csv", stringsAsFactors=FALSE)
View(dendroID_chronology)
data_stem<-scbi.dendroAll_2018[which(scbi.dendroAll_2018$survey.ID=='2018.01'), ] #subset by 2018.01 (one entry per stem)
scbi.dendroAll_2018$dendroID <- dendroID_chronology$X2018.dendroID[match(scbi.dendroAll_2018$tag, dendroID_chronology$tag)]
View(scbi.dendroAll_2018)
write.csv(scbi.dendroAll_2018, "scbi.dendroAll_2018.csv")
getwd()
dendro_cored_full <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/Dendrobands/data/clean_data_files/dendro_cored_full.csv")
View(dendro_cored_full)
cores <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/climate_sensitivity_cores/data/census_data_for_cored_trees.csv")
dendro_trees <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/Dendrobands/data/clean_data_files/dendro_trees.csv")
library(data.table)
setnames(cores, old=c("StemTag"), new=c("stemtag"))
dendro_trees$year.cored <-cores$year.cored[match(dendro_trees$tag,cores$tag)]
dendro_merge <- merge(dendro_trees, cores, by=c("tag", "stemtag", "sp", "quadrat", "treeID", "stemID", "status", "gx", "gy","year.cored"), all.x=TRUE, all.y=TRUE)
dendro_all <- dendro_merge[c(1:19)]
##order the data and remove the crossovers (btwn biannual and cored) that don't have biannual marked already
dendro_all <- dendro_all[order(dendro_all$tag,dendro_all$biannual),]
dendro_all$stemID[is.na(dendro_all$stemID)] <- 0
##WARNING:assign stemID values for 30365 and 131352 (discrepancy with 2013 census). THIS PART SHOULD BE DELETED once the 2018 census data includes these tags with the appropriate info.
dendro_all[91,6]=11
dendro_all[867,6]=12
dendro_all<-dendro_all[!duplicated(dendro_all$stemID),]
##populate with geographic coordinates
latlon <- read.csv("V:/SIGEO/GIS_data/dendroband surveys/Merged_dendroband_utm_lat_lon.csv")
dendro_all$NAD83_X <- latlon$NAD83_X[match(dendro_all$stemID, latlon$stemID)]
dendro_all$NAD83_Y <- latlon$NAD83_Y[match(dendro_all$stemID, latlon$stemID)]
dendro_all$lat <- latlon$lat[match(dendro_all$stemID, latlon$stemID)]
dendro_all$lon <- latlon$lon[match(dendro_all$stemID, latlon$stemID)]
##populate with lx, ly, and status (once ForestGEO 2018 census data is added, use that for base status)
census_2013 <- read.csv("V:/SIGEO/3-RECENSUS 2013/DATA/FINAL DATA to use, to share/scbi.stem2.csv")
dendro_all$lx <- $lx[match(dendro_all$stemID, $stemID)]
dendro_all$ly <- $ly[match(dendro_all$stemID, $stemID)]
##update status from most recent mortality data (this will update only some of the trees, hence why the census data is used first)
mortality_2018 <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/SCBI-ForestGEO-Data_private/SCBI_mortality/raw data/Mortality_Survey_2018.csv")
dendro_all$status <- mortality_2018$new.status[match(dendro_all$tag, mortality_2018$tag)]
missing <- ifelse(is.na(dendro_all$status), dendro_all$tag, "")
missingdf <- dendro_all[!complete.cases(dendro_all$status),]
missingdf <- missingdf[c(1:2)]
setnames(census_2013, old=c("StemTag"), new=c("stemtag"))
dendro_test <- merge(missingdf, census_2013[,c("tag", "stemtag","status")], by=c("tag","stemtag"))
dendro_all <- merge(dendro_all, dendro_test, by="tag", all.x=TRUE)
setnames(dendro_all, old="stemtag.x", new="stemtag")
library(tidyr)
dendro_all <- unite(dendro_all, status, status.x, status.y)
dendro_all$status <- gsub("_NA", "", dendro_all$status)
dendro_all$status <- gsub("NA_", "", dendro_all$status)
dendro_all$status <- gsub("PD", "D", dendro_all$status)
dendro_all$status <- gsub("DS", "D", dendro_all$status)
dendro_all$status <- gsub("DC", "D", dendro_all$status)
dendro_all$status <- gsub("AU", "A", dendro_all$status)
##get rid of NA
dendro_all$biannual[is.na(dendro_all$biannual)] <- 0
dendro_all$intraannual[is.na(dendro_all$intraannual)] <- 0
dendro_all$cored[is.na(dendro_all$cored)] <- 1
##re-order
dendro_all <- dendro_all[c(1:6,11:13,10,7,14:15,8:9,16:19)]
#get rid of final duplicates now that all rows are the same
dendro_all <- dendro_all[!duplicated(dendro_all),]
write.csv(dendro_all, "dendro_cored_full.csv", row.names=FALSE)
getwd()
dendro_cored_full <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/Dendrobands/data/clean_data_files/dendro_cored_full.csv")
View(dendro_cored_full)
library(dplyr)
dendro <- dendro_cored_full %>%
filter(status==A)
dendro <- dendro_cored_full %>%
filter(status=="A")
View(dendro)
dendro <- dendro[c(1:4,7:11)]
View(dendro)
dendro <- dendro[c(1:4,7:10)]
dendro <- dendro_cored_full %>%
filter(status=="A")
dendro <- dendro[c(1:4,7:10)]
View(dendro)
dendro$crown.position <- ""
View(dendro)
write.csv(dendro, "scbi.crownposition.csv")
getwd()
install.packages(devtools)
install.packages("devtools")
devtools::install_github("forestgeo/fgeo")
library(fgeo)
devtools::install_github("forestgeo/fgeo")
library(fgeo)
fgeo(help)
install.packages(c("animation", "aqp", "backports", "BH", "bookdown", "broom", "callr", "carData", "checkmate", "classInt", "clipr", "colorspace", "curl", "data.table", "dbplyr", "dplR", "dplyr", "e1071", "esquisse", "expss", "flextable", "FNN", "ggmap", "ggvis", "git2r", "googleVis", "haven", "Hmisc", "htmlTable", "htmlwidgets", "httpuv", "httr", "jsonlite", "lemon", "lme4", "mapview", "markdown", "measurements", "mgcv", "nloptr", "openssl", "packrat", "pillar", "plotKML", "processx", "ps", "psych", "purrr", "quantreg", "raster", "rcmdcheck", "Rcpp", "RcppEigen", "readr", "readxl", "reshape", "rio", "RJSONIO", "rlang", "rmarkdown", "rsconnect", "rstudioapi", "sessioninfo", "sf", "shiny", "shinyWidgets", "spam", "spData", "stars", "testthat", "tibble", "tidybayes", "tinytex", "tmap", "units", "waveslim", "webshot", "writexl", "xts"))
install.packages("pupR")
dendro2011 <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/Dendrobands/data/scbi.dendroAll_2011.csv")
dendro2012 <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/Dendrobands/data/scbi.dendroAll_2012.csv")
View(dendro2011)
View(dendro2012)
dendro2012 <- dendro2012[dendro2012$new.band==1, ]
farms <- data.frame(lat=runif(3), lng=runif(3))
dist(farms, diag=T, upper=T)
#behold the vegan package
farms <- data.frame(lat=runif(20), lng=runif(20))
View(farms)
rownames(farms) <- "A:Z"
rownames(farms) <- "[[:alpha:]]"
"[[:alpha:]]"
[[:alpha:]]
[:alpha:]
rownames(farms) <- 180001:180026
rownames(farms) <- 180001:180027
#behold the vegan package
farms <- data.frame(lat=runif(26), lng=runif(26))
rownames(farms) <- 180001:180026
View(farms)
d <- vegdist(farms, method="euclidean") #caluclate distance
#behold the vegan package
library(vegan)
d <- vegdist(farms, method="euclidean") #caluclate distance
m <- data.frame(t(combn(rownames(farms),2)), as.numeric(d)) #put in df format
names(m) <- c("tree1", "tree2", "distance")
View(m)
scbi.full2 <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/SCBI-ForestGEO-Data/tree_main_census/data/census-csv-files/scbi.full2.csv", stringsAsFactors=FALSE)
scbi.full2[5340, 3] <- 40874 #duplicated tag
trees <- scbi.full2[scbi.full2$dbh>=100  & !grepl("S", scbi.full2$codes), ]
trees <- trees[c(3,7,8)]
rownames(trees) <- trees[,1]
trees <- trees[, -1]
library(vegan)
d <- vegdist(trees, method="euclidean") #calculate distance between one tree and all the other trees using Pythagorean theorem
m <- data.frame(t(combn(rownames(trees),2)), as.numeric(d)) #put in df format
names(m) <- c("tree1", "tree2", "distance")
simple <- m[m$distance<=30, ] #only include distances of 30m or less
simple <- simple[sort(simple$tree1, simple$distance)]
?sort
?order
simple <- simple[order(simple$tree1, simple$distance)]
simple <- simple[order(simple$tree1, simple$distance), ]
View(simple)
scbi.2013 <- scbi.full2[scbi.full2$tag %in% unique(simple$tree1), ]
setdiff(unique(simple$tree1), scbi.2013$tag)
unique(simple$tree1)
q <- unique(simple$tree1)
p <- scbi.2013[duplicated(scbi.2013$tag)]
p <- scbi.2013[duplicated(scbi.2013$tag), ]
View(p)
scbi.sub <- scbi.full2[scbi.full2$dbh>=100  & !grepl("S", scbi.full2$codes), ]
trees <- scbi.sub[c(3,7,8)]
rownames(trees) <- trees[,1]
trees <- trees[, -1]
scbi.sub <- scbi.sub[scbi.sub$tag %in% unique(simple$tree1), ]
p <- trees[duplicated(rownames(trees)), ]
setdiff(unique(simple$tree1), scbi.sub$tag)
View(trees)
rm(scbi.2013)
scbi.full2 <- scbi.full2[scbi.full2$dbh>=100  & !grepl("S", scbi.full2$codes), ]
trees <- scbi.full2[c(3,7,8)]
rownames(trees) <- trees[,1]
trees <- trees[, -1]
scbi.sub <- scbi.full2[scbi.full2$tag %in% unique(simple$tree1), ] #this number won't match "trees" because some trees from scbi.sub are >30m apart from another tree
View(simple)
View(scbi.sub)
scbi.sub <- scbi.sub[c(3,7,8,11)]
scbi.sub$basal <- pi*(scbi.sub$dbh/2)^2
View(scbi.sub)
scbi.sub$dbh <- scbi.sub$dbh/10
View(scbi.sub)
scbi.sub$basal <- pi*(scbi.sub$dbh/2)^2
View(scbi.sub)
?seq
seq(1,30, by=0.5)
seq(0,30, by=0.5)
dist <- seq(0,30, by=0.5)
scbi.sub[, dist] <- NA
scbi.sub[dist] <- NA
?rep
gsub("^", "X", dist)
gsub("^", "x", dist)
dist <- gsub("^", "x", dist)
scbi.sub[, dist] <- NA
View(scbi.sub)
scbi.sub$basal <- (pi*(scbi.sub$dbh/2)^2)*0.0001
View(scbi.sub)
View(m)
View(simple)
test <- simple[simple$tree1 == 12165, ]
View(test)
test <- simple[simple$tree1 == 12165 | simple$tree2 == 12165, ]
View(test)
sum(test$distance)
sum(test$distance) / 30
scbi.sub[scbi.sub$tag==12171, ]
scbi.sub[scbi.sub$tag==12173, ]
colnames(scbi.sub[, 6:ncol(scbi.sub)])
i=1
inc <- colnames(scbi.sub[, 6:ncol(scbi.sub)])[[i]]
inc <- gsub("x", "", inc)
inc <- colnames(scbi.sub[, 6:ncol(scbi.sub)])[[i]]
inc_num <- gsub("x", "", inc)
j=1
test <- simple[simple$tree1 | simple$tree2 == simple$tree1[[j]], ]
simple$tree1 <- as.numeric(simple$tree1)
simple$tree2 <- as.numeric(simple$tree2)
test <- simple[simple$tree1 | simple$tree2 == simple$tree1[[j]], ]
test <- simple[simple$tree1 == simple$tree[[j]] | simple$tree2 == simple$tree1[[j]], ]
simple$tree1
simple <- m[m$distance<=30, ] #only include distances of 30m or less
simple <- simple[order(simple$tree1, simple$distance), ] #sort by tree and distance
simple$tree1 <- as.character(simple$tree1)
View(simple)
simple$tree2 <- as.character(simple$tree2)
View(simple)
simple$tree2 <- as.numeric(simple$tree2)
simple$tree1 <- as.numeric(simple$tree1)
View(simple)
test <- simple[simple$tree1 == simple$tree[[j]] | simple$tree2 == simple$tree1[[j]], ]
simple$tree1
tree <- unique(simple$tree1)[[j]]
test <- simple[simple$tree1 == tree | simple$tree2 == tree, ]
View(test)
test <- test[order(test$distance), ] #order by distance
View(test)
test$distance
test$distance[-ncol(test)]
inc <- colnames(scbi.sub[, 6:ncol(scbi.sub)])[[i]]
scbi.sub$inc
colnames(scbi.sub)
inc <- colnames(scbi.sub) # [, 6:ncol(scbi.sub)])[[i]]
inc <- colnames(scbi.sub)[[i]] # [, 6:ncol(scbi.sub)])[[i]]
inc[[i>=6]]
i=2
inc <- colnames(scbi.sub)[[i]] # [, 6:ncol(scbi.sub)])[[i]]
inc-1
inc[-1]
inc <- colnames(scbi.sub)[[i-1]] # [, 6:ncol(scbi.sub)])[[i]]
k=1
inc_num <- colnames(scbi.sub[, 6:ncol(scbi.sub)])[[k]]
install.packages("spelling", "mapr", "magick", "geoaxe")
install.packages(c("spelling", "spellcheckr", "mapr", "magick", "geoaxe"))
library(pointRes)
library(dplR)
library(data.table)
##4a. canopy ####
setwd("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/SCBI-ForestGEO-Data/tree_cores/chronologies/current_chronologies/complete/separated by canopy position/canopy_cores")
dirs_can <- dir("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/SCBI-ForestGEO-Data/tree_cores/chronologies/current_chronologies/complete/separated by canopy position/canopy_cores", pattern = "_canopy.rwl")
dirs_can <- dirs_can[dirs_can != "frni_canopy.rwl" & dirs_can != "frni_drop_canopy.rwl" & dirs_can != "caco_drop_canopy.rwl"]
sp_can <- gsub("_drop_canopy.rwl", "", dirs_can)
canopy <- list()
widths_can <- list()
canopy_table <- NULL
for (i in seq(along=dirs_can)){
for (j in seq(along=sp_can)){
if (i==j){
file <- dirs_can[[i]]
rings <- read.rwl(file) #read in rwl file
area <- bai.in(rings) #convert to bai.in
testr <- res.comp(area, nb.yrs=5, res.thresh.neg = 30, series.thresh = 50) #get resilience metrics
canopy[[i]] <- testr
widths_can[[i]] <- rings
testr_table <- data.frame(testr$out)
testr_table <- testr_table[testr_table$nb.series > 4, ] #remove where there are < 4 series
testr_table$sp <- sp_can[[j]]
testr_table$position <- "canopy"
canopy_table <- rbind(canopy_table, testr_table)
}
values <- paste0(sp_can, "_can_res")
names(canopy) <- values
values <- paste0(sp_can, "_canopy")
names(widths_can) <- values
##4c. df for pointer years of all trees combined ####
full_ind <- rbind(canopy_table, subcanopy_table) #full table of indices for canopy and subcanopy cores
pointers <- full_ind[full_ind$nature == -1, ]
library(dplyr)
years_point <- count(pointers, vars=year) #counts the occurrences of each unique year
colnames(years_point) <- c("yr", "n.pointer")
years_point <- years_point[order(years_point$n.pointer, decreasing=TRUE), ]
setwd("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/McGregor_climate-sensitivity-variation")
#write.csv(pointers, "occurrence_of_pointer_yrs.csv", row.names=FALSE)
##4d. resistance metrics for all trees ####
neil_list <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/McGregor_climate-sensitivity-variation/core_list_for_neil.csv", stringsAsFactors = FALSE)
neil_list$tag <- paste0("X", neil_list$tag) #to match the colnames of can_resist below
pointer_years <- head(years_point$yr) #from above in #4c
pointer_years <- pointer_years[!pointer_years %in% c(1911, 1947, 1991)]
###canopy ####
#this loop says, for the different species in the list "canopy" (names(canopy)), create a dataframe of only the resistance index. Make a list of the colnames, which are the individual trees. Then, assign species identifiers for each one from Neil's core list, subset by the defined pointer years, and melt the data before rbinding.
tag_n <- names(canopy)
trees_canopy <- NULL
for (i in seq(along=1:length(tag_n))){
can_resist <- data.frame(canopy[[i]]$resist)
years <- rownames(can_resist)
colnames(can_resist) <- gsub("A", "", colnames(can_resist))
tree_series <- colnames(can_resist)
# for (j in seq(along=tree_series)){
#  trees <- tree_series[[j]]
ind <- can_resist
ind_neil <- neil_list[neil_list$tag %in% tree_series, ]
#  colnames(ind) <- trees
ind$year <- years
ind$sp <- unique(ind_neil$sp)
ind$position <- "canopy"
ind <- ind[ind$year %in% pointer_years, ]
change <- melt(ind)
setnames(change, old=c("variable", "value"), new=c("tree", "resist.value"))
change$tree <- gsub("X", "", change$tree)
change$tree <- gsub("^0", "", change$tree)
trees_canopy <- rbind(trees_canopy, change)
}
pointers <- canopy_table[canopy_table$nature == -1, ]
library(dplyr)
years_point <- count(pointers, vars=year) #counts the occurrences of each unique year
colnames(years_point) <- c("yr", "n.pointer")
years_point <- years_point[order(years_point$n.pointer, decreasing=TRUE), ]
##4d. resistance metrics for all trees ####
neil_list <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/McGregor_climate-sensitivity-variation/core_list_for_neil.csv", stringsAsFactors = FALSE)
##4d. resistance metrics for all trees ####
neil_list <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/McGregor_climate-sensitivity-variation/core_list_for_neil.csv", stringsAsFactors = FALSE)
neil_list$tag <- paste0("X", neil_list$tag) #to match the colnames of can_resist below
pointer_years <- head(years_point$yr) #from above in #4c
pointer_years <- pointer_years[!pointer_years %in% c(1911, 1947, 1991)]
###canopy ####
#this loop says, for the different species in the list "canopy" (names(canopy)), create a dataframe of only the resistance index. Make a list of the colnames, which are the individual trees. Then, assign species identifiers for each one from Neil's core list, subset by the defined pointer years, and melt the data before rbinding.
tag_n <- names(canopy)
trees_canopy <- NULL
for (i in seq(along=1:length(tag_n))){
can_resist <- data.frame(canopy[[i]]$resist)
years <- rownames(can_resist)
colnames(can_resist) <- gsub("A", "", colnames(can_resist))
tree_series <- colnames(can_resist)
# for (j in seq(along=tree_series)){
#  trees <- tree_series[[j]]
ind <- can_resist
ind_neil <- neil_list[neil_list$tag %in% tree_series, ]
#  colnames(ind) <- trees
ind$year <- years
ind$sp <- unique(ind_neil$sp)
ind$position <- "canopy"
ind <- ind[ind$year %in% pointer_years, ]
change <- melt(ind)
setnames(change, old=c("variable", "value"), new=c("tree", "resist.value"))
change$tree <- gsub("X", "", change$tree)
change$tree <- gsub("^0", "", change$tree)
trees_canopy <- rbind(trees_canopy, change)
}
trees_all <- trees_canopy
trees_all$year <- as.numeric(trees_all$year)
##5a. add in turgor loss point values ####
#add in tlp values (from Krista github issue #6 https://github.com/SCBI-ForestGEO/McGregor_climate-sensitivity-variation/issues/6)
turgor <- data.frame("sp" = c("cagl", "caovl", "fagr", "fram", "juni", "litu", "pist", "qual", "qupr", "quru", "quve", "caco", "cato", "frni"), "tlp" = c(-2.1282533, -2.24839333, -2.57164, -2.1012133, -2.75936, -1.9212933, NA, -2.58412, -2.3601733, -2.6395867, -2.3879067, -2.1324133, -2.31424, NA))
trees_all$tlp <- turgor$tlp[match(trees_all$sp, turgor$sp)]
#tlp for pist is NA. Running the models below with this gives the min(AICc) for lmm.combined. Removing pist, however (because of the tlp NA), and running AICc and anova shows the best model to be lmm.random.
#trees_all <- trees_all[!trees_all$sp == "pist", ]
library(lme4)
library(AICcmodavg) #aictab function
library(car)
library(piecewiseSEM) #for R^2 values for all model outputs in a list
library(MuMIn) #for R^2 values of one model output
response <- "resist.value"
effects <- c("position", "tlp", "rp", "elev_m", "dbh_ln", "year", "(1 | sp / tree)")
#create all combinations of random / fixed effects
effects_comb <-
unlist( sapply( seq_len(length(effects)),
function(i) {
apply( combn(effects,i), 2, function(x) paste(x, collapse = "+"))
}))
# pair response with effect and sub out combinations that don't include random effects
#in general, if two variables are >70% correlated, you can toss one of them without significantly affecting the results
var_comb <- expand.grid(response, effects_comb)
var_comb <- var_comb[grepl("1", var_comb$Var2), ] #only keep in fixed/random combos
var_comb <- var_comb[grepl("year", var_comb$Var2), ] #keep year in for drought sake
# formulas for all combinations. $Var1 is the response, and $Var2 is the effect
# for good stats, you should have no more total parameters than 1/10th the number of observations in your dataset
formula_vec <- sprintf("%s ~ %s", var_comb$Var1, var_comb$Var2)
lmm_all <- lapply(formula_vec, function(x){
fit1 <- lmer(x, data = trees_all, REML=FALSE)
#fit1$coefficients <- coef( summary(fit1))
return(fit1)
})
names(lmm_all) <- formula_vec
var_aic <- aictab(lmm_all, second.ord=TRUE, sort=TRUE)
formula_vec
response <- "resist.value"
effects <- c("position", "tlp", "year", "(1 | sp / tree)") #"rp", "elev_m", "dbh_ln",
#create all combinations of random / fixed effects
effects_comb <-
unlist( sapply( seq_len(length(effects)),
function(i) {
apply( combn(effects,i), 2, function(x) paste(x, collapse = "+"))
}))
# pair response with effect and sub out combinations that don't include random effects
#in general, if two variables are >70% correlated, you can toss one of them without significantly affecting the results
var_comb <- expand.grid(response, effects_comb)
var_comb <- var_comb[grepl("1", var_comb$Var2), ] #only keep in fixed/random combos
var_comb <- var_comb[grepl("year", var_comb$Var2), ] #keep year in for drought sake
# formulas for all combinations. $Var1 is the response, and $Var2 is the effect
# for good stats, you should have no more total parameters than 1/10th the number of observations in your dataset
formula_vec <- sprintf("%s ~ %s", var_comb$Var1, var_comb$Var2)
lmm_all <- lapply(formula_vec, function(x){
fit1 <- lmer(x, data = trees_all, REML=FALSE)
#fit1$coefficients <- coef( summary(fit1))
return(fit1)
})
names(lmm_all) <- formula_vec
var_aic <- aictab(lmm_all, second.ord=TRUE, sort=TRUE)
formula_vec
View(trees_all)
trees_all <- trees_all[!trees_all$year == 1899, ]
# create list of model outputs
lmm_all <- lapply(formula_vec, function(x){
fit1 <- lmer(x, data = trees_all, REML=FALSE)
#fit1$coefficients <- coef( summary(fit1))
return(fit1)
})
View(trees_all)
#tlp for pist is NA. Running the models below with this gives the min(AICc) for lmm.combined. Removing pist, however (because of the tlp NA), and running AICc and anova shows the best model to be lmm.random.
trees_all <- trees_all[!trees_all$sp == "pist", ]
# create list of model outputs
lmm_all <- lapply(formula_vec, function(x){
fit1 <- lmer(x, data = trees_all, REML=FALSE)
#fit1$coefficients <- coef( summary(fit1))
return(fit1)
})
# create list of model outputs
lmm_all <- lapply(formula_vec, function(x){
fit1 <- lmer(x, data = trees_all, REML=FALSE)
#fit1$coefficients <- coef( summary(fit1))
return(fit1)
})
View(var_comb)
