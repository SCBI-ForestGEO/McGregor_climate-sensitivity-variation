# pair response with effect and sub out combinations that don't include random effects
#in general, if two variables are >70% correlated, you can toss one of them without significantly affecting the results
var_comb <- expand.grid(response, effects_comb)
var_comb <- var_comb[grepl("1", var_comb$Var2), ] #only keep in fixed/random combos
# formulas for all combinations. $Var1 is the response, and $Var2 is the effect
# for good stats, you should have no more total parameters than 1/10th the number of observations in your dataset
formula_vec <- sprintf("%s ~ %s", var_comb$Var1, var_comb$Var2)
lmm_all <- lapply(formula_vec, function(x){
fit1 <- lmer(x, data = model_df[[j]], REML=FALSE,
control = lmerControl(optimizer ="Nelder_Mead"))
return(fit1)
})
names(lmm_all) <- formula_vec
var_aic <- aictab(lmm_all, second.ord=TRUE, sort=TRUE) #rank based on AICc
var_aic$Modnames <- as.character(var_aic$Modnames)
best_mod_traits$best_model[[i]] <- var_aic$Modnames[[1]]
for (z in seq(along = lmm_all)){
if (names(lmm_all[z]) == var_aic$Modnames[[1]]){
#run the best model alone with REML=TRUE
fit1 <- lmer(formula_vec[[z]], data = model_df[[j]], REML=TRUE,
control = lmerControl(optimizer ="Nelder_Mead"))
#get coefficients and put in table
coeff <- data.frame(coef(summary(fit1))[ , "Estimate"]) ##2
coeff[,2] <- rownames(coeff)
coeff[,1] <- round(coeff[,1], 3)
colnames(coeff) <- c(names(model_df[j]), "model_var")
#put r2 in table
r <- rsquared(fit1) #gives R^2 values for models. "Marginal" is the R^2 for just the fixed effects, "Conditional" is the R^2 for everything.
r <- data.frame(r[,6])
colnames(r) <- names(model_df[j])
r$model_var <- "r^2"
r[,1] <- round(r[,1], 2)
coeff <- rbind(r,coeff)
coeff_list[[paste0("coeff_", names(model_df[j]))]] <- coeff
}
}
#INDIVIDUAL YEARS
} else if (j == i){
response <- "resist.value"
effects <- best_mod_full_year
#create all combinations of random / fixed effects
effects_comb <-
unlist( sapply( seq_len(length(effects)),
function(i) {
apply( combn(effects,i), 2, function(x) paste(x, collapse = "+"))
}))
var_comb <- expand.grid(response, effects_comb)
var_comb <- var_comb[grepl("1", var_comb$Var2), ] #only keep in fixed/random combos
formula_vec <- sprintf("%s ~ %s", var_comb$Var1, var_comb$Var2)
lmm_all <- lapply(formula_vec, function(x){
fit1 <- lmer(x, data = model_df[[j]], REML=FALSE,
control = lmerControl(optimizer ="Nelder_Mead"))
return(fit1)
})
names(lmm_all) <- formula_vec
var_aic <- aictab(lmm_all, second.ord=TRUE, sort=TRUE) #rank based on AICc
var_aic$Modnames <- as.character(var_aic$Modnames)
best_mod_traits$best_model[[i]] <- var_aic$Modnames[[1]]
for (z in seq(along = lmm_all)){
if (names(lmm_all[z]) == var_aic$Modnames[[1]]){
#run the best model alone with REML=TRUE
fit1 <- lmer(formula_vec[[z]], data = model_df[[j]], REML=TRUE,
control = lmerControl(optimizer ="Nelder_Mead"))
#get coefficients and put in table
coeff <- data.frame(coef(summary(fit1))[ , "Estimate"]) ##2
coeff[,2] <- rownames(coeff)
coeff[,1] <- round(coeff[,1], 3)
colnames(coeff) <- c(names(model_df[j]), "model_var")
#put r2 in table
r <- rsquared(fit1) #gives R^2 values for models. "Marginal" is the R^2 for just the fixed effects, "Conditional" is the R^2 for everything.
r <- data.frame(r[,6])
colnames(r) <- names(model_df[j])
r$model_var <- "r^2"
r[,1] <- round(r[,1], 2)
coeff <- rbind(r,coeff)
coeff_list[[paste0("coeff_", names(model_df[j]))]] <- coeff
}
}
}
}
}
View(var_aic)
##6a. test each variable individually for each drought scenario ####
sum_mod_traits <- data.frame(
"prediction" = c(1.1, 2.1, 2.2, 2.3, 2.4, 3.1, 3.2, 3.3, 3.4, 3.5),
"variable" = c("year", "dbh.ln.cm", "position_all",  "TWI.ln*height.ln.m", "rp", "PLA_dry_percent", "LMA_g_per_m2", "mean_TLP_Mpa", "WD_g_per_cm3"),
"variable_description" = c("drought.year", "ln[DBH]", "ln[height]", "crown.position", "ln[topographic.wetness.index]", "ring.porosity", "percent.leaf.area", "leaf.mass.area", "mean.turgor.loss.point", "wood.density"),
"null_model" =
c("resist.value ~ (1|sp/tree)",
"resist.value ~ year+(1|sp/tree)",
"resist.value ~ year+(1|sp/tree)",
"resist.value ~ height.ln.m+year+(1|sp/tree)",
"resist.value ~ height.ln.m+year+(1|sp/tree)",
"resist.value ~ height.ln.m+year+(1|sp/tree)",
"resist.value ~ height.ln.m+year+(1|sp/tree)",
"resist.value ~ height.ln.m+year+(1|sp/tree)",
"resist.value ~ height.ln.m+year+(1|sp/tree)",
"resist.value ~ height.ln.m+year+(1|sp/tree)"),
"tested_model" = NA)
##6a. test each variable individually for each drought scenario ####
sum_mod_traits <- data.frame(
"prediction" = c(1.1, 2.1, 2.2, 2.3, 2.4, 3.1, 3.2, 3.3, 3.4, 3.5),
"variable" = c("year", "dbh.ln.cm", "position_all",  "TWI.ln*height.ln.m", "rp", "PLA_dry_percent", "LMA_g_per_m2", "mean_TLP_Mpa", "WD_g_per_cm3"),
"variable_description" = c("drought.year", "ln[DBH]", "crown.position", "ln[topographic.wetness.index] and ln[height.m]", "ring.porosity", "percent.leaf.area", "leaf.mass.area", "mean.turgor.loss.point", "wood.density"),
"null_model" =
c("resist.value ~ (1|sp/tree)",
"resist.value ~ year+(1|sp/tree)",
"resist.value ~ year+(1|sp/tree)",
"resist.value ~ height.ln.m+year+(1|sp/tree)",
"resist.value ~ height.ln.m+year+(1|sp/tree)",
"resist.value ~ height.ln.m+year+(1|sp/tree)",
"resist.value ~ height.ln.m+year+(1|sp/tree)",
"resist.value ~ height.ln.m+year+(1|sp/tree)",
"resist.value ~ height.ln.m+year+(1|sp/tree)",),
"tested_model" = NA)
##6a. test each variable individually for each drought scenario ####
sum_mod_traits <- data.frame(
"prediction" = c(1.1, 2.1, 2.2, 2.3, 2.4, 3.1, 3.2, 3.3, 3.4, 3.5),
"variable" = c("year", "dbh.ln.cm", "position_all",  "TWI.ln*height.ln.m", "rp", "PLA_dry_percent", "LMA_g_per_m2", "mean_TLP_Mpa", "WD_g_per_cm3"),
"variable_description" = c("drought.year", "ln[DBH]", "crown.position", "ln[topographic.wetness.index] and ln[height.m]", "ring.porosity", "percent.leaf.area", "leaf.mass.area", "mean.turgor.loss.point", "wood.density"),
"null_model" =
c("resist.value ~ (1|sp/tree)",
"resist.value ~ year+(1|sp/tree)",
"resist.value ~ year+(1|sp/tree)",
"resist.value ~ height.ln.m+year+(1|sp/tree)",
"resist.value ~ height.ln.m+year+(1|sp/tree)",
"resist.value ~ height.ln.m+year+(1|sp/tree)",
"resist.value ~ height.ln.m+year+(1|sp/tree)",
"resist.value ~ height.ln.m+year+(1|sp/tree)",
"resist.value ~ height.ln.m+year+(1|sp/tree)",
"resist.value ~ height.ln.m+year+(1|sp/tree)"),
"tested_model" = NA)
##6a. test each variable individually for each drought scenario ####
sum_mod_traits <- data.frame(
"prediction" = c(1.1, 2.1, 2.2, 2.4, 3.1, 3.2, 3.3, 3.4, 3.5),
"variable" = c("year", "dbh.ln.cm", "position_all",  "TWI.ln*height.ln.m", "rp", "PLA_dry_percent", "LMA_g_per_m2", "mean_TLP_Mpa", "WD_g_per_cm3"),
"variable_description" = c("drought.year", "ln[DBH]", "crown.position", "ln[topographic.wetness.index] and ln[height.m]", "ring.porosity", "percent.leaf.area", "leaf.mass.area", "mean.turgor.loss.point", "wood.density"),
"null_model" =
c("resist.value ~ (1|sp/tree)",
"resist.value ~ year+(1|sp/tree)",
"resist.value ~ year+(1|sp/tree)",
"resist.value ~ height.ln.m+year+(1|sp/tree)",
"resist.value ~ height.ln.m+year+(1|sp/tree)",
"resist.value ~ height.ln.m+year+(1|sp/tree)",
"resist.value ~ height.ln.m+year+(1|sp/tree)",
"resist.value ~ height.ln.m+year+(1|sp/tree)",
"resist.value ~ height.ln.m+year+(1|sp/tree)",
"resist.value ~ height.ln.m+year+(1|sp/tree)"),
"tested_model" = NA)
##6a. test each variable individually for each drought scenario ####
sum_mod_traits <- data.frame(
"prediction" = c(1.1, 2.1, 2.2, 2.4, 3.1, 3.2, 3.3, 3.4, 3.5),
"variable" = c("year", "dbh.ln.cm", "position_all",  "TWI.ln*height.ln.m", "rp", "PLA_dry_percent", "LMA_g_per_m2", "mean_TLP_Mpa", "WD_g_per_cm3"),
"variable_description" = c("drought.year", "ln[DBH]", "crown.position", "ln[topographic.wetness.index] and ln[height.m]", "ring.porosity", "percent.leaf.area", "leaf.mass.area", "mean.turgor.loss.point", "wood.density"),
"null_model" =
c("resist.value ~ (1|sp/tree)",
"resist.value ~ year+(1|sp/tree)",
"resist.value ~ year+(1|sp/tree)",
"resist.value ~ height.ln.m+year+(1|sp/tree)",
"resist.value ~ height.ln.m+year+(1|sp/tree)",
"resist.value ~ height.ln.m+year+(1|sp/tree)",
"resist.value ~ height.ln.m+year+(1|sp/tree)",
"resist.value ~ height.ln.m+year+(1|sp/tree)",
"resist.value ~ height.ln.m+year+(1|sp/tree)"),
"tested_model" = NA)
View(sum_mod_traits)
sum_mod_traits[, c("null_model_year", "tested_model_year", "dAIC_all", "coef_all", "coef_var_all", "dAIC_1964.1966", "coef_1964.1966", "coef_var_1964.1966", "dAIC_1977", "coef_1977", "coef_var_1977", "dAIC_1999", "coef_1999", "coef_var_1999")] <- NA
# change factor columns to character
sum_mod_traits <- sum_mod_traits %>% mutate_if(is.factor, as.character)
coeff_all <- NULL
for (i in seq_along(1:10)){
null_mod <- sum_mod_traits$null_model[[i]] #all years
var <- sum_mod_traits$variable[[i]]
#if the variable is in the null model, then take it out, otherwise add it in
sum_mod_traits$tested_model[[i]] <-
ifelse(grepl(var, null_mod),
gsub(paste0(var, "[[:punct:]]"), "", sum_mod_traits$null_model[[i]]),
paste0(null_mod, "+", var))
sum_mod_traits$null_model_year[[i]] <-
gsub("year\\+|/tree", "", sum_mod_traits$null_model[[i]])
sum_mod_traits$tested_model_year[[i]] <-
gsub("year\\+|/tree", "", sum_mod_traits$tested_model[[i]])
#obviously, the tested model of the "year" effect doesn't work over the individual years
if (i == 1){
sum_mod_traits$tested_model_year[[i]] <- sum_mod_traits$null_model_year[[i]]
}
test_mod <- sum_mod_traits$tested_model[[i]] #all years
test_mod_yr <- sum_mod_traits$tested_model_year[[i]] #individual years
null_mod_yr <- sum_mod_traits$null_model_year[[i]] #individual years
models <- c(null_mod, test_mod) #all years
models_yr <- c(null_mod_yr, test_mod_yr) #ndividual years
for (j in seq(along=model_df)){
for (h in seq(along=sum_mod_traits[,c(8,11,14,17)])){ #dAIC
column <- colnames(sum_mod_traits[,c(8,11,14,17)][h])
for (k in seq(along=sum_mod_traits[,c(9,12,15,18)])){ #coefficients direction
column_cof <- colnames(sum_mod_traits[,c(9,12,15,18)][h])
for (l in seq(along=sum_mod_traits[,c(10,13,16,19)])){ #coefficient values
column_cof_val <- colnames(sum_mod_traits[,c(10,13,16,19)][l])
#ALL YEARS
if(j == 1 & h == 1 & k == 1 & l == 1){
lmm_all <- lapply(models, function(x){
fit1 <- lmer(x, data = model_df[[j]], REML=FALSE,
control = lmerControl(optimizer ="Nelder_Mead"))
return(fit1)
})
names(lmm_all) <- models
var_aic <- aictab(lmm_all, second.ord=TRUE, sort=FALSE) #rank based on AICc
#put AIC value in table (#null - test)
sum_mod_traits[,column][[i]] <- var_aic$AICc[[1]] - var_aic$AICc[[2]]
sum_mod_traits[,column][[i]] <- round(sum_mod_traits[,column][[i]], 3)
for (z in seq(along = lmm_all)){
if (grepl(var, test_mod)){
if (names(lmm_all[z]) == test_mod){
coeff <- data.frame(coef(summary(lmm_all[[z]]))[ , "Estimate"]) ##2
coeff[,2] <- rownames(coeff)
colnames(coeff) <- c("value", "model_var")
coeff$value <- round(coeff$value, 3)
coeff$combo <- paste0(coeff$model_var, " (", coeff$value, ")")
coeff <- coeff[grepl(sum_mod_traits$variable[[i]], coeff$combo), ]
coeff_vec <- coeff$combo
#this rbind is to get a full df showing all coefficient values from the entire for-loop
coeff_all <- rbind(coeff_all, coeff)
#put coefficients in table
sum_mod_traits[,column_cof][[i]] <- ifelse(any(coeff$value < 0), "-", "+")
sum_mod_traits[,column_cof_val][[i]] <- paste(coeff_vec, collapse = ", ")
}
}
}
#INDIVIDUAL YEARS
} else if (j == h & h == k & k == l){
if(i == 1){
sum_mod_traits[,column][[i]] <- NA
sum_mod_traits[,column_cof][[i]] <- NA
sum_mod_traits[,column_cof_val][[i]] <- NA
}
lmm_all <- lapply(models_yr, function(x){
fit1 <- lmer(x, data = model_df[[j]], REML=FALSE,
control = lmerControl(optimizer ="Nelder_Mead"))
return(fit1)
})
names(lmm_all) <- models_yr
var_aic <- aictab(lmm_all, second.ord=TRUE, sort=FALSE) #rank based on AICc
#put AIC value in table (null - tested)
sum_mod_traits[,column][[i]] <- var_aic$AICc[[1]] - var_aic$AICc[[2]]
sum_mod_traits[,column][[i]] <- round(sum_mod_traits[,column][[i]], 3)
for (z in seq(along = lmm_all)){
if (grepl(var, test_mod_yr)){
if (names(lmm_all[z]) == test_mod_yr){
coeff <- data.frame(coef(summary(lmm_all[[z]]))[ , "Estimate"]) ##2
coeff[,2] <- rownames(coeff)
colnames(coeff) <- c("value", "model_var")
coeff$value <- round(coeff$value, 3)
coeff$combo <- paste0(coeff$model_var, " (", coeff$value, ")")
coeff <- coeff[grepl(sum_mod_traits$variable[[i]], coeff$combo), ]
coeff_vec <- coeff$combo
#this rbind is to get a full df showing all coefficient values from the entire for-loop
coeff_all <- rbind(coeff_all, coeff)
#put coefficients in table
sum_mod_traits[,column_cof][[i]] <- ifelse(any(coeff$value < 0), "-", "+")
sum_mod_traits[,column_cof_val][[i]] <- paste(coeff_vec, collapse = ", ")
}
}
}
}
}
}
}
}
}
View(sum_mod_traits)
write.csv(sum_mod_traits, "manuscript/tables_figures/tested_traits_all-TWIheight.csv", row.names=FALSE)
##6a. test each variable individually for each drought scenario ####
sum_mod_traits <- data.frame(
"prediction" = c(1.1, 2.1, 2.2, 2.3, 2.4, 3.1, 3.2, 3.3, 3.4, 3.5),
"variable" = c("year", "dbh.ln.cm", "height.ln.m", "position_all",  "TWI.ln", "rp", "PLA_dry_percent", "LMA_g_per_m2", "mean_TLP_Mpa", "WD_g_per_cm3"),
"variable_description" = c("drought.year", "ln[DBH]", "ln[height]", "crown.position", "ln[topographic.wetness.index]", "ring.porosity", "percent.leaf.area", "leaf.mass.area", "mean.turgor.loss.point", "wood.density"),
"null_model" =
c("resist.value ~ (1|sp/tree)",
"resist.value ~ year+(1|sp/tree)",
"resist.value ~ year+(1|sp/tree)",
"resist.value ~ height.ln.m+year+(1|sp/tree)",
"resist.value ~ height.ln.m+year+(1|sp/tree)",
"resist.value ~ height.ln.m+year+(1|sp/tree)",
"resist.value ~ height.ln.m+year+(1|sp/tree)",
"resist.value ~ height.ln.m+year+(1|sp/tree)",
"resist.value ~ height.ln.m+year+(1|sp/tree)",
"resist.value ~ height.ln.m+year+(1|sp/tree)"),
"tested_model" = NA)
sum_mod_traits[, c("null_model_year", "tested_model_year", "dAIC_all", "coef_all", "coef_var_all", "dAIC_1964.1966", "coef_1964.1966", "coef_var_1964.1966", "dAIC_1977", "coef_1977", "coef_var_1977", "dAIC_1999", "coef_1999", "coef_var_1999")] <- NA
# change factor columns to character
sum_mod_traits <- sum_mod_traits %>% mutate_if(is.factor, as.character)
coeff_all <- NULL
for (i in seq_along(1:10)){
null_mod <- sum_mod_traits$null_model[[i]] #all years
var <- sum_mod_traits$variable[[i]]
#if the variable is in the null model, then take it out, otherwise add it in
sum_mod_traits$tested_model[[i]] <-
ifelse(grepl(var, null_mod),
gsub(paste0(var, "[[:punct:]]"), "", sum_mod_traits$null_model[[i]]),
paste0(null_mod, "+", var))
sum_mod_traits$null_model_year[[i]] <-
gsub("year\\+|/tree", "", sum_mod_traits$null_model[[i]])
sum_mod_traits$tested_model_year[[i]] <-
gsub("year\\+|/tree", "", sum_mod_traits$tested_model[[i]])
#obviously, the tested model of the "year" effect doesn't work over the individual years
if (i == 1){
sum_mod_traits$tested_model_year[[i]] <- sum_mod_traits$null_model_year[[i]]
}
test_mod <- sum_mod_traits$tested_model[[i]] #all years
test_mod_yr <- sum_mod_traits$tested_model_year[[i]] #individual years
null_mod_yr <- sum_mod_traits$null_model_year[[i]] #individual years
models <- c(null_mod, test_mod) #all years
models_yr <- c(null_mod_yr, test_mod_yr) #ndividual years
for (j in seq(along=model_df)){
for (h in seq(along=sum_mod_traits[,c(8,11,14,17)])){ #dAIC
column <- colnames(sum_mod_traits[,c(8,11,14,17)][h])
for (k in seq(along=sum_mod_traits[,c(9,12,15,18)])){ #coefficients direction
column_cof <- colnames(sum_mod_traits[,c(9,12,15,18)][h])
for (l in seq(along=sum_mod_traits[,c(10,13,16,19)])){ #coefficient values
column_cof_val <- colnames(sum_mod_traits[,c(10,13,16,19)][l])
#ALL YEARS
if(j == 1 & h == 1 & k == 1 & l == 1){
lmm_all <- lapply(models, function(x){
fit1 <- lmer(x, data = model_df[[j]], REML=FALSE,
control = lmerControl(optimizer ="Nelder_Mead"))
return(fit1)
})
names(lmm_all) <- models
var_aic <- aictab(lmm_all, second.ord=TRUE, sort=FALSE) #rank based on AICc
#put AIC value in table (#null - test)
sum_mod_traits[,column][[i]] <- var_aic$AICc[[1]] - var_aic$AICc[[2]]
sum_mod_traits[,column][[i]] <- round(sum_mod_traits[,column][[i]], 3)
for (z in seq(along = lmm_all)){
if (grepl(var, test_mod)){
if (names(lmm_all[z]) == test_mod){
coeff <- data.frame(coef(summary(lmm_all[[z]]))[ , "Estimate"]) ##2
coeff[,2] <- rownames(coeff)
colnames(coeff) <- c("value", "model_var")
coeff$value <- round(coeff$value, 3)
coeff$combo <- paste0(coeff$model_var, " (", coeff$value, ")")
coeff <- coeff[grepl(sum_mod_traits$variable[[i]], coeff$combo), ]
coeff_vec <- coeff$combo
#this rbind is to get a full df showing all coefficient values from the entire for-loop
coeff_all <- rbind(coeff_all, coeff)
#put coefficients in table
sum_mod_traits[,column_cof][[i]] <- ifelse(any(coeff$value < 0), "-", "+")
sum_mod_traits[,column_cof_val][[i]] <- paste(coeff_vec, collapse = ", ")
}
}
}
#INDIVIDUAL YEARS
} else if (j == h & h == k & k == l){
if(i == 1){
sum_mod_traits[,column][[i]] <- NA
sum_mod_traits[,column_cof][[i]] <- NA
sum_mod_traits[,column_cof_val][[i]] <- NA
}
lmm_all <- lapply(models_yr, function(x){
fit1 <- lmer(x, data = model_df[[j]], REML=FALSE,
control = lmerControl(optimizer ="Nelder_Mead"))
return(fit1)
})
names(lmm_all) <- models_yr
var_aic <- aictab(lmm_all, second.ord=TRUE, sort=FALSE) #rank based on AICc
#put AIC value in table (null - tested)
sum_mod_traits[,column][[i]] <- var_aic$AICc[[1]] - var_aic$AICc[[2]]
sum_mod_traits[,column][[i]] <- round(sum_mod_traits[,column][[i]], 3)
for (z in seq(along = lmm_all)){
if (grepl(var, test_mod_yr)){
if (names(lmm_all[z]) == test_mod_yr){
coeff <- data.frame(coef(summary(lmm_all[[z]]))[ , "Estimate"]) ##2
coeff[,2] <- rownames(coeff)
colnames(coeff) <- c("value", "model_var")
coeff$value <- round(coeff$value, 3)
coeff$combo <- paste0(coeff$model_var, " (", coeff$value, ")")
coeff <- coeff[grepl(sum_mod_traits$variable[[i]], coeff$combo), ]
coeff_vec <- coeff$combo
#this rbind is to get a full df showing all coefficient values from the entire for-loop
coeff_all <- rbind(coeff_all, coeff)
#put coefficients in table
sum_mod_traits[,column_cof][[i]] <- ifelse(any(coeff$value < 0), "-", "+")
sum_mod_traits[,column_cof_val][[i]] <- paste(coeff_vec, collapse = ", ")
}
}
}
}
}
}
}
}
}
cand_full <- NULL
for (i in seq(along=sum_mod_traits[,c(8,11,14,17)])){
column <- colnames(sum_mod_traits[,c(8,11,14,17)])[[i]]
cand <- sum_mod_traits[sum_mod_traits[,column] > 2 &
!sum_mod_traits$variable %in% c("dbh.ln.cm"), c(1:3)]
cand$top_model <- c("all", "1966", "1977", "1999")[[i]]
cand_full <- rbind(cand_full, cand)
cand_full <- cand_full[order(cand_full$prediction), ]
}
##6b. determine the best full model ####
best_mod_traits <- data.frame("best_model" = NA,
"scenario" = c("all droughts", "1964-1966", "1977", "1999")
)
best_mod_full <- c(unique(cand_full$variable), "(1|sp/tree)")
best_mod_full_year <- gsub("/tree", "", best_mod_full)
best_mod_full_year <- best_mod_full_year[!best_mod_full_year %in% c("year")]
#this loop determines the best full model for each scenario, using the traits from cand_full in #6a, and populates the table created above
coeff_list <- list()
for (i in seq(along=c(1:4))){
for (j in seq(along=model_df)){
#ALL YEARS
if(j == 1 & i == 1){
response <- "resist.value"
effects <- best_mod_full
#create all combinations of random / fixed effects
effects_comb <-
unlist(sapply(seq_len(length(effects)), function(i) {
apply( combn(effects,i), 2, function(x) paste(x, collapse = "+"))
}))
# pair response with effect and sub out combinations that don't include random effects
#in general, if two variables are >70% correlated, you can toss one of them without significantly affecting the results
var_comb <- expand.grid(response, effects_comb)
var_comb <- var_comb[grepl("1", var_comb$Var2), ] #only keep in fixed/random combos
# formulas for all combinations. $Var1 is the response, and $Var2 is the effect
# for good stats, you should have no more total parameters than 1/10th the number of observations in your dataset
formula_vec <- sprintf("%s ~ %s", var_comb$Var1, var_comb$Var2)
lmm_all <- lapply(formula_vec, function(x){
fit1 <- lmer(x, data = model_df[[j]], REML=FALSE,
control = lmerControl(optimizer ="Nelder_Mead"))
return(fit1)
})
names(lmm_all) <- formula_vec
var_aic <- aictab(lmm_all, second.ord=TRUE, sort=TRUE) #rank based on AICc
var_aic$Modnames <- as.character(var_aic$Modnames)
best_mod_traits$best_model[[i]] <- var_aic$Modnames[[1]]
for (z in seq(along = lmm_all)){
if (names(lmm_all[z]) == var_aic$Modnames[[1]]){
#run the best model alone with REML=TRUE
fit1 <- lmer(formula_vec[[z]], data = model_df[[j]], REML=TRUE,
control = lmerControl(optimizer ="Nelder_Mead"))
#get coefficients and put in table
coeff <- data.frame(coef(summary(fit1))[ , "Estimate"]) ##2
coeff[,2] <- rownames(coeff)
coeff[,1] <- round(coeff[,1], 3)
colnames(coeff) <- c(names(model_df[j]), "model_var")
#put r2 in table
r <- rsquared(fit1) #gives R^2 values for models. "Marginal" is the R^2 for just the fixed effects, "Conditional" is the R^2 for everything.
r <- data.frame(r[,6])
colnames(r) <- names(model_df[j])
r$model_var <- "r^2"
r[,1] <- round(r[,1], 2)
coeff <- rbind(r,coeff)
coeff_list[[paste0("coeff_", names(model_df[j]))]] <- coeff
}
}
#INDIVIDUAL YEARS
} else if (j == i){
response <- "resist.value"
effects <- best_mod_full_year
#create all combinations of random / fixed effects
effects_comb <-
unlist( sapply( seq_len(length(effects)),
function(i) {
apply( combn(effects,i), 2, function(x) paste(x, collapse = "+"))
}))
var_comb <- expand.grid(response, effects_comb)
var_comb <- var_comb[grepl("1", var_comb$Var2), ] #only keep in fixed/random combos
formula_vec <- sprintf("%s ~ %s", var_comb$Var1, var_comb$Var2)
lmm_all <- lapply(formula_vec, function(x){
fit1 <- lmer(x, data = model_df[[j]], REML=FALSE,
control = lmerControl(optimizer ="Nelder_Mead"))
return(fit1)
})
names(lmm_all) <- formula_vec
var_aic <- aictab(lmm_all, second.ord=TRUE, sort=TRUE) #rank based on AICc
var_aic$Modnames <- as.character(var_aic$Modnames)
best_mod_traits$best_model[[i]] <- var_aic$Modnames[[1]]
for (z in seq(along = lmm_all)){
if (names(lmm_all[z]) == var_aic$Modnames[[1]]){
#run the best model alone with REML=TRUE
fit1 <- lmer(formula_vec[[z]], data = model_df[[j]], REML=TRUE,
control = lmerControl(optimizer ="Nelder_Mead"))
#get coefficients and put in table
coeff <- data.frame(coef(summary(fit1))[ , "Estimate"]) ##2
coeff[,2] <- rownames(coeff)
coeff[,1] <- round(coeff[,1], 3)
colnames(coeff) <- c(names(model_df[j]), "model_var")
#put r2 in table
r <- rsquared(fit1) #gives R^2 values for models. "Marginal" is the R^2 for just the fixed effects, "Conditional" is the R^2 for everything.
r <- data.frame(r[,6])
colnames(r) <- names(model_df[j])
r$model_var <- "r^2"
r[,1] <- round(r[,1], 2)
coeff <- rbind(r,coeff)
coeff_list[[paste0("coeff_", names(model_df[j]))]] <- coeff
}
}
}
}
}
View(var_aic)
View(lmm_all)
lmm_all[1]
summary(lmm_all[1])
summary(lmm_all[[1]])
summary(lmm_all[[2]])
##6c. standalone code to get coefficients and r2 ####
##(for paper, should do ONLY w/REML=TRUE)
best <- lmm_all[[58]]
r <- rsquared(best) #gives R^2 values for models. "Marginal" is the R^2 for just the fixed effects, "Conditional" is the R^2 for everything.
View(r)
