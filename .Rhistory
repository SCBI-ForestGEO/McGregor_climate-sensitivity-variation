coeff$model_var <- gsub("ring", "", coeff$model_var)
coeff$model_var <- gsub("height", "ht_nat_log", coeff$model_var)
} else if (h == 12){
coeff$model_var <- gsub("subcanopy", "", coeff$model_var)
coeff$model_var <- gsub("ring", "", coeff$model_var)
coeff$model_var <- gsub("height", "ht_nat_log", coeff$model_var)
full_mod <- var_aic[1:10, c(1,4)]
full_mod[11,] <- var_aic_sub[,c(1,4)]
colnames(full_mod) <- c("Modnames_all_years", "dAIC_all_years")
}
for (y in seq(along = coeff$model_var)){ ##4
same <- coeff$model_var[[y]]
if(grepl(same, summary_mod_vars_all[[h]])){
coeff_sub <- coeff[coeff$model_var == same, ]
}
#update the coefficient value
summary_models[,9][[h]] <- ifelse(h == 12, NA, coeff_sub$value)
#update the table. If the sign conventions of the coefficient and the predicted response do not match, assign NA.
if (h!=12){
summary_models[,8][[h]] <- ifelse(
(coeff_sub$value <0 & summary_models$response_predict[[h]] <0) |
(coeff_sub$value >0 & summary_models$response_predict[[h]] >0),
summary_models[,8][[h]], NA)
}
if(h==12){
coeff <- coeff[-1,]
coeff_max <- coeff[coeff$value == max(coeff$value), ]
summary_models[,17][[h]] <- coeff_max$model_var
}
else if (i == 2) {
#isolate the AIC values of the target (sub) and null models, then math
var_aic_sub <- var_aic[var_aic$Modnames == summary_mod_vars_sep[[h]], ]
var_aic_null <- var_aic[var_aic$Modnames == summary_mod_null_sep[[h]], ]
summary_models[,10][[h]] <- round(var_aic_null$Delta_AICc - var_aic_sub$Delta_AICc, 2)
var_aic_sub$Modnames <- as.character(var_aic_sub$Modnames)
#this loop says for the models run for this iteration of h, take the model output represented by the target model (1). Get the coefficients and put in df (2). Rename variables such that you only pull what you need (3) and extract the coefficient for the variable you want (4).
for (z in seq(along = lmm_all)){
if (z == rownames(var_aic_sub)){ ##1
coeff <- data.frame(coef(summary(lmm_all[[z]]))[ , "Estimate"]) ##2
coeff[,2] <- rownames(coeff)
colnames(coeff) <- c("value", "model_var")
if (h == 3){ ##3
coeff$model_var <- gsub("subcanopy", "", coeff$model_var)
} else if (h == 4){
coeff$model_var <- gsub("subcanopy", "", coeff$model_var)
coeff$model_var <- gsub("height", "ht_nat_log", coeff$model_var)
} else if (h %in% 5:10){
coeff$model_var <- gsub("height", "ht_nat_log", coeff$model_var)
} else if (h == 11){
coeff$model_var <- gsub("ring", "", coeff$model_var)
coeff$model_var <- gsub("height", "ht_nat_log", coeff$model_var)
} else if (h == 12){
coeff$model_var <- gsub("subcanopy", "", coeff$model_var)
coeff$model_var <- gsub("ring", "", coeff$model_var)
coeff$model_var <- gsub("height", "ht_nat_log", coeff$model_var)
full_mod_1966 <- var_aic[1:10, c(1,4)]
full_mod_1966[11,] <- var_aic_sub[,c(1,4)]
colnames(full_mod_1966) <- c("Modnames_1966", "dAIC_1966")
}
for (y in seq(along = coeff$model_var)){ ##4
same <- coeff$model_var[[y]]
if(grepl(same, summary_mod_vars_all[[h]])){
coeff_sub <- coeff[coeff$model_var == same, ]
}
#update the coefficient value
summary_models[,11][[h]] <- ifelse(h == 12, NA, coeff_sub$value)
#update the table. If the sign conventions of the coefficient and the predicted response do not match, assign NA.
if (h!=12){
summary_models[,10][[h]] <- ifelse(
(coeff_sub$value <0 & summary_models$response_predict[[h]] <0) |
(coeff_sub$value >0 & summary_models$response_predict[[h]] >0),
summary_models[,10][[h]], NA)
}
if(h==12){
coeff <- coeff[-1,]
coeff_max <- coeff[coeff$value == max(coeff$value), ]
summary_models[,18][[h]] <- coeff_max$model_var
}
else if (i == 3){
#isolate the AIC values of the target (sub) and null models, then math
var_aic_sub <- var_aic[var_aic$Modnames == summary_mod_vars_sep[[h]], ]
var_aic_null <- var_aic[var_aic$Modnames == summary_mod_null_sep[[h]], ]
summary_models[,12][[h]] <- round(var_aic_null$Delta_AICc - var_aic_sub$Delta_AICc, 2)
var_aic_sub$Modnames <- as.character(var_aic_sub$Modnames)
#this loop says for the models run for this iteration of h, take the model output represented by the target model (1). Get the coefficients and put in df (2). Rename variables such that you only pull what you need (3) and extract the coefficient for the variable you want (4).
for (z in seq(along = lmm_all)){
if (z == rownames(var_aic_sub)){ ##1
coeff <- data.frame(coef(summary(lmm_all[[z]]))[ , "Estimate"]) ##2
coeff[,2] <- rownames(coeff)
colnames(coeff) <- c("value", "model_var")
if (h == 3){ ##3
coeff$model_var <- gsub("subcanopy", "", coeff$model_var)
} else if (h == 4){
coeff$model_var <- gsub("subcanopy", "", coeff$model_var)
coeff$model_var <- gsub("height", "ht_nat_log", coeff$model_var)
} else if (h %in% 5:10){
coeff$model_var <- gsub("height", "ht_nat_log", coeff$model_var)
} else if (h == 11){
coeff$model_var <- gsub("ring", "", coeff$model_var)
coeff$model_var <- gsub("height", "ht_nat_log", coeff$model_var)
} else if (h == 12){
coeff$model_var <- gsub("subcanopy", "", coeff$model_var)
coeff$model_var <- gsub("ring", "", coeff$model_var)
coeff$model_var <- gsub("height", "ht_nat_log", coeff$model_var)
full_mod_1977 <- var_aic[1:10, c(1,4)]
full_mod_1977[11,] <- var_aic_sub[,c(1,4)]
colnames(full_mod_1977) <- c("Modnames_1977", "dAIC_1977")
}
for (y in seq(along = coeff$model_var)){ ##4
same <- coeff$model_var[[y]]
if(grepl(same, summary_mod_vars_all[[h]])){
coeff_sub <- coeff[coeff$model_var == same, ]
}
#update the coefficient value
summary_models[,13][[h]] <- ifelse(h == 12, NA, coeff_sub$value)
#update the table. If the sign conventions of the coefficient and the predicted response do not match, assign NA.
if(h!=12){
summary_models[,12][[h]] <- ifelse(
(coeff_sub$value <0 & summary_models$response_predict[[h]] <0) |
(coeff_sub$value >0 & summary_models$response_predict[[h]] >0),
summary_models[,12][[h]], NA)
}
if(h==12){
coeff <- coeff[-1,]
coeff_max <- coeff[coeff$value == max(coeff$value), ]
summary_models[,19][[h]] <- coeff_max$model_var
}
else if (i == 4){
#isolate the AIC values of the target (sub) and null models, then math
var_aic_sub <- var_aic[var_aic$Modnames == summary_mod_vars_sep[[h]], ]
var_aic_null <- var_aic[var_aic$Modnames == summary_mod_null_sep[[h]], ]
summary_models[,14][[h]] <- round(var_aic_null$Delta_AICc - var_aic_sub$Delta_AICc, 2)
var_aic_sub$Modnames <- as.character(var_aic_sub$Modnames)
#this loop says for the models run for this iteration of h, take the model output represented by the target model (1). Get the coefficients and put in df (2). Rename variables such that you only pull what you need (3) and extract the coefficient for the variable you want (4).
for (z in seq(along = lmm_all)){
if (z == rownames(var_aic_sub)){ ##1
coeff <- data.frame(coef(summary(lmm_all[[z]]))[ , "Estimate"]) ##2
coeff[,2] <- rownames(coeff)
colnames(coeff) <- c("value", "model_var")
if (h == 3){ ##3
coeff$model_var <- gsub("subcanopy", "", coeff$model_var)
} else if (h == 4){
coeff$model_var <- gsub("subcanopy", "", coeff$model_var)
coeff$model_var <- gsub("height", "ht_nat_log", coeff$model_var)
} else if (h %in% 5:10){
coeff$model_var <- gsub("height", "ht_nat_log", coeff$model_var)
} else if (h == 11){
coeff$model_var <- gsub("ring", "", coeff$model_var)
coeff$model_var <- gsub("height", "ht_nat_log", coeff$model_var)
} else if (h == 12){
coeff$model_var <- gsub("subcanopy", "", coeff$model_var)
coeff$model_var <- gsub("ring", "", coeff$model_var)
coeff$model_var <- gsub("height", "ht_nat_log", coeff$model_var)
full_mod_1999 <- var_aic[1:10, c(1,4)]
full_mod_1999[11,] <- var_aic_sub[,c(1,4)]
colnames(full_mod_1999) <- c("Modnames_1999", "dAIC_1999")
full_mod_all <- cbind(full_mod, full_mod_1966, full_mod_1977, full_mod_1999)
}
for (y in seq(along = coeff$model_var)){ ##4
same <- coeff$model_var[[y]]
if(grepl(same, summary_mod_vars_all[[h]])){
coeff_sub <- coeff[coeff$model_var == same, ]
}
#update the coefficient value
summary_models[,15][[h]] <- ifelse(h == 12, NA, coeff_sub$value)
#update the table. If the sign conventions of the coefficient and the predicted response do not match, assign NA.
if (h!=12){
summary_models[,14][[h]] <- ifelse(
(coeff_sub$value <0 & summary_models$response_predict[[h]] <0) |
(coeff_sub$value >0 & summary_models$response_predict[[h]] >0),
summary_models[,14][[h]], NA)
}
if (h==12){
coeff <- coeff[-1,]
coeff_max <- coeff[coeff$value == max(coeff$value), ]
summary_models[,20][[h]] <- coeff_max$model_var
}
#csv has a 1 in the title to make sure any notes in current file are not overwritten
write.csv(summary_models, "manuscript/results1.csv", row.names=FALSE)
write.csv(full_mod_all, "manuscript/full_models.csv", row.names=FALSE)
##table looking at only full model over all years ####
##we ran all variables (aka a full model) against all years combined and found that position, height*elev, tlp, and rp were the variables in the best model. Using this knowledge, here we created a dfferent version of the original table.
summary_models <- data.frame(
"prediction" = c("1.1", "1.2b", "1.2c1, 1.3a1", "1.2c2", "1.3b1", "1.2c2,1.3b1", "2.1", "2.2"),
"model_vars_all_years" =
c("resist.value ~ position+height_ln+elev_m+height_ln*elev_m+tlp+rp+year+(1|sp/tree)",
"resist.value ~ position+height_ln+elev_m+height_ln*elev_m+tlp+rp+year+(1|sp/tree)",
"resist.value ~ position+height_ln+elev_m+tlp+rp+year+(1|sp/tree)",
"resist.value ~ position+height_ln+elev_m+height_ln*elev_m+tlp+rp+year+(1|sp/tree)",
"resist.value ~ position+height_ln+elev_m+height_ln*elev_m+tlp+rp+year+(1|sp/tree)"),
"null_model_all_years" =
c("resist.value ~ position+elev_m+tlp+rp+year+(1|sp/tree)",
"resist.value ~ height_ln*elev_m+tlp+rp+year+(1|sp/tree)",
"resist.value ~ position+height_ln+tlp+rp+year+(1|sp/tree)",
"resist.value ~ position+height_ln+elev_m+tlp+rp+year+(1|sp/tree)",
"resist.value ~ position+height_ln+tlp+rp+year+(1|sp/tree)",
"resist.value ~ position+height_ln*elev_m+rp+year+(1|sp/tree)",
"resist.value ~ position+height_ln*elev_m+tlp+year+(1|sp/tree)"),
"response_predict" = c(1, 1, -1, 1, -1, 1, -1, 1),
"response_sign" = c("+", "canopy<subcanopy", "-", "+", "-", "+", "-", "ring>diffuse"),
"dAIC_all_years" = NA,
"coef_all_years" = NA,
"coef_var" = NA,
"coef_all_big" = NA,
"notes" = "")
# change factor columns to character
summary_models %>% mutate_if(is.factor, as.character) -> summary_models
#define vectors to be used in loop
summary_mod_vars_all <- summary_models$model_vars_all_years
summary_mod_null_all <- summary_models$null_model_all_years
##this loop goes through each mix of effects from each prediction (nrow(summary_models)), and runs those models for the full years. it calculates dAIC (AIC of model with variable defined in model_vars columns minus the AIC of the null model) and the coefficients before putting them in the table created above.
for (i in seq_along(model_df)){
for (h in seq(along=summary_mod_vars_all)){
if (i==1){
#structure of creating the model strings come from 6a above.
response <- gsub(" ~.*", "", summary_mod_vars_all[[h]])
effects <- unlist(strsplit(summary_mod_vars_all[[h]], "\\+|~ "))[-1]
#create all combinations of random / fixed effects
effects_comb <-
unlist( sapply( seq_len(length(effects)),
function(i) {
apply( combn(effects,i), 2, function(x) paste(x, collapse = "+"))
}))
#make table
var_comb <- expand.grid(response, effects_comb)
var_comb <- var_comb[grepl("1", var_comb$Var2), ] #only keep in fixed/random combos
var_comb <- var_comb[grepl("year", var_comb$Var2), ] #keep year in for drought sake
}
#formulas for all combinations.
formula_vec <- sprintf("%s ~ %s", var_comb$Var1, var_comb$Var2)
# create list of model outputs
lmm_all <- lapply(formula_vec, function(x){
fit1 <- lmer(x, data = model_df[[i]], REML=FALSE,
control = lmerControl(optimizer ="Nelder_Mead"))
return(fit1)
})
names(lmm_all) <- formula_vec
var_aic <- aictab(lmm_all, second.ord=TRUE, sort=TRUE) #rank based on AICc
r <- rsquared(lmm_all) #gives R^2 values for models. "Marginal" is the R^2 for just the fixed effects, "Conditional" is the R^2 for everything.
#fill in table
if(i == 1){
#isolate the AIC values of the target (sub) and null models, then math
var_aic_sub <- var_aic[var_aic$Modnames == summary_mod_vars_all[[h]], ]
var_aic_null <- var_aic[var_aic$Modnames == summary_mod_null_all[[h]], ]
summary_models[,6][[h]] <- round(var_aic_null$Delta_AICc - var_aic_sub$Delta_AICc, 2)
var_aic_sub$Modnames <- as.character(var_aic_sub$Modnames)
## get coefficients and put in table
for (z in seq(along = lmm_all)){
if (z == rownames(var_aic_sub)){ ##1
coeff <- data.frame(coef(summary(lmm_all[[z]]))[ , "Estimate"]) ##2
coeff[,2] <- rownames(coeff)
colnames(coeff) <- c("value", "model_var")
if (h == 1){
for (y in seq(along = coeff$model_var)){ ##4
same <- coeff$model_var[[y]]
if(same == "height_ln"){
coeff_sub <- coeff[coeff$model_var == same, ]
summary_models[,8][[h]] <- same
}
else if (h == 2){
for (y in seq(along = coeff$model_var)){ ##4
same <- coeff$model_var[[y]]
if(same == "positionsubcanopy"){
coeff_sub <- coeff[coeff$model_var == same, ]
summary_models[,8][[h]] <- same
}
else if (h == 3 |h == 6){
for (y in seq(along = coeff$model_var)){ ##4
same <- coeff$model_var[[y]]
if(same == "elev_m"){
coeff_sub <- coeff[coeff$model_var == same, ]
summary_models[,8][[h]] <- same
}
else if (h == 4 |h == 5){
for (y in seq(along = coeff$model_var)){ ##4
same <- coeff$model_var[[y]]
if(same == "height_ln:elev_m"){
coeff_sub <- coeff[coeff$model_var == same, ]
summary_models[,8][[h]] <- same
}
else if (h == 7){
for (y in seq(along = coeff$model_var)){ ##4
same <- coeff$model_var[[y]]
if(same == "tlp"){
coeff_sub <- coeff[coeff$model_var == same, ]
summary_models[,8][[h]] <- same
}
else if (h == 8){
for (y in seq(along = coeff$model_var)){ ##4
same <- coeff$model_var[[y]]
if(same == "rpring"){
coeff_sub <- coeff[coeff$model_var == same, ]
summary_models[,8][[h]] <- same
}
#update the coefficient value
summary_models[,7][[h]] <- coeff_sub$value
#update the table. If the sign conventions of the coefficient and the predicted response do not match, assign NA.
# summary_models[,6][[h]] <- ifelse(
#   (coeff_sub$value <0 & summary_models$response_predict[[h]] <0) |
#     (coeff_sub$value >0 & summary_models$response_predict[[h]] >0),
#   summary_models[,6][[h]], NA)
coeff <- coeff[-1,]
coeff_max <- coeff[coeff$value == max(coeff$value), ]
summary_models[,9][[h]] <- coeff_max$model_var
}
View(summary_models)
library(BIEN)
?BIEN
vignette("BIEN")
BIEN_list_all
lirio <- BIEN_ranges_species("Liriodendron_tulipifera")
BIEN_ranges_species("Liriodendron_tulipifera")
response <- resist.value
effects <- c("position", "tlp", "rp", "elev_m", "dbh_ln", "height_ln", "year", "(1|sp/tree)")
#create all combinations of random / fixed effects
effects_comb <-
unlist( sapply( seq_len(length(effects)),
function(i) {
apply( combn(effects,i), 2, function(x) paste(x, collapse = "+"))
}))
# pair response with effect and sub out combinations that don't include random effects
#in general, if two variables are >70% correlated, you can toss one of them without significantly affecting the results
var_comb <- expand.grid(response, effects_comb)
var_comb <- var_comb[grepl("1", var_comb$Var2), ] #only keep in fixed/random combos
var_comb <- var_comb[grepl("year", var_comb$Var2), ] #keep year in for drought sake
# formulas for all combinations. $Var1 is the response, and $Var2 is the effect
# for good stats, you should have no more total parameters than 1/10th the number of observations in your dataset
formula_vec <- sprintf("%s ~ %s", var_comb$Var1, var_comb$Var2)
# create list of model outputs
lmm_all <- lapply(formula_vec, function(x){
fit1 <- lmer(x, data = model_df[[i]], REML=FALSE,
control = lmerControl(optimizer ="Nelder_Mead"))
return(fit1)
})
names(lmm_all) <- formula_vec
var_aic <- aictab(lmm_all, second.ord=TRUE, sort=TRUE) #rank based on AICc
r <- rsquared(lmm_all) #gives R^2 values for models. "Marginal" is the R^2 for just the fixed effects, "Conditional" is the R^2 for everything.
response <- resist.value
effects <- c("position", "tlp", "rp", "elev_m", "dbh_ln", "height_ln", "year", "(1|sp/tree)")
#create all combinations of random / fixed effects
effects_comb <-
unlist( sapply( seq_len(length(effects)),
function(i) {
apply( combn(effects,i), 2, function(x) paste(x, collapse = "+"))
}))
# pair response with effect and sub out combinations that don't include random effects
#in general, if two variables are >70% correlated, you can toss one of them without significantly affecting the results
var_comb <- expand.grid(response, effects_comb)
var_comb <- var_comb[grepl("1", var_comb$Var2), ] #only keep in fixed/random combos
var_comb <- var_comb[grepl("year", var_comb$Var2), ] #keep year in for drought sake
# formulas for all combinations. $Var1 is the response, and $Var2 is the effect
# for good stats, you should have no more total parameters than 1/10th the number of observations in your dataset
formula_vec <- sprintf("%s ~ %s", var_comb$Var1, var_comb$Var2)
# create list of model outputs
lmm_all <- lapply(formula_vec, function(x){
fit1 <- lmer(x, data = trees_all, REML=FALSE,
control = lmerControl(optimizer ="Nelder_Mead"))
return(fit1)
})
names(lmm_all) <- formula_vec
var_aic <- aictab(lmm_all, second.ord=TRUE, sort=TRUE) #rank based on AICc
r <- rsquared(lmm_all) #gives R^2 values for models. "Marginal" is the R^2 for just the fixed effects, "Conditional" is the R^2 for everything.
response <- "resist.value"
effects <- c("position", "tlp", "rp", "elev_m", "dbh_ln", "height_ln", "year", "(1|sp/tree)")
#create all combinations of random / fixed effects
effects_comb <-
unlist( sapply( seq_len(length(effects)),
function(i) {
apply( combn(effects,i), 2, function(x) paste(x, collapse = "+"))
}))
# pair response with effect and sub out combinations that don't include random effects
#in general, if two variables are >70% correlated, you can toss one of them without significantly affecting the results
var_comb <- expand.grid(response, effects_comb)
var_comb <- var_comb[grepl("1", var_comb$Var2), ] #only keep in fixed/random combos
var_comb <- var_comb[grepl("year", var_comb$Var2), ] #keep year in for drought sake
# formulas for all combinations. $Var1 is the response, and $Var2 is the effect
# for good stats, you should have no more total parameters than 1/10th the number of observations in your dataset
formula_vec <- sprintf("%s ~ %s", var_comb$Var1, var_comb$Var2)
# create list of model outputs
lmm_all <- lapply(formula_vec, function(x){
fit1 <- lmer(x, data = trees_all, REML=FALSE,
control = lmerControl(optimizer ="Nelder_Mead"))
return(fit1)
})
names(lmm_all) <- formula_vec
var_aic <- aictab(lmm_all, second.ord=TRUE, sort=TRUE) #rank based on AICc
r <- rsquared(lmm_all) #gives R^2 values for models. "Marginal" is the R^2 for just the fixed effects, "Conditional" is the R^2 for everything.
View(var_aic)
##6aii. coefficients ####
best <- lmm_all[[59]]
coef(summary(best))[ , "Estimate"]
response <- "resist.value"
effects <- c("position", "tlp", "rp", "elev_m", "dbh_ln", "height", "year", "(1|sp/tree)")
#create all combinations of random / fixed effects
effects_comb <-
unlist( sapply( seq_len(length(effects)),
function(i) {
apply( combn(effects,i), 2, function(x) paste(x, collapse = "+"))
}))
# pair response with effect and sub out combinations that don't include random effects
#in general, if two variables are >70% correlated, you can toss one of them without significantly affecting the results
var_comb <- expand.grid(response, effects_comb)
var_comb <- var_comb[grepl("1", var_comb$Var2), ] #only keep in fixed/random combos
var_comb <- var_comb[grepl("year", var_comb$Var2), ] #keep year in for drought sake
# formulas for all combinations. $Var1 is the response, and $Var2 is the effect
# for good stats, you should have no more total parameters than 1/10th the number of observations in your dataset
formula_vec <- sprintf("%s ~ %s", var_comb$Var1, var_comb$Var2)
# create list of model outputs
lmm_all <- lapply(formula_vec, function(x){
fit1 <- lmer(x, data = trees_all, REML=FALSE,
control = lmerControl(optimizer ="Nelder_Mead"))
return(fit1)
})
names(lmm_all) <- formula_vec
var_aic <- aictab(lmm_all, second.ord=TRUE, sort=TRUE) #rank based on AICc
r <- rsquared(lmm_all) #gives R^2 values for models. "Marginal" is the R^2 for just the fixed effects, "Conditional" is the R^2 for everything.
View(trees_all)
?`SciViews-package`
log(10)
ln(10)
trees_all$height <- exp(trees_all$height_ln)
View(trees_all)
response <- "resist.value"
effects <- c("position", "tlp", "rp", "elev_m", "dbh_ln", "height", "year", "(1|sp/tree)")
#create all combinations of random / fixed effects
effects_comb <-
unlist( sapply( seq_len(length(effects)),
function(i) {
apply( combn(effects,i), 2, function(x) paste(x, collapse = "+"))
}))
# pair response with effect and sub out combinations that don't include random effects
#in general, if two variables are >70% correlated, you can toss one of them without significantly affecting the results
var_comb <- expand.grid(response, effects_comb)
var_comb <- var_comb[grepl("1", var_comb$Var2), ] #only keep in fixed/random combos
var_comb <- var_comb[grepl("year", var_comb$Var2), ] #keep year in for drought sake
# formulas for all combinations. $Var1 is the response, and $Var2 is the effect
# for good stats, you should have no more total parameters than 1/10th the number of observations in your dataset
formula_vec <- sprintf("%s ~ %s", var_comb$Var1, var_comb$Var2)
# create list of model outputs
lmm_all <- lapply(formula_vec, function(x){
fit1 <- lmer(x, data = trees_all, REML=FALSE,
control = lmerControl(optimizer ="Nelder_Mead"))
return(fit1)
})
names(lmm_all) <- formula_vec
var_aic <- aictab(lmm_all, second.ord=TRUE, sort=TRUE) #rank based on AICc
r <- rsquared(lmm_all) #gives R^2 values for models. "Marginal" is the R^2 for just the fixed effects, "Conditional" is the R^2 for everything.
View(var_aic)
##6aii. coefficients ####
best <- lmm_all[[64]]
coef(summary(best))[ , "Estimate"]
##6aii. coefficients ####
best <- lmm_all[[48]]
coef(summary(best))[ , "Estimate"]
##6aii. coefficients ####
best <- lmm_all[[59]]
coef(summary(best))[ , "Estimate"]
response <- "resist.value"
effects <- c("position", "tlp", "rp", "elev_m", "height", "year", "(1|sp/tree)")
#create all combinations of random / fixed effects
effects_comb <-
unlist( sapply( seq_len(length(effects)),
function(i) {
apply( combn(effects,i), 2, function(x) paste(x, collapse = "+"))
}))
# pair response with effect and sub out combinations that don't include random effects
#in general, if two variables are >70% correlated, you can toss one of them without significantly affecting the results
var_comb <- expand.grid(response, effects_comb)
var_comb <- var_comb[grepl("1", var_comb$Var2), ] #only keep in fixed/random combos
var_comb <- var_comb[grepl("year", var_comb$Var2), ] #keep year in for drought sake
# formulas for all combinations. $Var1 is the response, and $Var2 is the effect
# for good stats, you should have no more total parameters than 1/10th the number of observations in your dataset
formula_vec <- sprintf("%s ~ %s", var_comb$Var1, var_comb$Var2)
# create list of model outputs
lmm_all <- lapply(formula_vec, function(x){
fit1 <- lmer(x, data = trees_all, REML=FALSE,
control = lmerControl(optimizer ="Nelder_Mead"))
return(fit1)
})
names(lmm_all) <- formula_vec
var_aic <- aictab(lmm_all, second.ord=TRUE, sort=TRUE) #rank based on AICc
r <- rsquared(lmm_all) #gives R^2 values for models. "Marginal" is the R^2 for just the fixed effects, "Conditional" is the R^2 for everything.
View(var_aic)
##6aii. coefficients ####
best <- lmm_all[[32]]
coef(summary(best))[ , "Estimate"]
response <- "resist.value"
effects <- c("position", "tlp", "rp", "elev_m", "height_ln", "year", "(1|sp/tree)")
#create all combinations of random / fixed effects
effects_comb <-
unlist( sapply( seq_len(length(effects)),
function(i) {
apply( combn(effects,i), 2, function(x) paste(x, collapse = "+"))
}))
# pair response with effect and sub out combinations that don't include random effects
#in general, if two variables are >70% correlated, you can toss one of them without significantly affecting the results
var_comb <- expand.grid(response, effects_comb)
var_comb <- var_comb[grepl("1", var_comb$Var2), ] #only keep in fixed/random combos
var_comb <- var_comb[grepl("year", var_comb$Var2), ] #keep year in for drought sake
# formulas for all combinations. $Var1 is the response, and $Var2 is the effect
# for good stats, you should have no more total parameters than 1/10th the number of observations in your dataset
formula_vec <- sprintf("%s ~ %s", var_comb$Var1, var_comb$Var2)
# create list of model outputs
lmm_all <- lapply(formula_vec, function(x){
fit1 <- lmer(x, data = trees_all, REML=FALSE,
control = lmerControl(optimizer ="Nelder_Mead"))
return(fit1)
})
names(lmm_all) <- formula_vec
var_aic <- aictab(lmm_all, second.ord=TRUE, sort=TRUE) #rank based on AICc
r <- rsquared(lmm_all) #gives R^2 values for models. "Marginal" is the R^2 for just the fixed effects, "Conditional" is the R^2 for everything.
View(var_aic)
