var_aic <- aictab(lmm_all, second.ord=TRUE, sort=TRUE) #rank based on AICc
View(var_aic)
# create list of model outputs
lmm_all <- lapply(formula_vec, function(x){
fit1 <- lmer(x, data = x1999, REML=FALSE,
control = lmerControl(optimizer ="Nelder_Mead"))
return(fit1)
})
names(lmm_all) <- formula_vec
var_aic <- aictab(lmm_all, second.ord=TRUE, sort=TRUE) #rank based on AICc
View(var_aic)
effects <- c("height.ln.m", "position_all", "TWI", "rp", "PLA_dry_percent", "mean_TLP_Mpa",  "LMA_g_per_m2", "WD_g_per_cm3", "year", "(1|sp/tree)")
#create all combinations of random / fixed effects
effects_comb <-
unlist( sapply( seq_len(length(effects)),
function(i) {
apply( combn(effects,i), 2, function(x) paste(x, collapse = "+"))
}))
# pair response with effect and sub out combinations that don't include random effects
#in general, if two variables are >70% correlated, you can toss one of them without significantly affecting the results
var_comb <- expand.grid(response, effects_comb)
var_comb <- var_comb[grepl("1", var_comb$Var2), ] #only keep in fixed/random combos
var_comb <- var_comb[grepl("year", var_comb$Var2), ] #keep year in for drought sake
# formulas for all combinations. $Var1 is the response, and $Var2 is the effect
# for good stats, you should have no more total parameters than 1/10th the number of observations in your dataset
formula_vec <- sprintf("%s ~ %s", var_comb$Var1, var_comb$Var2)
# create list of model outputs
lmm_all <- lapply(formula_vec, function(x){
fit1 <- lmer(x, data = trees_all_sub, REML=FALSE,
control = lmerControl(optimizer ="Nelder_Mead"))
return(fit1)
})
names(lmm_all) <- formula_vec
var_aic <- aictab(lmm_all, second.ord=TRUE, sort=TRUE) #rank based on AICc
View(var_aic)
# effects <- c("height.ln.m", "position_all", "TWI", "rp", "PLA_dry_percent", "mean_TLP_Mpa",  "LMA_g_per_m2", "WD_g_per_cm3", "year", "(1|sp/tree)")
# effects <- c("height.ln.m", "position_all", "TWI", "rp", "PLA_dry_percent", "mean_TLP_Mpa", "LMA_g_per_m2", "WD_g_per_cm3", "(1|sp)")
effects <- c("height.ln.m", "position_all", "TWI", "PLA_dry_percent", "mean_TLP_Mpa", "(1|sp)")
#create all combinations of random / fixed effects
effects_comb <-
unlist( sapply( seq_len(length(effects)),
function(i) {
apply( combn(effects,i), 2, function(x) paste(x, collapse = "+"))
}))
# pair response with effect and sub out combinations that don't include random effects
#in general, if two variables are >70% correlated, you can toss one of them without significantly affecting the results
var_comb <- expand.grid(response, effects_comb)
var_comb <- var_comb[grepl("1", var_comb$Var2), ] #only keep in fixed/random combos
var_comb <- var_comb[grepl("year", var_comb$Var2), ] #keep year in for drought sake
# pair response with effect and sub out combinations that don't include random effects
#in general, if two variables are >70% correlated, you can toss one of them without significantly affecting the results
var_comb <- expand.grid(response, effects_comb)
var_comb <- var_comb[grepl("1", var_comb$Var2), ] #only keep in fixed/random combos
# formulas for all combinations. $Var1 is the response, and $Var2 is the effect
# for good stats, you should have no more total parameters than 1/10th the number of observations in your dataset
formula_vec <- sprintf("%s ~ %s", var_comb$Var1, var_comb$Var2)
# create list of model outputs
lmm_all <- lapply(formula_vec, function(x){
fit1 <- lmer(x, data = x1966, REML=FALSE,
control = lmerControl(optimizer ="Nelder_Mead"))
return(fit1)
})
names(lmm_all) <- formula_vec
var_aic <- aictab(lmm_all, second.ord=TRUE, sort=TRUE) #rank based on AICc
View(var_aic)
# create list of model outputs
lmm_all <- lapply(formula_vec, function(x){
fit1 <- lmer(x, data = x1977, REML=FALSE,
control = lmerControl(optimizer ="Nelder_Mead"))
return(fit1)
})
names(lmm_all) <- formula_vec
var_aic <- aictab(lmm_all, second.ord=TRUE, sort=TRUE) #rank based on AICc
View(var_aic)
# create list of model outputs
lmm_all <- lapply(formula_vec, function(x){
fit1 <- lmer(x, data = x1999, REML=FALSE,
control = lmerControl(optimizer ="Nelder_Mead"))
return(fit1)
})
names(lmm_all) <- formula_vec
var_aic <- aictab(lmm_all, second.ord=TRUE, sort=TRUE) #rank based on AICc
View(var_aic)
##height and canopy position by size class ####
scbi.stem3 <- read.csv(text=getURL("https://raw.githubusercontent.com/SCBI-ForestGEO/SCBI-ForestGEO-Data/master/tree_main_census/data/scbi.stem3_TEMPORARY.csv"))
scbi.stem3$Tree_ID_Num <- gsub("_.*$", "", scbi.stem3$Tree_ID_Num)
current_ht <- trees_all[!duplicated(trees_all$tree), ]
current_ht$year <- 2018
current_ht$dbh_old.cm <- scbi.stem3$DBHcm[match(current_ht$tree, scbi.stem3$Tree_ID_Num)]
current_ht$dbh.ln.cm <- log(current_ht$dbh_old.cm)
current_ht$sap_ratio <- NA
#linear log-log regression
#the full equation is using all points for which we have data to create the equation, despite that for several species we don't have enough data to get a sp-specific equation
current_ht$height.ln.m <-
ifelse(current_ht$sp == "caco", (0.348+0.808*current_ht$dbh.ln.cm),
ifelse(current_ht$sp == "cagl", (0.681+0.704*current_ht$dbh.ln.cm),
ifelse(current_ht$sp == "caovl", (0.621+0.722*current_ht$dbh.ln.cm),
ifelse(current_ht$sp == "cato", (0.776+0.701*current_ht$dbh.ln.cm),
ifelse(current_ht$sp == "fagr", (0.708+0.662*current_ht$dbh.ln.cm),
ifelse(current_ht$sp == "fram", (0.715+0.619*current_ht$dbh.ln.cm),
ifelse(current_ht$sp == "juni", (1.22+0.49*current_ht$dbh.ln.cm),
ifelse(current_ht$sp == "litu", (1.32+0.524*current_ht$dbh.ln.cm),
ifelse(current_ht$sp == "qual", (1.14+0.548*current_ht$dbh.ln.cm),
ifelse(current_ht$sp == "qupr", (0.44+0.751*current_ht$dbh.ln.cm),
ifelse(current_ht$sp == "quru", (1.17+0.533*current_ht$dbh.ln.cm),
ifelse(current_ht$sp == "quve", (0.864+0.585*current_ht$dbh.ln.cm),
(0.791+0.645*current_ht$dbh.ln.cm)))))))))))))
current_ht$height.m <- exp(current_ht$height.ln.m)
current_ht <- rbind(current_ht, trees_all)
View(current_ht)
View(trees_all)
##height and canopy position by size class ####
scbi.stem3 <- read.csv(text=getURL("https://raw.githubusercontent.com/SCBI-ForestGEO/SCBI-ForestGEO-Data/master/tree_main_census/data/census-csv-files/scbi.stem3.csv"))
scbi.stem3 <- read.csv(text=getURL("D:/Dropbox (Smithsonian)/Github_Ian/SCBI-ForestGEO-Data/tree_main_census/data/census-csv-files/scbi.stem3.csv"))
scbi.stem3 <- read.csv(text=getURL("D:/Dropbox (Smithsonian)/Github_Ian/SCBI-ForestGEO-Data/tree_main_census/data/census-csv-files/scbi.stem3.csv"))
scbi.stem3 <- read.csv(text=getURL("D:/Dropbox (Smithsonian)/Github_Ian/SCBI-ForestGEO-Data/tree_main_census/data/census-csv-files/scbi.stem3.csv"))
View(var_aic)
##6cii. base code for running multiple models through AICc eval ####
#define response and effects
response <- "resist.value"
# effects <- c("height.ln.m", "position_all", "TWI", "rp", "PLA_dry_percent", "mean_TLP_Mpa",  "LMA_g_per_m2", "WD_g_per_cm3", "year", "(1|sp/tree)")
# effects <- c("height.ln.m", "position_all", "TWI", "rp", "PLA_dry_percent", "mean_TLP_Mpa", "LMA_g_per_m2", "WD_g_per_cm3", "(1|sp)")
effects <- c("height.ln.m", "position_all", "TWI", "PLA_dry_percent", "mean_TLP_Mpa", "(1|sp)")
#create all combinations of random / fixed effects
effects_comb <-
unlist( sapply( seq_len(length(effects)),
function(i) {
apply( combn(effects,i), 2, function(x) paste(x, collapse = "+"))
}))
# pair response with effect and sub out combinations that don't include random effects
#in general, if two variables are >70% correlated, you can toss one of them without significantly affecting the results
var_comb <- expand.grid(response, effects_comb)
var_comb <- var_comb[grepl("1", var_comb$Var2), ] #only keep in fixed/random combos
# formulas for all combinations. $Var1 is the response, and $Var2 is the effect
# for good stats, you should have no more total parameters than 1/10th the number of observations in your dataset
formula_vec <- sprintf("%s ~ %s", var_comb$Var1, var_comb$Var2)
# create list of model outputs
lmm_all <- lapply(formula_vec, function(x){
fit1 <- lmer(x, data = x1966, REML=FALSE,
control = lmerControl(optimizer ="Nelder_Mead"))
return(fit1)
})
names(lmm_all) <- formula_vec
var_aic <- aictab(lmm_all, second.ord=TRUE, sort=TRUE) #rank based on AICc
View(var_aic)
##6ciii. coefficients ####
best <- lmm_all[[22]]
coef(summary(best))[ , "Estimate"])
coef(summary(best))[ , "Estimate"]
# create list of model outputs
lmm_all <- lapply(formula_vec, function(x){
fit1 <- lmer(x, data = x1977, REML=FALSE,
control = lmerControl(optimizer ="Nelder_Mead"))
return(fit1)
})
names(lmm_all) <- formula_vec
var_aic <- aictab(lmm_all, second.ord=TRUE, sort=TRUE) #rank based on AICc
##6ciii. coefficients ####
best <- lmm_all[[15]]
coef(summary(best))[ , "Estimate"]
# create list of model outputs
lmm_all <- lapply(formula_vec, function(x){
fit1 <- lmer(x, data = x1999, REML=FALSE,
control = lmerControl(optimizer ="Nelder_Mead"))
return(fit1)
})
names(lmm_all) <- formula_vec
var_aic <- aictab(lmm_all, second.ord=TRUE, sort=TRUE) #rank based on AICc
##6ciii. coefficients ####
best <- lmm_all[[17]]
coef(summary(best))[ , "Estimate"]
# effects <- c("height.ln.m", "position_all", "TWI", "PLA_dry_percent", "mean_TLP_Mpa", "(1|sp)")
effects <- c("height.ln.m", "position_all", "TWI", "PLA_dry_percent", "mean_TLP_Mpa", "year", "(1|sp/tree)")
#create all combinations of random / fixed effects
effects_comb <-
unlist( sapply( seq_len(length(effects)),
function(i) {
apply( combn(effects,i), 2, function(x) paste(x, collapse = "+"))
}))
# pair response with effect and sub out combinations that don't include random effects
#in general, if two variables are >70% correlated, you can toss one of them without significantly affecting the results
var_comb <- expand.grid(response, effects_comb)
var_comb <- var_comb[grepl("1", var_comb$Var2), ] #only keep in fixed/random combos
var_comb <- var_comb[grepl("year", var_comb$Var2), ] #keep year in for drought sake
# formulas for all combinations. $Var1 is the response, and $Var2 is the effect
# for good stats, you should have no more total parameters than 1/10th the number of observations in your dataset
formula_vec <- sprintf("%s ~ %s", var_comb$Var1, var_comb$Var2)
# create list of model outputs
lmm_all <- lapply(formula_vec, function(x){
fit1 <- lmer(x, data = trees_all_sub, REML=FALSE,
control = lmerControl(optimizer ="Nelder_Mead"))
return(fit1)
})
names(lmm_all) <- formula_vec
var_aic <- aictab(lmm_all, second.ord=TRUE, sort=TRUE) #rank based on AICc
View(var_aic)
##6ciii. coefficients ####
best <- lmm_all[[32]]
coef(summary(best))[ , "Estimate"]
effects <- c("height.ln.m", "position_all", "TWI", "rp", "PLA_dry_percent", "mean_TLP_Mpa",  "LMA_g_per_m2", "WD_g_per_cm3", "year", "(1|sp/tree)")
#create all combinations of random / fixed effects
effects_comb <-
unlist( sapply( seq_len(length(effects)),
function(i) {
apply( combn(effects,i), 2, function(x) paste(x, collapse = "+"))
}))
# pair response with effect and sub out combinations that don't include random effects
#in general, if two variables are >70% correlated, you can toss one of them without significantly affecting the results
var_comb <- expand.grid(response, effects_comb)
var_comb <- var_comb[grepl("1", var_comb$Var2), ] #only keep in fixed/random combos
var_comb <- var_comb[grepl("year", var_comb$Var2), ] #keep year in for drought sake
# formulas for all combinations. $Var1 is the response, and $Var2 is the effect
# for good stats, you should have no more total parameters than 1/10th the number of observations in your dataset
formula_vec <- sprintf("%s ~ %s", var_comb$Var1, var_comb$Var2)
# create list of model outputs
lmm_all <- lapply(formula_vec, function(x){
fit1 <- lmer(x, data = trees_all_sub, REML=FALSE,
control = lmerControl(optimizer ="Nelder_Mead"))
return(fit1)
})
names(lmm_all) <- formula_vec
var_aic <- aictab(lmm_all, second.ord=TRUE, sort=TRUE) #rank based on AICc
View(var_aic)
##6ciii. coefficients ####
best <- lmm_all[[254]]
coef(summary(best))[ , "Estimate"]
# effects <- c("height.ln.m", "position_all", "TWI", "rp", "PLA_dry_percent", "mean_TLP_Mpa",  "LMA_g_per_m2", "WD_g_per_cm3", "year", "(1|sp/tree)")
effects <- c("height.ln.m", "position_all", "TWI", "rp", "PLA_dry_percent", "mean_TLP_Mpa", "LMA_g_per_m2", "WD_g_per_cm3", "(1|sp)")
#create all combinations of random / fixed effects
effects_comb <-
unlist( sapply( seq_len(length(effects)),
function(i) {
apply( combn(effects,i), 2, function(x) paste(x, collapse = "+"))
}))
# pair response with effect and sub out combinations that don't include random effects
#in general, if two variables are >70% correlated, you can toss one of them without significantly affecting the results
var_comb <- expand.grid(response, effects_comb)
var_comb <- var_comb[grepl("1", var_comb$Var2), ] #only keep in fixed/random combos
# formulas for all combinations. $Var1 is the response, and $Var2 is the effect
# for good stats, you should have no more total parameters than 1/10th the number of observations in your dataset
formula_vec <- sprintf("%s ~ %s", var_comb$Var1, var_comb$Var2)
# create list of model outputs
lmm_all <- lapply(formula_vec, function(x){
fit1 <- lmer(x, data = x1966, REML=FALSE,
control = lmerControl(optimizer ="Nelder_Mead"))
return(fit1)
})
names(lmm_all) <- formula_vec
var_aic <- aictab(lmm_all, second.ord=TRUE, sort=TRUE) #rank based on AICc
View(var_aic)
##6ciii. coefficients ####
best <- lmm_all[[49]]
coef(summary(best))[ , "Estimate"]
# create list of model outputs
lmm_all <- lapply(formula_vec, function(x){
fit1 <- lmer(x, data = x1977, REML=FALSE,
control = lmerControl(optimizer ="Nelder_Mead"))
return(fit1)
})
names(lmm_all) <- formula_vec
var_aic <- aictab(lmm_all, second.ord=TRUE, sort=TRUE) #rank based on AICc
View(var_aic)
##6ciii. coefficients ####
best <- lmm_all[[217]]
coef(summary(best))[ , "Estimate"]
# create list of model outputs
lmm_all <- lapply(formula_vec, function(x){
fit1 <- lmer(x, data = x1999, REML=FALSE,
control = lmerControl(optimizer ="Nelder_Mead"))
return(fit1)
})
names(lmm_all) <- formula_vec
var_aic <- aictab(lmm_all, second.ord=TRUE, sort=TRUE) #rank based on AICc
View(var_aic)
##6ciii. coefficients ####
best <- lmm_all[[150]]
coef(summary(best))[ , "Estimate"]
##height and canopy position by size class ####
scbi.stem3 <- read.csv(text=getURL("https://raw.githubusercontent.com/SCBI-ForestGEO/SCBI-ForestGEO-Data/master/tree_main_census/data/census-csv-files/scbi.stem3.csv"))
scbi.stem3$Tree_ID_Num <- gsub("_.*$", "", scbi.stem3$Tree_ID_Num)
current_ht <- trees_all[!duplicated(trees_all$tree), ]
current_ht$year <- 2018
current_ht$dbh_old.cm <- scbi.stem3$DBHcm[match(current_ht$tree, scbi.stem3$Tree_ID_Num)]
current_ht$dbh.ln.cm <- log(current_ht$dbh_old.cm)
current_ht$sap_ratio <- NA
View(scbi.stem3)
current_ht <- trees_all[!duplicated(trees_all$tree), ]
current_ht$year <- 2018
##height and canopy position by size class ####
scbi.stem3 <- read.csv(text=getURL("https://raw.githubusercontent.com/SCBI-ForestGEO/SCBI-ForestGEO-Data/master/tree_main_census/data/census-csv-files/scbi.stem3.csv"), stringsAsFactors = FALSE)
scbi.stem3$dbh <- as.numeric(scbi.stem3)
scbi.stem3$dbh <- as.numeric(scbi.stem3$dbh)
current_ht <- trees_all[!duplicated(trees_all$tree), ]
current_ht$year <- 2018
current_ht$dbh_old.cm <- scbi.stem3$dbh[match(current_ht$tree, scbi.stem3$tree)]
current_ht$dbh.ln.cm <- log(current_ht$dbh_old.cm)
current_ht$sap_ratio <- NA
#linear log-log regression
#the full equation is using all points for which we have data to create the equation, despite that for several species we don't have enough data to get a sp-specific equation
current_ht$height.ln.m <-
ifelse(current_ht$sp == "caco", (0.348+0.808*current_ht$dbh.ln.cm),
ifelse(current_ht$sp == "cagl", (0.681+0.704*current_ht$dbh.ln.cm),
ifelse(current_ht$sp == "caovl", (0.621+0.722*current_ht$dbh.ln.cm),
ifelse(current_ht$sp == "cato", (0.776+0.701*current_ht$dbh.ln.cm),
ifelse(current_ht$sp == "fagr", (0.708+0.662*current_ht$dbh.ln.cm),
ifelse(current_ht$sp == "fram", (0.715+0.619*current_ht$dbh.ln.cm),
ifelse(current_ht$sp == "juni", (1.22+0.49*current_ht$dbh.ln.cm),
ifelse(current_ht$sp == "litu", (1.32+0.524*current_ht$dbh.ln.cm),
ifelse(current_ht$sp == "qual", (1.14+0.548*current_ht$dbh.ln.cm),
ifelse(current_ht$sp == "qupr", (0.44+0.751*current_ht$dbh.ln.cm),
ifelse(current_ht$sp == "quru", (1.17+0.533*current_ht$dbh.ln.cm),
ifelse(current_ht$sp == "quve", (0.864+0.585*current_ht$dbh.ln.cm),
(0.791+0.645*current_ht$dbh.ln.cm)))))))))))))
current_ht$height.m <- exp(current_ht$height.ln.m)
current_ht <- rbind(current_ht, trees_all)
current_ht <- current_ht[order(current_ht$tree, current_ht$year), ]
#with height
ggplot(data = current_ht) +
aes(x = year, y = height.m, fill = position_all) +
# aes(x=position_all, y=height.m, fill=year) +
geom_boxplot() +
ggtitle("Height vs crown position")+
xlab("year") +
ylab("height(m)") +
theme_minimal()
scbi.stem3 <- read.csv(text=getURL("https://raw.githubusercontent.com/SCBI-ForestGEO/SCBI-ForestGEO-Data/master/tree_main_census/data/census-csv-files/scbi.stem3.csv"), stringsAsFactors = FALSE)
scbi.stem3$dbh <- as.numeric(scbi.stem3$dbh)
current_ht <- trees_all[!duplicated(trees_all$tree), ]
current_ht$year <- 2018
current_ht$dbh_old.cm <- scbi.stem3$dbh[match(current_ht$tree, scbi.stem3$tree)]
current_ht$dbh.ln.cm <- log(current_ht$dbh_old.cm)
current_ht$sap_ratio <- NA
#linear log-log regression
#the full equation is using all points for which we have data to create the equation, despite that for several species we don't have enough data to get a sp-specific equation
current_ht$height.ln.m <-
ifelse(current_ht$sp == "caco", (0.348+0.808*current_ht$dbh.ln.cm),
ifelse(current_ht$sp == "cagl", (0.681+0.704*current_ht$dbh.ln.cm),
ifelse(current_ht$sp == "caovl", (0.621+0.722*current_ht$dbh.ln.cm),
ifelse(current_ht$sp == "cato", (0.776+0.701*current_ht$dbh.ln.cm),
ifelse(current_ht$sp == "fagr", (0.708+0.662*current_ht$dbh.ln.cm),
ifelse(current_ht$sp == "fram", (0.715+0.619*current_ht$dbh.ln.cm),
ifelse(current_ht$sp == "juni", (1.22+0.49*current_ht$dbh.ln.cm),
ifelse(current_ht$sp == "litu", (1.32+0.524*current_ht$dbh.ln.cm),
ifelse(current_ht$sp == "qual", (1.14+0.548*current_ht$dbh.ln.cm),
ifelse(current_ht$sp == "qupr", (0.44+0.751*current_ht$dbh.ln.cm),
ifelse(current_ht$sp == "quru", (1.17+0.533*current_ht$dbh.ln.cm),
ifelse(current_ht$sp == "quve", (0.864+0.585*current_ht$dbh.ln.cm),
(0.791+0.645*current_ht$dbh.ln.cm)))))))))))))
current_ht$height.m <- exp(current_ht$height.ln.m)
# #power function Height = intercept*(diameter^slope)
# current_ht$height_power_ln <-
#                     ifelse(current_ht$sp == "caco", (0.55*(current_ht$dbh_ln.cm^0.766)),
#                     ifelse(current_ht$sp == "cagl", (0.652*(current_ht$dbh_ln.cm^0.751)),
#                     ifelse(current_ht$sp == "caovl", (0.9*(current_ht$dbh_ln.cm^0.659)),
#                     ifelse(current_ht$sp == "cato", (0.879*(current_ht$dbh_ln.cm^0.668)),
#                     ifelse(current_ht$sp == "fagr", (0.513*(current_ht$dbh_ln.cm^0.712)),
#                     ifelse(current_ht$sp == "litu", (1.57*(current_ht$dbh_ln.cm^0.488)),
#                     ifelse(current_ht$sp == "quru", (1.13*(current_ht$dbh_ln.cm^0.54)),
#                                  (0.849*(current_ht$dbh_ln.cm^0.659)))))))))
# current_ht$height_power.m <- exp(current_ht$height_power_ln)
# current_ht <- rbind(current_ht, trees_all) #run this line to get full picture going back in time
current_ht <- current_ht[order(current_ht$tree, current_ht$year), ]
#with height
ggplot(data = current_ht) +
aes(x = year, y = height.m, fill = position_all) +
# aes(x=position_all, y=height.m, fill=year) +
geom_boxplot() +
ggtitle("Height vs crown position")+
xlab("year") +
ylab("height(m)") +
theme_minimal()
#with height
ggplot(data = current_ht) +
aes(x = position_all, y = height.m, fill = position_all) +
# aes(x=position_all, y=height.m, fill=year) +
geom_boxplot() +
ggtitle("Height vs crown position")+
xlab("year") +
ylab("height(m)") +
theme_minimal()
current_ht <- trees_all[!duplicated(trees_all$tree), ]
current_ht$year <- 2018
current_ht <- current_ht[,c(1:4,15:17,19:21)]
current_ht$dbh_old.cm <- scbi.stem3$dbh[match(current_ht$tree, scbi.stem3$tree)]
scbi.stem3$dbh <- as.numeric(scbi.stem3$dbh)
View(scbi.stem3)
current_ht <- trees_all[!duplicated(trees_all$tree), ]
current_ht$year <- 2018
current_ht <- current_ht[,c(1:4,15:17,19:21)]
current_ht$dbh_old.cm <- scbi.stem3$dbh[match(current_ht$tree, scbi.stem3$tree)]
current_ht$dbh_old.cm <- scbi.stem3$dbh[match(current_ht$tree, scbi.stem3$tag)]
current_ht$dbh.ln.cm <- log(current_ht$dbh_old.cm)
#linear log-log regression
#the full equation is using all points for which we have data to create the equation, despite that for several species we don't have enough data to get a sp-specific equation
current_ht$height.ln.m <-
ifelse(current_ht$sp == "caco", (0.348+0.808*current_ht$dbh.ln.cm),
ifelse(current_ht$sp == "cagl", (0.681+0.704*current_ht$dbh.ln.cm),
ifelse(current_ht$sp == "caovl", (0.621+0.722*current_ht$dbh.ln.cm),
ifelse(current_ht$sp == "cato", (0.776+0.701*current_ht$dbh.ln.cm),
ifelse(current_ht$sp == "fagr", (0.708+0.662*current_ht$dbh.ln.cm),
ifelse(current_ht$sp == "fram", (0.715+0.619*current_ht$dbh.ln.cm),
ifelse(current_ht$sp == "juni", (1.22+0.49*current_ht$dbh.ln.cm),
ifelse(current_ht$sp == "litu", (1.32+0.524*current_ht$dbh.ln.cm),
ifelse(current_ht$sp == "qual", (1.14+0.548*current_ht$dbh.ln.cm),
ifelse(current_ht$sp == "qupr", (0.44+0.751*current_ht$dbh.ln.cm),
ifelse(current_ht$sp == "quru", (1.17+0.533*current_ht$dbh.ln.cm),
ifelse(current_ht$sp == "quve", (0.864+0.585*current_ht$dbh.ln.cm),
(0.791+0.645*current_ht$dbh.ln.cm)))))))))))))
current_ht$height.m <- exp(current_ht$height.ln.m)
# current_ht <- rbind(current_ht, trees_all) #run this line to get full picture going back in time
current_ht <- current_ht[order(current_ht$tree, current_ht$year), ]
#with height
ggplot(data = current_ht) +
aes(x = position_all, y = height.m, fill = position_all) +
# aes(x=position_all, y=height.m, fill=year) +
geom_boxplot() +
ggtitle("Height vs crown position")+
xlab("year") +
ylab("height(m)") +
theme_minimal()
current_ht$dbh_old.mm <- scbi.stem3$dbh[match(current_ht$tree, scbi.stem3$tag)]
current_ht$dbh_old.cm <- current_ht$dbh_old.mm/10
current_ht$dbh.ln.cm <- log(current_ht$dbh_old.cm)
#linear log-log regression
#the full equation is using all points for which we have data to create the equation, despite that for several species we don't have enough data to get a sp-specific equation
current_ht$height.ln.m <-
ifelse(current_ht$sp == "caco", (0.348+0.808*current_ht$dbh.ln.cm),
ifelse(current_ht$sp == "cagl", (0.681+0.704*current_ht$dbh.ln.cm),
ifelse(current_ht$sp == "caovl", (0.621+0.722*current_ht$dbh.ln.cm),
ifelse(current_ht$sp == "cato", (0.776+0.701*current_ht$dbh.ln.cm),
ifelse(current_ht$sp == "fagr", (0.708+0.662*current_ht$dbh.ln.cm),
ifelse(current_ht$sp == "fram", (0.715+0.619*current_ht$dbh.ln.cm),
ifelse(current_ht$sp == "juni", (1.22+0.49*current_ht$dbh.ln.cm),
ifelse(current_ht$sp == "litu", (1.32+0.524*current_ht$dbh.ln.cm),
ifelse(current_ht$sp == "qual", (1.14+0.548*current_ht$dbh.ln.cm),
ifelse(current_ht$sp == "qupr", (0.44+0.751*current_ht$dbh.ln.cm),
ifelse(current_ht$sp == "quru", (1.17+0.533*current_ht$dbh.ln.cm),
ifelse(current_ht$sp == "quve", (0.864+0.585*current_ht$dbh.ln.cm),
(0.791+0.645*current_ht$dbh.ln.cm)))))))))))))
current_ht$height.m <- exp(current_ht$height.ln.m)
# current_ht <- rbind(current_ht, trees_all) #run this line to get full picture going back in time
current_ht <- current_ht[order(current_ht$tree, current_ht$year), ]
#with height
ggplot(data = current_ht) +
aes(x = position_all, y = height.m, fill = position_all) +
# aes(x=position_all, y=height.m, fill=year) +
geom_boxplot() +
ggtitle("Height vs crown position")+
xlab("year") +
ylab("height(m)") +
theme_minimal()
#with height
ggplot(data = current_ht) +
aes(x = position_all, y = height.m, fill = position_all) +
# aes(x=position_all, y=height.m, fill=year) +
geom_boxplot(na.rm=TRUE) +
ggtitle("Height vs crown position")+
xlab("year") +
ylab("height(m)") +
theme_minimal()
#with height
current_ht <- current_ht[!is.na(current_ht$position_all), ]
ggplot(data = current_ht) +
aes(x = position_all, y = height.m, fill = position_all) +
# aes(x=position_all, y=height.m, fill=year) +
geom_boxplot() +
ggtitle("Height vs crown position")+
xlab("year") +
ylab("height(m)") +
theme_minimal()
ggplot(data = current_ht) +
aes(x = position_all, y = height.m, fill = position_all, group = desc(position_all)) +
# aes(x=position_all, y=height.m, fill=year) +
geom_boxplot() +
ggtitle("Current height vs crown position")+
xlab("year") +
ylab("height(m)") +
theme_minimal()
ggplot(data = current_ht) +
aes(x = position_all, y = height.m, fill = position_all, group = position_all) +
# aes(x=position_all, y=height.m, fill=year) +
geom_boxplot() +
ggtitle("Current height vs crown position")+
xlab("year") +
ylab("height(m)") +
theme_minimal()
aes(x = position_all, y = height.m, fill = position_all, group = factor(position_all, levels = c("dominant", "co-dominant", "intermediate", "suppressed")) +
ggplot(data = current_ht) +
aes(x = position_all, y = height.m, fill = position_all, group = factor(position_all, levels = c("dominant", "co-dominant", "intermediate", "suppressed"))) +
# aes(x=position_all, y=height.m, fill=year) +
geom_boxplot() +
ggtitle("Current height vs crown position")+
xlab("year") +
ylab("height(m)") +
theme_minimal()
current_ht$position_all <- factor(current_ht$position_all, levels = c("dominant", "co-dominant", "intermediate", "suppressed"))
ggplot(data = current_ht) +
aes(x = position_all, y = height.m, fill = position_all, group = position_all)) +
# aes(x=position_all, y=height.m, fill=year) +
geom_boxplot() +
ggtitle("Current height vs crown position")+
xlab("year") +
ylab("height(m)") +
theme_minimal()
ggplot(data = current_ht) +
aes(x = position_all, y = height.m, fill = position_all, group = position_all) +
# aes(x=position_all, y=height.m, fill=year) +
geom_boxplot() +
ggtitle("Current height vs crown position")+
xlab("year") +
ylab("height(m)") +
theme_minimal()
