formula_vec <- sprintf("%s ~ %s", var_comb$Var1, var_comb$Var2)
lmm_all <- lapply(formula_vec, function(x){
fit1 <- lmer(x, data = model_df[[j]], REML=FALSE,
control = lmerControl(optimizer ="Nelder_Mead"))
return(fit1)
})
names(lmm_all) <- formula_vec
var_aic <- aictab(lmm_all, second.ord=TRUE, sort=TRUE) #rank based on AICc
var_aic$Modnames <- as.character(var_aic$Modnames)
best_mod_traits$best_model[[i]] <- var_aic$Modnames[[1]]
#get all mods <2 dAIC
var_aic <- var_aic[var_aic$Delta_AICc <= 2, ]
top <- var_aic[,c(1,4)]
top$Delta_AICc <- round(top$Delta_AICc, 2)
top$scenario <- mods[[i]]
top$coef <- NA
for (z in seq(along = lmm_all)){
if (names(lmm_all[z]) == var_aic$Modnames[[1]]){
#run the best model alone with REML=TRUE
fit1 <- lmer(formula_vec[[z]], data = model_df[[j]], REML=TRUE,
control = lmerControl(optimizer ="Nelder_Mead"))
#get coefficients and put in table
coeff <- data.frame(coef(summary(fit1))[ , "Estimate"]) ##2
coeff[,2] <- rownames(coeff)
coeff[,1] <- round(coeff[,1], 3)
colnames(coeff) <- c(names(model_df[j]), "model_var")
#put r2 in table
r <- rsquared(fit1) #gives R^2 values for models. "Marginal" is the R^2 for just the fixed effects, "Conditional" is the R^2 for everything.
r <- data.frame(r[,6])
colnames(r) <- names(model_df[j])
r$model_var <- "r^2"
r[,1] <- round(r[,1], 2)
coeff <- rbind(r,coeff)
coeff_list[[paste0("coeff_", names(model_df[j]))]] <- coeff
}
if (names(lmm_all[z]) %in% var_aic$Modnames){
#run the best model alone with REML=TRUE
fit1 <- lmer(formula_vec[[z]], data = model_df[[j]], REML=FALSE,
control = lmerControl(optimizer ="Nelder_Mead"))
#get coefficients and put in table
coeff <- data.frame(coef(summary(fit1))[ , "Estimate"]) ##2
coeff[,2] <- rownames(coeff)
coeff[,1] <- round(coeff[,1], 3)
coeff$comb <- paste0(coeff[,2], " (", coeff[,1], ")")
for (g in seq(along=1:nrow(top))){
if(rownames(top)[[g]] == z){
top$coef[[g]] <- paste(unlist(coeff$comb), collapse=", ")
}
}
}
}
#INDIVIDUAL YEARS
} else if (j == i){
response <- "resist.value"
effects <- best_mod_full_year
#create all combinations of random / fixed effects
effects_comb <-
unlist( sapply( seq_len(length(effects)),
function(i) {
apply( combn(effects,i), 2, function(x) paste(x, collapse = "+"))
}))
var_comb <- expand.grid(response, effects_comb)
var_comb <- var_comb[grepl("1", var_comb$Var2), ] #only keep in fixed/random combos
var_comb$Var2 <- as.character(var_comb$Var2)
#can't have height and TWI separately when the interaction is in
for (q in seq(along=var_comb$Var2)){
cell <- var_comb$Var2[[q]]
if(grepl("\\*", cell)){
if(grepl("\\+TWI.ln", cell)){
var_comb$Var2[[q]] <- gsub("\\+TWI.ln", "", var_comb$Var2[[q]])
}
if(grepl("\\+height.ln.m", cell)){
var_comb$Var2[[q]] <- gsub("\\+height.ln.m\\+", "+", var_comb$Var2[[q]])
}
}
}
var_comb <- unique(var_comb[,1:2])
formula_vec <- sprintf("%s ~ %s", var_comb$Var1, var_comb$Var2)
lmm_all <- lapply(formula_vec, function(x){
fit1 <- lmer(x, data = model_df[[j]], REML=FALSE,
control = lmerControl(optimizer ="Nelder_Mead"))
return(fit1)
})
names(lmm_all) <- formula_vec
var_aic <- aictab(lmm_all, second.ord=TRUE, sort=TRUE) #rank based on AICc
var_aic$Modnames <- as.character(var_aic$Modnames)
best_mod_traits$best_model[[i]] <- var_aic$Modnames[[1]]
#get all mods <2 dAIC
var_aic <- var_aic[var_aic$Delta_AICc <= 2, ]
top <- var_aic[,c(1,4)]
top$Delta_AICc <- round(top$Delta_AICc, 2)
top$scenario <- mods[[i]]
top$coef <- NA
for (z in seq(along = lmm_all)){
if (names(lmm_all[z]) == var_aic$Modnames[[1]]){
#run the best model alone with REML=TRUE
fit1 <- lmer(formula_vec[[z]], data = model_df[[j]], REML=TRUE,
control = lmerControl(optimizer ="Nelder_Mead"))
#get coefficients and put in table
coeff <- data.frame(coef(summary(fit1))[ , "Estimate"]) ##2
coeff[,2] <- rownames(coeff)
coeff[,1] <- round(coeff[,1], 3)
colnames(coeff) <- c(names(model_df[j]), "model_var")
#put r2 in table
r <- rsquared(fit1) #gives R^2 values for models. "Marginal" is the R^2 for just the fixed effects, "Conditional" is the R^2 for everything.
r <- data.frame(r[,6])
colnames(r) <- names(model_df[j])
r$model_var <- "r^2"
r[,1] <- round(r[,1], 2)
coeff <- rbind(r,coeff)
coeff_list[[paste0("coeff_", names(model_df[j]))]] <- coeff
}
if (names(lmm_all[z]) %in% var_aic$Modnames){
#run the best model alone with REML=TRUE
fit1 <- lmer(formula_vec[[z]], data = model_df[[j]], REML=FALSE,
control = lmerControl(optimizer ="Nelder_Mead"))
#get coefficients and put in table
coeff <- data.frame(coef(summary(fit1))[ , "Estimate"]) ##2
coeff[,2] <- rownames(coeff)
coeff[,1] <- round(coeff[,1], 3)
coeff$comb <- paste0(coeff[,2], " (", coeff[,1], ")")
for (g in seq(along=1:nrow(top))){
if(rownames(top)[[g]] == z){
top$coef[[g]] <- paste(unlist(coeff$comb), collapse=", ")
}
}
}
}
}
}
top_models <- rbind(top_models, top)
}
View(var_comb)
cell
var_comb <- expand.grid(response, effects_comb)
var_comb <- var_comb[grepl("1", var_comb$Var2), ] #only keep in fixed/random combos
var_comb$Var2 <- as.character(var_comb$Var2)
#can't have height and TWI separately when the interaction is in
for (q in seq(along=var_comb$Var2)){
cell <- var_comb$Var2[[q]]
if(grepl("\\*", cell)){
if(grepl("\\+TWI.ln", cell)){
var_comb$Var2[[q]] <- gsub("\\+TWI.ln", "", var_comb$Var2[[q]])
}
if(grepl("\\+height.ln.m", cell)){
var_comb$Var2[[q]] <- gsub("\\+height.ln.m\\+", "\\+", var_comb$Var2[[q]])
}
}
}
top_models <- NULL
coeff_list <- list()
for (i in seq(along=c(1:4))){
for (j in seq(along=model_df)){
#ALL YEARS
if(j == 1 & i == 1){
response <- "resist.value"
effects <- best_mod_full
#create all combinations of random / fixed effects
effects_comb <-
unlist(sapply(seq_len(length(effects)), function(i) {
apply( combn(effects,i), 2, function(x) paste(x, collapse = "+"))
}))
#pair response with effect and sub out combinations that don't include random effects
#in general, if two variables are >70% correlated, you can toss one of them without significantly affecting the results
var_comb <- expand.grid(response, effects_comb)
var_comb <- var_comb[grepl("1", var_comb$Var2), ] #only keep in fixed/random combos
var_comb$Var2 <- as.character(var_comb$Var2)
#can't have height and TWI separately when the interaction is in
for (q in seq(along=var_comb$Var2)){
cell <- var_comb$Var2[[q]]
if(grepl("\\*", cell)){
if(grepl("\\+TWI.ln", cell)){
var_comb$Var2[[q]] <- gsub("\\+TWI.ln", "", var_comb$Var2[[q]])
}
if(grepl("\\+height.ln.m", cell)){
var_comb$Var2[[q]] <- gsub("\\+height.ln.m\\+", "", var_comb$Var2[[q]])
}
}
}
var_comb <- unique(var_comb[,1:2])
# formulas for all combinations. $Var1 is the response, and $Var2 is the effect
# for good stats, you should have no more total parameters than 1/10th the number of observations in your dataset
formula_vec <- sprintf("%s ~ %s", var_comb$Var1, var_comb$Var2)
lmm_all <- lapply(formula_vec, function(x){
fit1 <- lmer(x, data = model_df[[j]], REML=FALSE,
control = lmerControl(optimizer ="Nelder_Mead"))
return(fit1)
})
names(lmm_all) <- formula_vec
var_aic <- aictab(lmm_all, second.ord=TRUE, sort=TRUE) #rank based on AICc
var_aic$Modnames <- as.character(var_aic$Modnames)
best_mod_traits$best_model[[i]] <- var_aic$Modnames[[1]]
#get all mods <2 dAIC
var_aic <- var_aic[var_aic$Delta_AICc <= 2, ]
top <- var_aic[,c(1,4)]
top$Delta_AICc <- round(top$Delta_AICc, 2)
top$scenario <- mods[[i]]
top$coef <- NA
for (z in seq(along = lmm_all)){
if (names(lmm_all[z]) == var_aic$Modnames[[1]]){
#run the best model alone with REML=TRUE
fit1 <- lmer(formula_vec[[z]], data = model_df[[j]], REML=TRUE,
control = lmerControl(optimizer ="Nelder_Mead"))
#get coefficients and put in table
coeff <- data.frame(coef(summary(fit1))[ , "Estimate"]) ##2
coeff[,2] <- rownames(coeff)
coeff[,1] <- round(coeff[,1], 3)
colnames(coeff) <- c(names(model_df[j]), "model_var")
#put r2 in table
r <- rsquared(fit1) #gives R^2 values for models. "Marginal" is the R^2 for just the fixed effects, "Conditional" is the R^2 for everything.
r <- data.frame(r[,6])
colnames(r) <- names(model_df[j])
r$model_var <- "r^2"
r[,1] <- round(r[,1], 2)
coeff <- rbind(r,coeff)
coeff_list[[paste0("coeff_", names(model_df[j]))]] <- coeff
}
if (names(lmm_all[z]) %in% var_aic$Modnames){
#run the best model alone with REML=TRUE
fit1 <- lmer(formula_vec[[z]], data = model_df[[j]], REML=FALSE,
control = lmerControl(optimizer ="Nelder_Mead"))
#get coefficients and put in table
coeff <- data.frame(coef(summary(fit1))[ , "Estimate"]) ##2
coeff[,2] <- rownames(coeff)
coeff[,1] <- round(coeff[,1], 3)
coeff$comb <- paste0(coeff[,2], " (", coeff[,1], ")")
for (g in seq(along=1:nrow(top))){
if(rownames(top)[[g]] == z){
top$coef[[g]] <- paste(unlist(coeff$comb), collapse=", ")
}
}
}
}
#INDIVIDUAL YEARS
} else if (j == i){
response <- "resist.value"
effects <- best_mod_full_year
#create all combinations of random / fixed effects
effects_comb <-
unlist( sapply( seq_len(length(effects)),
function(i) {
apply( combn(effects,i), 2, function(x) paste(x, collapse = "+"))
}))
var_comb <- expand.grid(response, effects_comb)
var_comb <- var_comb[grepl("1", var_comb$Var2), ] #only keep in fixed/random combos
var_comb$Var2 <- as.character(var_comb$Var2)
#can't have height and TWI separately when the interaction is in
for (q in seq(along=var_comb$Var2)){
cell <- var_comb$Var2[[q]]
if(grepl("\\*", cell)){
if(grepl("\\+TWI.ln", cell)){
var_comb$Var2[[q]] <- gsub("\\+TWI.ln", "", var_comb$Var2[[q]])
}
if(grepl("\\+height.ln.m", cell)){
var_comb$Var2[[q]] <- gsub("\\+height.ln.m\\+", "\\+", var_comb$Var2[[q]])
}
}
}
var_comb <- unique(var_comb[,1:2])
formula_vec <- sprintf("%s ~ %s", var_comb$Var1, var_comb$Var2)
lmm_all <- lapply(formula_vec, function(x){
fit1 <- lmer(x, data = model_df[[j]], REML=FALSE,
control = lmerControl(optimizer ="Nelder_Mead"))
return(fit1)
})
names(lmm_all) <- formula_vec
var_aic <- aictab(lmm_all, second.ord=TRUE, sort=TRUE) #rank based on AICc
var_aic$Modnames <- as.character(var_aic$Modnames)
best_mod_traits$best_model[[i]] <- var_aic$Modnames[[1]]
#get all mods <2 dAIC
var_aic <- var_aic[var_aic$Delta_AICc <= 2, ]
top <- var_aic[,c(1,4)]
top$Delta_AICc <- round(top$Delta_AICc, 2)
top$scenario <- mods[[i]]
top$coef <- NA
for (z in seq(along = lmm_all)){
if (names(lmm_all[z]) == var_aic$Modnames[[1]]){
#run the best model alone with REML=TRUE
fit1 <- lmer(formula_vec[[z]], data = model_df[[j]], REML=TRUE,
control = lmerControl(optimizer ="Nelder_Mead"))
#get coefficients and put in table
coeff <- data.frame(coef(summary(fit1))[ , "Estimate"]) ##2
coeff[,2] <- rownames(coeff)
coeff[,1] <- round(coeff[,1], 3)
colnames(coeff) <- c(names(model_df[j]), "model_var")
#put r2 in table
r <- rsquared(fit1) #gives R^2 values for models. "Marginal" is the R^2 for just the fixed effects, "Conditional" is the R^2 for everything.
r <- data.frame(r[,6])
colnames(r) <- names(model_df[j])
r$model_var <- "r^2"
r[,1] <- round(r[,1], 2)
coeff <- rbind(r,coeff)
coeff_list[[paste0("coeff_", names(model_df[j]))]] <- coeff
}
if (names(lmm_all[z]) %in% var_aic$Modnames){
#run the best model alone with REML=TRUE
fit1 <- lmer(formula_vec[[z]], data = model_df[[j]], REML=FALSE,
control = lmerControl(optimizer ="Nelder_Mead"))
#get coefficients and put in table
coeff <- data.frame(coef(summary(fit1))[ , "Estimate"]) ##2
coeff[,2] <- rownames(coeff)
coeff[,1] <- round(coeff[,1], 3)
coeff$comb <- paste0(coeff[,2], " (", coeff[,1], ")")
for (g in seq(along=1:nrow(top))){
if(rownames(top)[[g]] == z){
top$coef[[g]] <- paste(unlist(coeff$comb), collapse=", ")
}
}
}
}
}
}
top_models <- rbind(top_models, top)
}
#create all combinations of random / fixed effects
effects_comb <-
unlist( sapply( seq_len(length(effects)),
function(i) {
apply( combn(effects,i), 2, function(x) paste(x, collapse = "+"))
}))
var_comb <- expand.grid(response, effects_comb)
var_comb <- var_comb[grepl("1", var_comb$Var2), ] #only keep in fixed/random combos
var_comb$Var2 <- as.character(var_comb$Var2)
#can't have height and TWI separately when the interaction is in
for (q in seq(along=var_comb$Var2)){
cell <- var_comb$Var2[[q]]
if(grepl("\\*", cell)){
if(grepl("\\+TWI.ln", cell)){
var_comb$Var2[[q]] <- gsub("\\+TWI.ln", "", var_comb$Var2[[q]])
}
if(grepl("\\+height.ln.m", cell)){
var_comb$Var2[[q]] <- gsub("\\+height.ln.m\\+", "\\+", var_comb$Var2[[q]])
}
}
}
var_comb <- unique(var_comb[,1:2])
formula_vec <- sprintf("%s ~ %s", var_comb$Var1, var_comb$Var2)
lmm_all <- lapply(formula_vec, function(x){
fit1 <- lmer(x, data = model_df[[j]], REML=FALSE,
control = lmerControl(optimizer ="Nelder_Mead"))
return(fit1)
})
top_models <- NULL
coeff_list <- list()
for (i in seq(along=c(1:4))){
for (j in seq(along=model_df)){
#ALL YEARS
if(j == 1 & i == 1){
response <- "resist.value"
effects <- best_mod_full
#create all combinations of random / fixed effects
effects_comb <-
unlist(sapply(seq_len(length(effects)), function(i) {
apply( combn(effects,i), 2, function(x) paste(x, collapse = "+"))
}))
#pair response with effect and sub out combinations that don't include random effects
#in general, if two variables are >70% correlated, you can toss one of them without significantly affecting the results
var_comb <- expand.grid(response, effects_comb)
var_comb <- var_comb[grepl("1", var_comb$Var2), ] #only keep in fixed/random combos
var_comb$Var2 <- as.character(var_comb$Var2)
#can't have height and TWI separately when the interaction is in
for (q in seq(along=var_comb$Var2)){
cell <- var_comb$Var2[[q]]
if(grepl("\\*", cell)){
if(grepl("\\+TWI.ln", cell)){
var_comb$Var2[[q]] <- gsub("\\+TWI.ln", "", var_comb$Var2[[q]])
}
if(grepl("\\+height.ln.m", cell)){
var_comb$Var2[[q]] <- gsub("\\+height.ln.m\\+", "\\+", var_comb$Var2[[q]])
}
}
}
var_comb <- unique(var_comb[,1:2])
# formulas for all combinations. $Var1 is the response, and $Var2 is the effect
# for good stats, you should have no more total parameters than 1/10th the number of observations in your dataset
formula_vec <- sprintf("%s ~ %s", var_comb$Var1, var_comb$Var2)
lmm_all <- lapply(formula_vec, function(x){
fit1 <- lmer(x, data = model_df[[j]], REML=FALSE,
control = lmerControl(optimizer ="Nelder_Mead"))
return(fit1)
})
names(lmm_all) <- formula_vec
var_aic <- aictab(lmm_all, second.ord=TRUE, sort=TRUE) #rank based on AICc
var_aic$Modnames <- as.character(var_aic$Modnames)
best_mod_traits$best_model[[i]] <- var_aic$Modnames[[1]]
#get all mods <2 dAIC
var_aic <- var_aic[var_aic$Delta_AICc <= 2, ]
top <- var_aic[,c(1,4)]
top$Delta_AICc <- round(top$Delta_AICc, 2)
top$scenario <- mods[[i]]
top$coef <- NA
for (z in seq(along = lmm_all)){
if (names(lmm_all[z]) == var_aic$Modnames[[1]]){
#run the best model alone with REML=TRUE
fit1 <- lmer(formula_vec[[z]], data = model_df[[j]], REML=TRUE,
control = lmerControl(optimizer ="Nelder_Mead"))
#get coefficients and put in table
coeff <- data.frame(coef(summary(fit1))[ , "Estimate"]) ##2
coeff[,2] <- rownames(coeff)
coeff[,1] <- round(coeff[,1], 3)
colnames(coeff) <- c(names(model_df[j]), "model_var")
#put r2 in table
r <- rsquared(fit1) #gives R^2 values for models. "Marginal" is the R^2 for just the fixed effects, "Conditional" is the R^2 for everything.
r <- data.frame(r[,6])
colnames(r) <- names(model_df[j])
r$model_var <- "r^2"
r[,1] <- round(r[,1], 2)
coeff <- rbind(r,coeff)
coeff_list[[paste0("coeff_", names(model_df[j]))]] <- coeff
}
if (names(lmm_all[z]) %in% var_aic$Modnames){
#run the best model alone with REML=TRUE
fit1 <- lmer(formula_vec[[z]], data = model_df[[j]], REML=FALSE,
control = lmerControl(optimizer ="Nelder_Mead"))
#get coefficients and put in table
coeff <- data.frame(coef(summary(fit1))[ , "Estimate"]) ##2
coeff[,2] <- rownames(coeff)
coeff[,1] <- round(coeff[,1], 3)
coeff$comb <- paste0(coeff[,2], " (", coeff[,1], ")")
for (g in seq(along=1:nrow(top))){
if(rownames(top)[[g]] == z){
top$coef[[g]] <- paste(unlist(coeff$comb), collapse=", ")
}
}
}
}
#INDIVIDUAL YEARS
} else if (j == i){
response <- "resist.value"
effects <- best_mod_full_year
#create all combinations of random / fixed effects
effects_comb <-
unlist( sapply( seq_len(length(effects)),
function(i) {
apply( combn(effects,i), 2, function(x) paste(x, collapse = "+"))
}))
var_comb <- expand.grid(response, effects_comb)
var_comb <- var_comb[grepl("1", var_comb$Var2), ] #only keep in fixed/random combos
var_comb$Var2 <- as.character(var_comb$Var2)
#can't have height and TWI separately when the interaction is in
for (q in seq(along=var_comb$Var2)){
cell <- var_comb$Var2[[q]]
if(grepl("\\*", cell)){
if(grepl("\\+TWI.ln", cell)){
var_comb$Var2[[q]] <- gsub("\\+TWI.ln", "", var_comb$Var2[[q]])
}
if(grepl("\\+height.ln.m", cell)){
var_comb$Var2[[q]] <- gsub("\\+height.ln.m\\+", "\\+", var_comb$Var2[[q]])
}
}
}
var_comb <- unique(var_comb[,1:2])
formula_vec <- sprintf("%s ~ %s", var_comb$Var1, var_comb$Var2)
lmm_all <- lapply(formula_vec, function(x){
fit1 <- lmer(x, data = model_df[[j]], REML=FALSE,
control = lmerControl(optimizer ="Nelder_Mead"))
return(fit1)
})
names(lmm_all) <- formula_vec
var_aic <- aictab(lmm_all, second.ord=TRUE, sort=TRUE) #rank based on AICc
var_aic$Modnames <- as.character(var_aic$Modnames)
best_mod_traits$best_model[[i]] <- var_aic$Modnames[[1]]
#get all mods <2 dAIC
var_aic <- var_aic[var_aic$Delta_AICc <= 2, ]
top <- var_aic[,c(1,4)]
top$Delta_AICc <- round(top$Delta_AICc, 2)
top$scenario <- mods[[i]]
top$coef <- NA
for (z in seq(along = lmm_all)){
if (names(lmm_all[z]) == var_aic$Modnames[[1]]){
#run the best model alone with REML=TRUE
fit1 <- lmer(formula_vec[[z]], data = model_df[[j]], REML=TRUE,
control = lmerControl(optimizer ="Nelder_Mead"))
#get coefficients and put in table
coeff <- data.frame(coef(summary(fit1))[ , "Estimate"]) ##2
coeff[,2] <- rownames(coeff)
coeff[,1] <- round(coeff[,1], 3)
colnames(coeff) <- c(names(model_df[j]), "model_var")
#put r2 in table
r <- rsquared(fit1) #gives R^2 values for models. "Marginal" is the R^2 for just the fixed effects, "Conditional" is the R^2 for everything.
r <- data.frame(r[,6])
colnames(r) <- names(model_df[j])
r$model_var <- "r^2"
r[,1] <- round(r[,1], 2)
coeff <- rbind(r,coeff)
coeff_list[[paste0("coeff_", names(model_df[j]))]] <- coeff
}
if (names(lmm_all[z]) %in% var_aic$Modnames){
#run the best model alone with REML=TRUE
fit1 <- lmer(formula_vec[[z]], data = model_df[[j]], REML=FALSE,
control = lmerControl(optimizer ="Nelder_Mead"))
#get coefficients and put in table
coeff <- data.frame(coef(summary(fit1))[ , "Estimate"]) ##2
coeff[,2] <- rownames(coeff)
coeff[,1] <- round(coeff[,1], 3)
coeff$comb <- paste0(coeff[,2], " (", coeff[,1], ")")
for (g in seq(along=1:nrow(top))){
if(rownames(top)[[g]] == z){
top$coef[[g]] <- paste(unlist(coeff$comb), collapse=", ")
}
}
}
}
}
}
top_models <- rbind(top_models, top)
}
View(top_models)
top_models$Modnames
write.csv(best_mod_traits, "manuscript/tables_figures/tested_traits_best.csv", row.names=FALSE)
write.csv(top_models, "manuscript/tables_figures/top_models_dAIC.csv", row.names=FALSE)
duplicated(top_models$Modnames)
